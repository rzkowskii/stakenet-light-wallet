// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: rpc.proto
#ifndef GRPC_rpc_2eproto__INCLUDED
#define GRPC_rpc_2eproto__INCLUDED

#include "rpc.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace lnrpc {

//
// Comments in this file will be directly parsed into the API
// Documentation as descriptions of the associated method, message, or field.
// These descriptions should go right above the definition of the object, and
// can be in either block or // comment format.
//
// An RPC method can be matched to an lncli command by placing a line in the
// beginning of the description in exactly the following format:
// lncli: `methodname`
//
// Failure to specify the exact name of the command will cause documentation
// generation to fail.
//
// More information on how exactly the gRPC documentation is generated from
// this proto file can be found here:
// https://github.com/lightninglabs/lightning-api
//
// Lightning is the main RPC server of the daemon.
class Lightning final {
 public:
  static constexpr char const* service_full_name() {
    return "lnrpc.Lightning";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // lncli: `walletbalance`
    // WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
    // confirmed unspent outputs and all unconfirmed unspent outputs under control
    // of the wallet.
    virtual ::grpc::Status WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::lnrpc::WalletBalanceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::WalletBalanceResponse>> AsyncWalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::WalletBalanceResponse>>(AsyncWalletBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::WalletBalanceResponse>> PrepareAsyncWalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::WalletBalanceResponse>>(PrepareAsyncWalletBalanceRaw(context, request, cq));
    }
    // lncli: `channelbalance`
    // ChannelBalance returns a report on the total funds across all open channels,
    // categorized in local/remote, pending local/remote and unsettled local/remote
    // balances.
    virtual ::grpc::Status ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::lnrpc::ChannelBalanceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBalanceResponse>> AsyncChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBalanceResponse>>(AsyncChannelBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBalanceResponse>> PrepareAsyncChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBalanceResponse>>(PrepareAsyncChannelBalanceRaw(context, request, cq));
    }
    // lncli: `listchaintxns`
    // GetTransactions returns a list describing all the known transactions
    // relevant to the wallet.
    virtual ::grpc::Status GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::lnrpc::TransactionDetails* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::TransactionDetails>> AsyncGetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::TransactionDetails>>(AsyncGetTransactionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::TransactionDetails>> PrepareAsyncGetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::TransactionDetails>>(PrepareAsyncGetTransactionsRaw(context, request, cq));
    }
    // lncli: `estimatefee`
    // EstimateFee asks the chain backend to estimate the fee rate and total fees
    // for a transaction that pays to multiple specified outputs.
    //
    // When using REST, the `AddrToAmount` map type can be set by appending
    // `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
    // map type doesn't appear in the REST API documentation because of a bug in
    // the grpc-gateway library.
    virtual ::grpc::Status EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::lnrpc::EstimateFeeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::EstimateFeeResponse>> AsyncEstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::EstimateFeeResponse>>(AsyncEstimateFeeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::EstimateFeeResponse>> PrepareAsyncEstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::EstimateFeeResponse>>(PrepareAsyncEstimateFeeRaw(context, request, cq));
    }
    // lncli: `sendcoins`
    // SendCoins executes a request to send coins to a particular address. Unlike
    // SendMany, this RPC call only allows creating a single output at a time. If
    // neither target_conf, or sat_per_vbyte are set, then the internal wallet will
    // consult its fee model to determine a fee for the default confirmation
    // target.
    virtual ::grpc::Status SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::lnrpc::SendCoinsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendCoinsResponse>> AsyncSendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendCoinsResponse>>(AsyncSendCoinsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendCoinsResponse>> PrepareAsyncSendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendCoinsResponse>>(PrepareAsyncSendCoinsRaw(context, request, cq));
    }
    // lncli: `listunspent`
    // Deprecated, use walletrpc.ListUnspent instead.
    //
    // ListUnspent returns a list of all utxos spendable by the wallet with a
    // number of confirmations between the specified minimum and maximum.
    virtual ::grpc::Status ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::lnrpc::ListUnspentResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListUnspentResponse>> AsyncListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListUnspentResponse>>(AsyncListUnspentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListUnspentResponse>> PrepareAsyncListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListUnspentResponse>>(PrepareAsyncListUnspentRaw(context, request, cq));
    }
    //
    // SubscribeTransactions creates a uni-directional stream from the server to
    // the client in which any newly discovered transactions relevant to the
    // wallet are sent over.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::Transaction>> SubscribeTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::Transaction>>(SubscribeTransactionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Transaction>> AsyncSubscribeTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Transaction>>(AsyncSubscribeTransactionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Transaction>> PrepareAsyncSubscribeTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Transaction>>(PrepareAsyncSubscribeTransactionsRaw(context, request, cq));
    }
    // lncli: `sendmany`
    // SendMany handles a request for a transaction that creates multiple specified
    // outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
    // the internal wallet will consult its fee model to determine a fee for the
    // default confirmation target.
    virtual ::grpc::Status SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::lnrpc::SendManyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendManyResponse>> AsyncSendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendManyResponse>>(AsyncSendManyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendManyResponse>> PrepareAsyncSendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendManyResponse>>(PrepareAsyncSendManyRaw(context, request, cq));
    }
    // lncli: `newaddress`
    // NewAddress creates a new address under control of the local wallet.
    virtual ::grpc::Status NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::lnrpc::NewAddressResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NewAddressResponse>> AsyncNewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NewAddressResponse>>(AsyncNewAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NewAddressResponse>> PrepareAsyncNewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NewAddressResponse>>(PrepareAsyncNewAddressRaw(context, request, cq));
    }
    // lncli: `signmessage`
    // SignMessage signs a message with this node's private key. The returned
    // signature string is `zbase32` encoded and pubkey recoverable, meaning that
    // only the message digest and signature are needed for verification.
    virtual ::grpc::Status SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::lnrpc::SignMessageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SignMessageResponse>> AsyncSignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SignMessageResponse>>(AsyncSignMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SignMessageResponse>> PrepareAsyncSignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SignMessageResponse>>(PrepareAsyncSignMessageRaw(context, request, cq));
    }
    // lncli: `verifymessage`
    // VerifyMessage verifies a signature over a msg. The signature must be
    // zbase32 encoded and signed by an active node in the resident node's
    // channel database. In addition to returning the validity of the signature,
    // VerifyMessage also returns the recovered pubkey from the signature.
    virtual ::grpc::Status VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::lnrpc::VerifyMessageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyMessageResponse>> AsyncVerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyMessageResponse>>(AsyncVerifyMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyMessageResponse>> PrepareAsyncVerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyMessageResponse>>(PrepareAsyncVerifyMessageRaw(context, request, cq));
    }
    // lncli: `connect`
    // ConnectPeer attempts to establish a connection to a remote peer. This is at
    // the networking level, and is used for communication between nodes. This is
    // distinct from establishing a channel with a peer.
    virtual ::grpc::Status ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::lnrpc::ConnectPeerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ConnectPeerResponse>> AsyncConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ConnectPeerResponse>>(AsyncConnectPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ConnectPeerResponse>> PrepareAsyncConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ConnectPeerResponse>>(PrepareAsyncConnectPeerRaw(context, request, cq));
    }
    // lncli: `disconnect`
    // DisconnectPeer attempts to disconnect one peer from another identified by a
    // given pubKey. In the case that we currently have a pending or active channel
    // with the target peer, then this action will be not be allowed.
    virtual ::grpc::Status DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::lnrpc::DisconnectPeerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DisconnectPeerResponse>> AsyncDisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DisconnectPeerResponse>>(AsyncDisconnectPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DisconnectPeerResponse>> PrepareAsyncDisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DisconnectPeerResponse>>(PrepareAsyncDisconnectPeerRaw(context, request, cq));
    }
    // lncli: `listpeers`
    // ListPeers returns a verbose listing of all currently active peers.
    virtual ::grpc::Status ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::lnrpc::ListPeersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPeersResponse>> AsyncListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPeersResponse>>(AsyncListPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPeersResponse>> PrepareAsyncListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPeersResponse>>(PrepareAsyncListPeersRaw(context, request, cq));
    }
    //
    // SubscribePeerEvents creates a uni-directional stream from the server to
    // the client in which any events relevant to the state of peers are sent
    // over. Events include peers going online and offline.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::PeerEvent>> SubscribePeerEvents(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::PeerEvent>>(SubscribePeerEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::PeerEvent>> AsyncSubscribePeerEvents(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::PeerEvent>>(AsyncSubscribePeerEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::PeerEvent>> PrepareAsyncSubscribePeerEvents(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::PeerEvent>>(PrepareAsyncSubscribePeerEventsRaw(context, request, cq));
    }
    // lncli: `getinfo`
    // GetInfo returns general information concerning the lightning node including
    // it's identity pubkey, alias, the chains it is connected to, and information
    // concerning the number of open+pending channels.
    virtual ::grpc::Status GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::lnrpc::GetInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetInfoResponse>> AsyncGetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetInfoResponse>>(AsyncGetInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetInfoResponse>> PrepareAsyncGetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetInfoResponse>>(PrepareAsyncGetInfoRaw(context, request, cq));
    }
    // * lncli: `getrecoveryinfo`
    // GetRecoveryInfo returns information concerning the recovery mode including
    // whether it's in a recovery mode, whether the recovery is finished, and the
    // progress made so far.
    virtual ::grpc::Status GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::lnrpc::GetRecoveryInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetRecoveryInfoResponse>> AsyncGetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetRecoveryInfoResponse>>(AsyncGetRecoveryInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetRecoveryInfoResponse>> PrepareAsyncGetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetRecoveryInfoResponse>>(PrepareAsyncGetRecoveryInfoRaw(context, request, cq));
    }
    // TODO(roasbeef): merge with below with bool?
    //
    // lncli: `pendingchannels`
    // PendingChannels returns a list of all the channels that are currently
    // considered "pending". A channel is pending if it has finished the funding
    // workflow and is waiting for confirmations for the funding txn, or is in the
    // process of closure, either initiated cooperatively or non-cooperatively.
    virtual ::grpc::Status PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::lnrpc::PendingChannelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PendingChannelsResponse>> AsyncPendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PendingChannelsResponse>>(AsyncPendingChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PendingChannelsResponse>> PrepareAsyncPendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PendingChannelsResponse>>(PrepareAsyncPendingChannelsRaw(context, request, cq));
    }
    // lncli: `listchannels`
    // ListChannels returns a description of all the open channels that this node
    // is a participant in.
    virtual ::grpc::Status ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::lnrpc::ListChannelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListChannelsResponse>> AsyncListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListChannelsResponse>>(AsyncListChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListChannelsResponse>> PrepareAsyncListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListChannelsResponse>>(PrepareAsyncListChannelsRaw(context, request, cq));
    }
    //
    // SubscribeChannelEvents creates a uni-directional stream from the server to
    // the client in which any updates relevant to the state of the channels are
    // sent over. Events include new active channels, inactive channels, and closed
    // channels.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::ChannelEventUpdate>> SubscribeChannelEvents(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::ChannelEventUpdate>>(SubscribeChannelEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChannelEventUpdate>> AsyncSubscribeChannelEvents(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChannelEventUpdate>>(AsyncSubscribeChannelEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChannelEventUpdate>> PrepareAsyncSubscribeChannelEvents(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChannelEventUpdate>>(PrepareAsyncSubscribeChannelEventsRaw(context, request, cq));
    }
    // lncli: `closedchannels`
    // ClosedChannels returns a description of all the closed channels that
    // this node was a participant in.
    virtual ::grpc::Status ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::lnrpc::ClosedChannelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ClosedChannelsResponse>> AsyncClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ClosedChannelsResponse>>(AsyncClosedChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ClosedChannelsResponse>> PrepareAsyncClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ClosedChannelsResponse>>(PrepareAsyncClosedChannelsRaw(context, request, cq));
    }
    //
    // OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
    // call is meant to be consumed by clients to the REST proxy. As with all
    // other sync calls, all byte slices are intended to be populated as hex
    // encoded strings.
    virtual ::grpc::Status OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::lnrpc::ChannelPoint* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelPoint>> AsyncOpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelPoint>>(AsyncOpenChannelSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelPoint>> PrepareAsyncOpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelPoint>>(PrepareAsyncOpenChannelSyncRaw(context, request, cq));
    }
    // lncli: `openchannel`
    // OpenChannel attempts to open a singly funded channel specified in the
    // request to a remote peer. Users are able to specify a target number of
    // blocks that the funding transaction should be confirmed in, or a manual fee
    // rate to us for the funding transaction. If neither are specified, then a
    // lax block confirmation target is used. Each OpenStatusUpdate will return
    // the pending channel ID of the in-progress channel. Depending on the
    // arguments specified in the OpenChannelRequest, this pending channel ID can
    // then be used to manually progress the channel funding flow.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::OpenStatusUpdate>> OpenChannel(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::OpenStatusUpdate>>(OpenChannelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::OpenStatusUpdate>> AsyncOpenChannel(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::OpenStatusUpdate>>(AsyncOpenChannelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::OpenStatusUpdate>> PrepareAsyncOpenChannel(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::OpenStatusUpdate>>(PrepareAsyncOpenChannelRaw(context, request, cq));
    }
    //
    // FundingStateStep is an advanced funding related call that allows the caller
    // to either execute some preparatory steps for a funding workflow, or
    // manually progress a funding workflow. The primary way a funding flow is
    // identified is via its pending channel ID. As an example, this method can be
    // used to specify that we're expecting a funding flow for a particular
    // pending channel ID, for which we need to use specific parameters.
    // Alternatively, this can be used to interactively drive PSBT signing for
    // funding for partially complete funding transactions.
    virtual ::grpc::Status FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::lnrpc::FundingStateStepResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FundingStateStepResp>> AsyncFundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FundingStateStepResp>>(AsyncFundingStateStepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FundingStateStepResp>> PrepareAsyncFundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FundingStateStepResp>>(PrepareAsyncFundingStateStepRaw(context, request, cq));
    }
    //
    // ChannelAcceptor dispatches a bi-directional streaming RPC in which
    // OpenChannel requests are sent to the client and the client responds with
    // a boolean that tells LND whether or not to accept the channel. This allows
    // node operators to specify their own criteria for accepting inbound channels
    // through a single persistent connection.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>> ChannelAcceptor(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>>(ChannelAcceptorRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>> AsyncChannelAcceptor(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>>(AsyncChannelAcceptorRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>> PrepareAsyncChannelAcceptor(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>>(PrepareAsyncChannelAcceptorRaw(context, cq));
    }
    // lncli: `closechannel`
    // CloseChannel attempts to close an active channel identified by its channel
    // outpoint (ChannelPoint). The actions of this method can additionally be
    // augmented to attempt a force close after a timeout period in the case of an
    // inactive peer. If a non-force close (cooperative closure) is requested,
    // then the user can specify either a target number of blocks until the
    // closure transaction is confirmed, or a manual fee rate. If neither are
    // specified, then a default lax, block confirmation target is used.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::CloseStatusUpdate>> CloseChannel(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::CloseStatusUpdate>>(CloseChannelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::CloseStatusUpdate>> AsyncCloseChannel(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::CloseStatusUpdate>>(AsyncCloseChannelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::CloseStatusUpdate>> PrepareAsyncCloseChannel(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::CloseStatusUpdate>>(PrepareAsyncCloseChannelRaw(context, request, cq));
    }
    // lncli: `abandonchannel`
    // AbandonChannel removes all channel state from the database except for a
    // close summary. This method can be used to get rid of permanently unusable
    // channels due to bugs fixed in newer versions of lnd. This method can also be
    // used to remove externally funded channels where the funding transaction was
    // never broadcast. Only available for non-externally funded channels in dev
    // build.
    virtual ::grpc::Status AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::lnrpc::AbandonChannelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AbandonChannelResponse>> AsyncAbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AbandonChannelResponse>>(AsyncAbandonChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AbandonChannelResponse>> PrepareAsyncAbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AbandonChannelResponse>>(PrepareAsyncAbandonChannelRaw(context, request, cq));
    }
    // lncli: `sendpayment`
    // Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
    // bi-directional streaming RPC for sending payments through the Lightning
    // Network. A single RPC invocation creates a persistent bi-directional
    // stream allowing clients to rapidly send payments through the Lightning
    // Network with a single persistent connection.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>> SendPayment(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>>(SendPaymentRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>> AsyncSendPayment(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>>(AsyncSendPaymentRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>> PrepareAsyncSendPayment(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>>(PrepareAsyncSendPaymentRaw(context, cq));
    }
    //
    // SendPaymentSync is the synchronous non-streaming version of SendPayment.
    // This RPC is intended to be consumed by clients of the REST proxy.
    // Additionally, this RPC expects the destination's public key and the payment
    // hash (if any) to be encoded as hex strings.
    virtual ::grpc::Status SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::lnrpc::SendResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>> AsyncSendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>>(AsyncSendPaymentSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>> PrepareAsyncSendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>>(PrepareAsyncSendPaymentSyncRaw(context, request, cq));
    }
    // lncli: `sendtoroute`
    // Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
    // streaming RPC for sending payment through the Lightning Network. This
    // method differs from SendPayment in that it allows users to specify a full
    // route manually. This can be used for things like rebalancing, and atomic
    // swaps.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>> SendToRoute(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>>(SendToRouteRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>> AsyncSendToRoute(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>>(AsyncSendToRouteRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>> PrepareAsyncSendToRoute(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>>(PrepareAsyncSendToRouteRaw(context, cq));
    }
    //
    // SendToRouteSync is a synchronous version of SendToRoute. It Will block
    // until the payment either fails or succeeds.
    virtual ::grpc::Status SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::lnrpc::SendResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>> AsyncSendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>>(AsyncSendToRouteSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>> PrepareAsyncSendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>>(PrepareAsyncSendToRouteSyncRaw(context, request, cq));
    }
    // lncli: `addinvoice`
    // AddInvoice attempts to add a new invoice to the invoice database. Any
    // duplicated invoices are rejected, therefore all invoices *must* have a
    // unique payment preimage.
    virtual ::grpc::Status AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::lnrpc::AddInvoiceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AddInvoiceResponse>> AsyncAddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AddInvoiceResponse>>(AsyncAddInvoiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AddInvoiceResponse>> PrepareAsyncAddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AddInvoiceResponse>>(PrepareAsyncAddInvoiceRaw(context, request, cq));
    }
    // lncli: `listinvoices`
    // ListInvoices returns a list of all the invoices currently stored within the
    // database. Any active debug invoices are ignored. It has full support for
    // paginated responses, allowing users to query for specific invoices through
    // their add_index. This can be done by using either the first_index_offset or
    // last_index_offset fields included in the response as the index_offset of the
    // next request. By default, the first 100 invoices created will be returned.
    // Backwards pagination is also supported through the Reversed flag.
    virtual ::grpc::Status ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::lnrpc::ListInvoiceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListInvoiceResponse>> AsyncListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListInvoiceResponse>>(AsyncListInvoicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListInvoiceResponse>> PrepareAsyncListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListInvoiceResponse>>(PrepareAsyncListInvoicesRaw(context, request, cq));
    }
    // lncli: `lookupinvoice`
    // LookupInvoice attempts to look up an invoice according to its payment hash.
    // The passed payment hash *must* be exactly 32 bytes, if not, an error is
    // returned.
    virtual ::grpc::Status LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::lnrpc::Invoice* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::Invoice>> AsyncLookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::Invoice>>(AsyncLookupInvoiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::Invoice>> PrepareAsyncLookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::Invoice>>(PrepareAsyncLookupInvoiceRaw(context, request, cq));
    }
    //
    // SubscribeInvoices returns a uni-directional stream (server -> client) for
    // notifying the client of newly added/settled invoices. The caller can
    // optionally specify the add_index and/or the settle_index. If the add_index
    // is specified, then we'll first start by sending add invoice events for all
    // invoices with an add_index greater than the specified value. If the
    // settle_index is specified, the next, we'll send out all settle events for
    // invoices with a settle_index greater than the specified value. One or both
    // of these fields can be set. If no fields are set, then we'll only send out
    // the latest add/settle events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::Invoice>> SubscribeInvoices(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::Invoice>>(SubscribeInvoicesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Invoice>> AsyncSubscribeInvoices(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Invoice>>(AsyncSubscribeInvoicesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Invoice>> PrepareAsyncSubscribeInvoices(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::Invoice>>(PrepareAsyncSubscribeInvoicesRaw(context, request, cq));
    }
    // lncli: `decodepayreq`
    // DecodePayReq takes an encoded payment request string and attempts to decode
    // it, returning a full description of the conditions encoded within the
    // payment request.
    virtual ::grpc::Status DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::lnrpc::PayReq* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PayReq>> AsyncDecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PayReq>>(AsyncDecodePayReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PayReq>> PrepareAsyncDecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PayReq>>(PrepareAsyncDecodePayReqRaw(context, request, cq));
    }
    // lncli: `listpayments`
    // ListPayments returns a list of all outgoing payments.
    virtual ::grpc::Status ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::lnrpc::ListPaymentsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPaymentsResponse>> AsyncListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPaymentsResponse>>(AsyncListPaymentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPaymentsResponse>> PrepareAsyncListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPaymentsResponse>>(PrepareAsyncListPaymentsRaw(context, request, cq));
    }
    //
    // DeleteAllPayments deletes all outgoing payments from DB.
    virtual ::grpc::Status DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::lnrpc::DeleteAllPaymentsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteAllPaymentsResponse>> AsyncDeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteAllPaymentsResponse>>(AsyncDeleteAllPaymentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteAllPaymentsResponse>> PrepareAsyncDeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteAllPaymentsResponse>>(PrepareAsyncDeleteAllPaymentsRaw(context, request, cq));
    }
    // lncli: `describegraph`
    // DescribeGraph returns a description of the latest graph state from the
    // point of view of the node. The graph information is partitioned into two
    // components: all the nodes/vertexes, and all the edges that connect the
    // vertexes themselves. As this is a directed graph, the edges also contain
    // the node directional specific routing policy which includes: the time lock
    // delta, fee information, etc.
    virtual ::grpc::Status DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::lnrpc::ChannelGraph* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelGraph>> AsyncDescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelGraph>>(AsyncDescribeGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelGraph>> PrepareAsyncDescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelGraph>>(PrepareAsyncDescribeGraphRaw(context, request, cq));
    }
    // lncli: `getnodemetrics`
    // GetNodeMetrics returns node metrics calculated from the graph. Currently
    // the only supported metric is betweenness centrality of individual nodes.
    virtual ::grpc::Status GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::lnrpc::NodeMetricsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeMetricsResponse>> AsyncGetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeMetricsResponse>>(AsyncGetNodeMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeMetricsResponse>> PrepareAsyncGetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeMetricsResponse>>(PrepareAsyncGetNodeMetricsRaw(context, request, cq));
    }
    // lncli: `getchaninfo`
    // GetChanInfo returns the latest authenticated network announcement for the
    // given channel identified by its channel ID: an 8-byte integer which
    // uniquely identifies the location of transaction's funding output within the
    // blockchain.
    virtual ::grpc::Status GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::lnrpc::ChannelEdge* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelEdge>> AsyncGetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelEdge>>(AsyncGetChanInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelEdge>> PrepareAsyncGetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelEdge>>(PrepareAsyncGetChanInfoRaw(context, request, cq));
    }
    // lncli: `getnodeinfo`
    // GetNodeInfo returns the latest advertised, aggregated, and authenticated
    // channel information for the specified node identified by its public key.
    virtual ::grpc::Status GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::lnrpc::NodeInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeInfo>> AsyncGetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeInfo>>(AsyncGetNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeInfo>> PrepareAsyncGetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeInfo>>(PrepareAsyncGetNodeInfoRaw(context, request, cq));
    }
    // lncli: `queryroutes`
    // QueryRoutes attempts to query the daemon's Channel Router for a possible
    // route to a target destination capable of carrying a specific amount of
    // satoshis. The returned route contains the full details required to craft and
    // send an HTLC, also including the necessary information that should be
    // present within the Sphinx packet encapsulated within the HTLC.
    //
    // When using REST, the `dest_custom_records` map type can be set by appending
    // `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
    // to the URL. Unfortunately this map type doesn't appear in the REST API
    // documentation because of a bug in the grpc-gateway library.
    virtual ::grpc::Status QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::lnrpc::QueryRoutesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::QueryRoutesResponse>> AsyncQueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::QueryRoutesResponse>>(AsyncQueryRoutesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::QueryRoutesResponse>> PrepareAsyncQueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::QueryRoutesResponse>>(PrepareAsyncQueryRoutesRaw(context, request, cq));
    }
    // lncli: `getnetworkinfo`
    // GetNetworkInfo returns some basic stats about the known channel graph from
    // the point of view of the node.
    virtual ::grpc::Status GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::lnrpc::NetworkInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NetworkInfo>> AsyncGetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NetworkInfo>>(AsyncGetNetworkInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NetworkInfo>> PrepareAsyncGetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NetworkInfo>>(PrepareAsyncGetNetworkInfoRaw(context, request, cq));
    }
    // lncli: `stop`
    // StopDaemon will send a shutdown request to the interrupt handler, triggering
    // a graceful shutdown of the daemon.
    virtual ::grpc::Status StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::lnrpc::StopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::StopResponse>> AsyncStopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::StopResponse>>(AsyncStopDaemonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::StopResponse>> PrepareAsyncStopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::StopResponse>>(PrepareAsyncStopDaemonRaw(context, request, cq));
    }
    //
    // SubscribeChannelGraph launches a streaming RPC that allows the caller to
    // receive notifications upon any changes to the channel graph topology from
    // the point of view of the responding node. Events notified include: new
    // nodes coming online, nodes updating their authenticated attributes, new
    // channels being advertised, updates in the routing policy for a directional
    // channel edge, and when channels are closed on-chain.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::GraphTopologyUpdate>> SubscribeChannelGraph(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::GraphTopologyUpdate>>(SubscribeChannelGraphRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::GraphTopologyUpdate>> AsyncSubscribeChannelGraph(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::GraphTopologyUpdate>>(AsyncSubscribeChannelGraphRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::GraphTopologyUpdate>> PrepareAsyncSubscribeChannelGraph(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::GraphTopologyUpdate>>(PrepareAsyncSubscribeChannelGraphRaw(context, request, cq));
    }
    // lncli: `debuglevel`
    // DebugLevel allows a caller to programmatically set the logging verbosity of
    // lnd. The logging can be targeted according to a coarse daemon-wide logging
    // level, or in a granular fashion to specify the logging for a target
    // sub-system.
    virtual ::grpc::Status DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::lnrpc::DebugLevelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DebugLevelResponse>> AsyncDebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DebugLevelResponse>>(AsyncDebugLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DebugLevelResponse>> PrepareAsyncDebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DebugLevelResponse>>(PrepareAsyncDebugLevelRaw(context, request, cq));
    }
    // lncli: `feereport`
    // FeeReport allows the caller to obtain a report detailing the current fee
    // schedule enforced by the node globally for each channel.
    virtual ::grpc::Status FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::lnrpc::FeeReportResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FeeReportResponse>> AsyncFeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FeeReportResponse>>(AsyncFeeReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FeeReportResponse>> PrepareAsyncFeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FeeReportResponse>>(PrepareAsyncFeeReportRaw(context, request, cq));
    }
    // lncli: `updatechanpolicy`
    // UpdateChannelPolicy allows the caller to update the fee schedule and
    // channel policies for all channels globally, or a particular channel.
    virtual ::grpc::Status UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::lnrpc::PolicyUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PolicyUpdateResponse>> AsyncUpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PolicyUpdateResponse>>(AsyncUpdateChannelPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PolicyUpdateResponse>> PrepareAsyncUpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PolicyUpdateResponse>>(PrepareAsyncUpdateChannelPolicyRaw(context, request, cq));
    }
    // lncli: `fwdinghistory`
    // ForwardingHistory allows the caller to query the htlcswitch for a record of
    // all HTLCs forwarded within the target time range, and integer offset
    // within that time range. If no time-range is specified, then the first chunk
    // of the past 24 hrs of forwarding history are returned.
    //
    // A list of forwarding events are returned. The size of each forwarding event
    // is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
    // As a result each message can only contain 50k entries. Each response has
    // the index offset of the last entry. The index offset can be provided to the
    // request to allow the caller to skip a series of records.
    virtual ::grpc::Status ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::lnrpc::ForwardingHistoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ForwardingHistoryResponse>> AsyncForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ForwardingHistoryResponse>>(AsyncForwardingHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ForwardingHistoryResponse>> PrepareAsyncForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ForwardingHistoryResponse>>(PrepareAsyncForwardingHistoryRaw(context, request, cq));
    }
    // lncli: `exportchanbackup`
    // ExportChannelBackup attempts to return an encrypted static channel backup
    // for the target channel identified by it channel point. The backup is
    // encrypted with a key generated from the aezeed seed of the user. The
    // returned backup can either be restored using the RestoreChannelBackup
    // method once lnd is running, or via the InitWallet and UnlockWallet methods
    // from the WalletUnlocker service.
    virtual ::grpc::Status ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::lnrpc::ChannelBackup* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBackup>> AsyncExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBackup>>(AsyncExportChannelBackupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBackup>> PrepareAsyncExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBackup>>(PrepareAsyncExportChannelBackupRaw(context, request, cq));
    }
    //
    // ExportAllChannelBackups returns static channel backups for all existing
    // channels known to lnd. A set of regular singular static channel backups for
    // each channel are returned. Additionally, a multi-channel backup is returned
    // as well, which contains a single encrypted blob containing the backups of
    // each channel.
    virtual ::grpc::Status ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::lnrpc::ChanBackupSnapshot* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChanBackupSnapshot>> AsyncExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChanBackupSnapshot>>(AsyncExportAllChannelBackupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChanBackupSnapshot>> PrepareAsyncExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChanBackupSnapshot>>(PrepareAsyncExportAllChannelBackupsRaw(context, request, cq));
    }
    //
    // VerifyChanBackup allows a caller to verify the integrity of a channel backup
    // snapshot. This method will accept either a packed Single or a packed Multi.
    // Specifying both will result in an error.
    virtual ::grpc::Status VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::lnrpc::VerifyChanBackupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyChanBackupResponse>> AsyncVerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyChanBackupResponse>>(AsyncVerifyChanBackupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyChanBackupResponse>> PrepareAsyncVerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyChanBackupResponse>>(PrepareAsyncVerifyChanBackupRaw(context, request, cq));
    }
    // lncli: `restorechanbackup`
    // RestoreChannelBackups accepts a set of singular channel backups, or a
    // single encrypted multi-chan backup and attempts to recover any funds
    // remaining within the channel. If we are able to unpack the backup, then the
    // new channel will be shown under listchannels, as well as pending channels.
    virtual ::grpc::Status RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::lnrpc::RestoreBackupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::RestoreBackupResponse>> AsyncRestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::RestoreBackupResponse>>(AsyncRestoreChannelBackupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::RestoreBackupResponse>> PrepareAsyncRestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::RestoreBackupResponse>>(PrepareAsyncRestoreChannelBackupsRaw(context, request, cq));
    }
    //
    // SubscribeChannelBackups allows a client to sub-subscribe to the most up to
    // date information concerning the state of all channel backups. Each time a
    // new channel is added, we return the new set of channels, along with a
    // multi-chan backup containing the backup info for all channels. Each time a
    // channel is closed, we send a new update, which contains new new chan back
    // ups, but the updated set of encrypted multi-chan backups with the closed
    // channel(s) removed.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::ChanBackupSnapshot>> SubscribeChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lnrpc::ChanBackupSnapshot>>(SubscribeChannelBackupsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChanBackupSnapshot>> AsyncSubscribeChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChanBackupSnapshot>>(AsyncSubscribeChannelBackupsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChanBackupSnapshot>> PrepareAsyncSubscribeChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChanBackupSnapshot>>(PrepareAsyncSubscribeChannelBackupsRaw(context, request, cq));
    }
    // lncli: `bakemacaroon`
    // BakeMacaroon allows the creation of a new macaroon with custom read and
    // write permissions. No first-party caveats are added since this can be done
    // offline.
    virtual ::grpc::Status BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::lnrpc::BakeMacaroonResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::BakeMacaroonResponse>> AsyncBakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::BakeMacaroonResponse>>(AsyncBakeMacaroonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::BakeMacaroonResponse>> PrepareAsyncBakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::BakeMacaroonResponse>>(PrepareAsyncBakeMacaroonRaw(context, request, cq));
    }
    // lncli: `listmacaroonids`
    // ListMacaroonIDs returns all root key IDs that are in use.
    virtual ::grpc::Status ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::lnrpc::ListMacaroonIDsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListMacaroonIDsResponse>> AsyncListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListMacaroonIDsResponse>>(AsyncListMacaroonIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListMacaroonIDsResponse>> PrepareAsyncListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListMacaroonIDsResponse>>(PrepareAsyncListMacaroonIDsRaw(context, request, cq));
    }
    // lncli: `deletemacaroonid`
    // DeleteMacaroonID deletes the specified macaroon ID and invalidates all
    // macaroons derived from that ID.
    virtual ::grpc::Status DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::lnrpc::DeleteMacaroonIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteMacaroonIDResponse>> AsyncDeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteMacaroonIDResponse>>(AsyncDeleteMacaroonIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteMacaroonIDResponse>> PrepareAsyncDeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteMacaroonIDResponse>>(PrepareAsyncDeleteMacaroonIDRaw(context, request, cq));
    }
    // lncli: `listpermissions`
    // ListPermissions lists all RPC method URIs and their required macaroon
    // permissions to access them.
    virtual ::grpc::Status ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::lnrpc::ListPermissionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPermissionsResponse>> AsyncListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPermissionsResponse>>(AsyncListPermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPermissionsResponse>> PrepareAsyncListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPermissionsResponse>>(PrepareAsyncListPermissionsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // lncli: `walletbalance`
      // WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      // confirmed unspent outputs and all unconfirmed unspent outputs under control
      // of the wallet.
      virtual void WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WalletBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::WalletBalanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WalletBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WalletBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `channelbalance`
      // ChannelBalance returns a report on the total funds across all open channels,
      // categorized in local/remote, pending local/remote and unsettled local/remote
      // balances.
      virtual void ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChannelBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBalanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChannelBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChannelBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listchaintxns`
      // GetTransactions returns a list describing all the known transactions
      // relevant to the wallet.
      virtual void GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTransactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::TransactionDetails* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTransactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::TransactionDetails* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTransactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::TransactionDetails* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `estimatefee`
      // EstimateFee asks the chain backend to estimate the fee rate and total fees
      // for a transaction that pays to multiple specified outputs.
      //
      // When using REST, the `AddrToAmount` map type can be set by appending
      // `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
      // map type doesn't appear in the REST API documentation because of a bug in
      // the grpc-gateway library.
      virtual void EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EstimateFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::EstimateFeeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EstimateFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EstimateFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `sendcoins`
      // SendCoins executes a request to send coins to a particular address. Unlike
      // SendMany, this RPC call only allows creating a single output at a time. If
      // neither target_conf, or sat_per_vbyte are set, then the internal wallet will
      // consult its fee model to determine a fee for the default confirmation
      // target.
      virtual void SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendCoins(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendCoinsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendCoins(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendCoinsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendCoins(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendCoinsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listunspent`
      // Deprecated, use walletrpc.ListUnspent instead.
      //
      // ListUnspent returns a list of all utxos spendable by the wallet with a
      // number of confirmations between the specified minimum and maximum.
      virtual void ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListUnspent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListUnspentResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListUnspent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListUnspentResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListUnspent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListUnspentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // SubscribeTransactions creates a uni-directional stream from the server to
      // the client in which any newly discovered transactions relevant to the
      // wallet are sent over.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeTransactions(::grpc::ClientContext* context, ::lnrpc::GetTransactionsRequest* request, ::grpc::ClientReadReactor< ::lnrpc::Transaction>* reactor) = 0;
      #else
      virtual void SubscribeTransactions(::grpc::ClientContext* context, ::lnrpc::GetTransactionsRequest* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::Transaction>* reactor) = 0;
      #endif
      // lncli: `sendmany`
      // SendMany handles a request for a transaction that creates multiple specified
      // outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
      // the internal wallet will consult its fee model to determine a fee for the
      // default confirmation target.
      virtual void SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMany(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendManyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMany(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendManyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMany(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendManyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `newaddress`
      // NewAddress creates a new address under control of the local wallet.
      virtual void NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NewAddressResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NewAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NewAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NewAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NewAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `signmessage`
      // SignMessage signs a message with this node's private key. The returned
      // signature string is `zbase32` encoded and pubkey recoverable, meaning that
      // only the message digest and signature are needed for verification.
      virtual void SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SignMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SignMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SignMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SignMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SignMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SignMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `verifymessage`
      // VerifyMessage verifies a signature over a msg. The signature must be
      // zbase32 encoded and signed by an active node in the resident node's
      // channel database. In addition to returning the validity of the signature,
      // VerifyMessage also returns the recovered pubkey from the signature.
      virtual void VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VerifyMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VerifyMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VerifyMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `connect`
      // ConnectPeer attempts to establish a connection to a remote peer. This is at
      // the networking level, and is used for communication between nodes. This is
      // distinct from establishing a channel with a peer.
      virtual void ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ConnectPeerResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ConnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ConnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `disconnect`
      // DisconnectPeer attempts to disconnect one peer from another identified by a
      // given pubKey. In the case that we currently have a pending or active channel
      // with the target peer, then this action will be not be allowed.
      virtual void DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisconnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DisconnectPeerResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DisconnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DisconnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listpeers`
      // ListPeers returns a verbose listing of all currently active peers.
      virtual void ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPeersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPeersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPeersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // SubscribePeerEvents creates a uni-directional stream from the server to
      // the client in which any events relevant to the state of peers are sent
      // over. Events include peers going online and offline.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribePeerEvents(::grpc::ClientContext* context, ::lnrpc::PeerEventSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::PeerEvent>* reactor) = 0;
      #else
      virtual void SubscribePeerEvents(::grpc::ClientContext* context, ::lnrpc::PeerEventSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::PeerEvent>* reactor) = 0;
      #endif
      // lncli: `getinfo`
      // GetInfo returns general information concerning the lightning node including
      // it's identity pubkey, alias, the chains it is connected to, and information
      // concerning the number of open+pending channels.
      virtual void GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * lncli: `getrecoveryinfo`
      // GetRecoveryInfo returns information concerning the recovery mode including
      // whether it's in a recovery mode, whether the recovery is finished, and the
      // progress made so far.
      virtual void GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRecoveryInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetRecoveryInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRecoveryInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRecoveryInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // TODO(roasbeef): merge with below with bool?
      //
      // lncli: `pendingchannels`
      // PendingChannels returns a list of all the channels that are currently
      // considered "pending". A channel is pending if it has finished the funding
      // workflow and is waiting for confirmations for the funding txn, or is in the
      // process of closure, either initiated cooperatively or non-cooperatively.
      virtual void PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PendingChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PendingChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PendingChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PendingChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listchannels`
      // ListChannels returns a description of all the open channels that this node
      // is a participant in.
      virtual void ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // SubscribeChannelEvents creates a uni-directional stream from the server to
      // the client in which any updates relevant to the state of the channels are
      // sent over. Events include new active channels, inactive channels, and closed
      // channels.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeChannelEvents(::grpc::ClientContext* context, ::lnrpc::ChannelEventSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::ChannelEventUpdate>* reactor) = 0;
      #else
      virtual void SubscribeChannelEvents(::grpc::ClientContext* context, ::lnrpc::ChannelEventSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::ChannelEventUpdate>* reactor) = 0;
      #endif
      // lncli: `closedchannels`
      // ClosedChannels returns a description of all the closed channels that
      // this node was a participant in.
      virtual void ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClosedChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ClosedChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ClosedChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ClosedChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      // call is meant to be consumed by clients to the REST proxy. As with all
      // other sync calls, all byte slices are intended to be populated as hex
      // encoded strings.
      virtual void OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response, std::function<void(::grpc::Status)>) = 0;
      virtual void OpenChannelSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelPoint* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OpenChannelSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelPoint* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OpenChannelSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelPoint* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `openchannel`
      // OpenChannel attempts to open a singly funded channel specified in the
      // request to a remote peer. Users are able to specify a target number of
      // blocks that the funding transaction should be confirmed in, or a manual fee
      // rate to us for the funding transaction. If neither are specified, then a
      // lax block confirmation target is used. Each OpenStatusUpdate will return
      // the pending channel ID of the in-progress channel. Depending on the
      // arguments specified in the OpenChannelRequest, this pending channel ID can
      // then be used to manually progress the channel funding flow.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OpenChannel(::grpc::ClientContext* context, ::lnrpc::OpenChannelRequest* request, ::grpc::ClientReadReactor< ::lnrpc::OpenStatusUpdate>* reactor) = 0;
      #else
      virtual void OpenChannel(::grpc::ClientContext* context, ::lnrpc::OpenChannelRequest* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::OpenStatusUpdate>* reactor) = 0;
      #endif
      //
      // FundingStateStep is an advanced funding related call that allows the caller
      // to either execute some preparatory steps for a funding workflow, or
      // manually progress a funding workflow. The primary way a funding flow is
      // identified is via its pending channel ID. As an example, this method can be
      // used to specify that we're expecting a funding flow for a particular
      // pending channel ID, for which we need to use specific parameters.
      // Alternatively, this can be used to interactively drive PSBT signing for
      // funding for partially complete funding transactions.
      virtual void FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FundingStateStep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FundingStateStepResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FundingStateStep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FundingStateStepResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FundingStateStep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FundingStateStepResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // ChannelAcceptor dispatches a bi-directional streaming RPC in which
      // OpenChannel requests are sent to the client and the client responds with
      // a boolean that tells LND whether or not to accept the channel. This allows
      // node operators to specify their own criteria for accepting inbound channels
      // through a single persistent connection.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChannelAcceptor(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::lnrpc::ChannelAcceptResponse,::lnrpc::ChannelAcceptRequest>* reactor) = 0;
      #else
      virtual void ChannelAcceptor(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::lnrpc::ChannelAcceptResponse,::lnrpc::ChannelAcceptRequest>* reactor) = 0;
      #endif
      // lncli: `closechannel`
      // CloseChannel attempts to close an active channel identified by its channel
      // outpoint (ChannelPoint). The actions of this method can additionally be
      // augmented to attempt a force close after a timeout period in the case of an
      // inactive peer. If a non-force close (cooperative closure) is requested,
      // then the user can specify either a target number of blocks until the
      // closure transaction is confirmed, or a manual fee rate. If neither are
      // specified, then a default lax, block confirmation target is used.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CloseChannel(::grpc::ClientContext* context, ::lnrpc::CloseChannelRequest* request, ::grpc::ClientReadReactor< ::lnrpc::CloseStatusUpdate>* reactor) = 0;
      #else
      virtual void CloseChannel(::grpc::ClientContext* context, ::lnrpc::CloseChannelRequest* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::CloseStatusUpdate>* reactor) = 0;
      #endif
      // lncli: `abandonchannel`
      // AbandonChannel removes all channel state from the database except for a
      // close summary. This method can be used to get rid of permanently unusable
      // channels due to bugs fixed in newer versions of lnd. This method can also be
      // used to remove externally funded channels where the funding transaction was
      // never broadcast. Only available for non-externally funded channels in dev
      // build.
      virtual void AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AbandonChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AbandonChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AbandonChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AbandonChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `sendpayment`
      // Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
      // bi-directional streaming RPC for sending payments through the Lightning
      // Network. A single RPC invocation creates a persistent bi-directional
      // stream allowing clients to rapidly send payments through the Lightning
      // Network with a single persistent connection.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendPayment(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::lnrpc::SendRequest,::lnrpc::SendResponse>* reactor) = 0;
      #else
      virtual void SendPayment(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::lnrpc::SendRequest,::lnrpc::SendResponse>* reactor) = 0;
      #endif
      //
      // SendPaymentSync is the synchronous non-streaming version of SendPayment.
      // This RPC is intended to be consumed by clients of the REST proxy.
      // Additionally, this RPC expects the destination's public key and the payment
      // hash (if any) to be encoded as hex strings.
      virtual void SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendPaymentSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendPaymentSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendPaymentSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `sendtoroute`
      // Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
      // streaming RPC for sending payment through the Lightning Network. This
      // method differs from SendPayment in that it allows users to specify a full
      // route manually. This can be used for things like rebalancing, and atomic
      // swaps.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendToRoute(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::lnrpc::SendToRouteRequest,::lnrpc::SendResponse>* reactor) = 0;
      #else
      virtual void SendToRoute(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::lnrpc::SendToRouteRequest,::lnrpc::SendResponse>* reactor) = 0;
      #endif
      //
      // SendToRouteSync is a synchronous version of SendToRoute. It Will block
      // until the payment either fails or succeeds.
      virtual void SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendToRouteSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendToRouteSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendToRouteSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `addinvoice`
      // AddInvoice attempts to add a new invoice to the invoice database. Any
      // duplicated invoices are rejected, therefore all invoices *must* have a
      // unique payment preimage.
      virtual void AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AddInvoiceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listinvoices`
      // ListInvoices returns a list of all the invoices currently stored within the
      // database. Any active debug invoices are ignored. It has full support for
      // paginated responses, allowing users to query for specific invoices through
      // their add_index. This can be done by using either the first_index_offset or
      // last_index_offset fields included in the response as the index_offset of the
      // next request. By default, the first 100 invoices created will be returned.
      // Backwards pagination is also supported through the Reversed flag.
      virtual void ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListInvoices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListInvoiceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListInvoices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListInvoices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `lookupinvoice`
      // LookupInvoice attempts to look up an invoice according to its payment hash.
      // The passed payment hash *must* be exactly 32 bytes, if not, an error is
      // returned.
      virtual void LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LookupInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::Invoice* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LookupInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::Invoice* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LookupInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::Invoice* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // SubscribeInvoices returns a uni-directional stream (server -> client) for
      // notifying the client of newly added/settled invoices. The caller can
      // optionally specify the add_index and/or the settle_index. If the add_index
      // is specified, then we'll first start by sending add invoice events for all
      // invoices with an add_index greater than the specified value. If the
      // settle_index is specified, the next, we'll send out all settle events for
      // invoices with a settle_index greater than the specified value. One or both
      // of these fields can be set. If no fields are set, then we'll only send out
      // the latest add/settle events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeInvoices(::grpc::ClientContext* context, ::lnrpc::InvoiceSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::Invoice>* reactor) = 0;
      #else
      virtual void SubscribeInvoices(::grpc::ClientContext* context, ::lnrpc::InvoiceSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::Invoice>* reactor) = 0;
      #endif
      // lncli: `decodepayreq`
      // DecodePayReq takes an encoded payment request string and attempts to decode
      // it, returning a full description of the conditions encoded within the
      // payment request.
      virtual void DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DecodePayReq(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PayReq* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DecodePayReq(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PayReq* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DecodePayReq(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PayReq* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listpayments`
      // ListPayments returns a list of all outgoing payments.
      virtual void ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPaymentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // DeleteAllPayments deletes all outgoing payments from DB.
      virtual void DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAllPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteAllPaymentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAllPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAllPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `describegraph`
      // DescribeGraph returns a description of the latest graph state from the
      // point of view of the node. The graph information is partitioned into two
      // components: all the nodes/vertexes, and all the edges that connect the
      // vertexes themselves. As this is a directed graph, the edges also contain
      // the node directional specific routing policy which includes: the time lock
      // delta, fee information, etc.
      virtual void DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DescribeGraph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelGraph* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DescribeGraph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelGraph* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DescribeGraph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelGraph* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `getnodemetrics`
      // GetNodeMetrics returns node metrics calculated from the graph. Currently
      // the only supported metric is betweenness centrality of individual nodes.
      virtual void GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNodeMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNodeMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNodeMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `getchaninfo`
      // GetChanInfo returns the latest authenticated network announcement for the
      // given channel identified by its channel ID: an 8-byte integer which
      // uniquely identifies the location of transaction's funding output within the
      // blockchain.
      virtual void GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetChanInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelEdge* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChanInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelEdge* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetChanInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelEdge* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `getnodeinfo`
      // GetNodeInfo returns the latest advertised, aggregated, and authenticated
      // channel information for the specified node identified by its public key.
      virtual void GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeInfo* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `queryroutes`
      // QueryRoutes attempts to query the daemon's Channel Router for a possible
      // route to a target destination capable of carrying a specific amount of
      // satoshis. The returned route contains the full details required to craft and
      // send an HTLC, also including the necessary information that should be
      // present within the Sphinx packet encapsulated within the HTLC.
      //
      // When using REST, the `dest_custom_records` map type can be set by appending
      // `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
      // to the URL. Unfortunately this map type doesn't appear in the REST API
      // documentation because of a bug in the grpc-gateway library.
      virtual void QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::QueryRoutesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void QueryRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void QueryRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `getnetworkinfo`
      // GetNetworkInfo returns some basic stats about the known channel graph from
      // the point of view of the node.
      virtual void GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNetworkInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NetworkInfo* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNetworkInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NetworkInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNetworkInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `stop`
      // StopDaemon will send a shutdown request to the interrupt handler, triggering
      // a graceful shutdown of the daemon.
      virtual void StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopDaemon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::StopResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StopDaemon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StopDaemon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // SubscribeChannelGraph launches a streaming RPC that allows the caller to
      // receive notifications upon any changes to the channel graph topology from
      // the point of view of the responding node. Events notified include: new
      // nodes coming online, nodes updating their authenticated attributes, new
      // channels being advertised, updates in the routing policy for a directional
      // channel edge, and when channels are closed on-chain.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeChannelGraph(::grpc::ClientContext* context, ::lnrpc::GraphTopologySubscription* request, ::grpc::ClientReadReactor< ::lnrpc::GraphTopologyUpdate>* reactor) = 0;
      #else
      virtual void SubscribeChannelGraph(::grpc::ClientContext* context, ::lnrpc::GraphTopologySubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::GraphTopologyUpdate>* reactor) = 0;
      #endif
      // lncli: `debuglevel`
      // DebugLevel allows a caller to programmatically set the logging verbosity of
      // lnd. The logging can be targeted according to a coarse daemon-wide logging
      // level, or in a granular fashion to specify the logging for a target
      // sub-system.
      virtual void DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DebugLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DebugLevelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DebugLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DebugLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DebugLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DebugLevelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `feereport`
      // FeeReport allows the caller to obtain a report detailing the current fee
      // schedule enforced by the node globally for each channel.
      virtual void FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FeeReport(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FeeReportResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FeeReport(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FeeReportResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FeeReport(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FeeReportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `updatechanpolicy`
      // UpdateChannelPolicy allows the caller to update the fee schedule and
      // channel policies for all channels globally, or a particular channel.
      virtual void UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateChannelPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PolicyUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateChannelPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateChannelPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `fwdinghistory`
      // ForwardingHistory allows the caller to query the htlcswitch for a record of
      // all HTLCs forwarded within the target time range, and integer offset
      // within that time range. If no time-range is specified, then the first chunk
      // of the past 24 hrs of forwarding history are returned.
      //
      // A list of forwarding events are returned. The size of each forwarding event
      // is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      // As a result each message can only contain 50k entries. Each response has
      // the index offset of the last entry. The index offset can be provided to the
      // request to allow the caller to skip a series of records.
      virtual void ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ForwardingHistory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ForwardingHistoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ForwardingHistory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ForwardingHistory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `exportchanbackup`
      // ExportChannelBackup attempts to return an encrypted static channel backup
      // for the target channel identified by it channel point. The backup is
      // encrypted with a key generated from the aezeed seed of the user. The
      // returned backup can either be restored using the RestoreChannelBackup
      // method once lnd is running, or via the InitWallet and UnlockWallet methods
      // from the WalletUnlocker service.
      virtual void ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExportChannelBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBackup* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExportChannelBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBackup* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExportChannelBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBackup* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // ExportAllChannelBackups returns static channel backups for all existing
      // channels known to lnd. A set of regular singular static channel backups for
      // each channel are returned. Additionally, a multi-channel backup is returned
      // as well, which contains a single encrypted blob containing the backups of
      // each channel.
      virtual void ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExportAllChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChanBackupSnapshot* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExportAllChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExportAllChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // VerifyChanBackup allows a caller to verify the integrity of a channel backup
      // snapshot. This method will accept either a packed Single or a packed Multi.
      // Specifying both will result in an error.
      virtual void VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VerifyChanBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyChanBackupResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VerifyChanBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VerifyChanBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `restorechanbackup`
      // RestoreChannelBackups accepts a set of singular channel backups, or a
      // single encrypted multi-chan backup and attempts to recover any funds
      // remaining within the channel. If we are able to unpack the backup, then the
      // new channel will be shown under listchannels, as well as pending channels.
      virtual void RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RestoreChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::RestoreBackupResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RestoreChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RestoreChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // SubscribeChannelBackups allows a client to sub-subscribe to the most up to
      // date information concerning the state of all channel backups. Each time a
      // new channel is added, we return the new set of channels, along with a
      // multi-chan backup containing the backup info for all channels. Each time a
      // channel is closed, we send a new update, which contains new new chan back
      // ups, but the updated set of encrypted multi-chan backups with the closed
      // channel(s) removed.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeChannelBackups(::grpc::ClientContext* context, ::lnrpc::ChannelBackupSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::ChanBackupSnapshot>* reactor) = 0;
      #else
      virtual void SubscribeChannelBackups(::grpc::ClientContext* context, ::lnrpc::ChannelBackupSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::ChanBackupSnapshot>* reactor) = 0;
      #endif
      // lncli: `bakemacaroon`
      // BakeMacaroon allows the creation of a new macaroon with custom read and
      // write permissions. No first-party caveats are added since this can be done
      // offline.
      virtual void BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BakeMacaroon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::BakeMacaroonResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BakeMacaroon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BakeMacaroon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listmacaroonids`
      // ListMacaroonIDs returns all root key IDs that are in use.
      virtual void ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListMacaroonIDs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListMacaroonIDsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListMacaroonIDs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListMacaroonIDs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `deletemacaroonid`
      // DeleteMacaroonID deletes the specified macaroon ID and invalidates all
      // macaroons derived from that ID.
      virtual void DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteMacaroonID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteMacaroonIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteMacaroonID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteMacaroonID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // lncli: `listpermissions`
      // ListPermissions lists all RPC method URIs and their required macaroon
      // permissions to access them.
      virtual void ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPermissions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPermissionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPermissions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPermissions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::WalletBalanceResponse>* AsyncWalletBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::WalletBalanceResponse>* PrepareAsyncWalletBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBalanceResponse>* AsyncChannelBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBalanceResponse>* PrepareAsyncChannelBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::TransactionDetails>* AsyncGetTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::TransactionDetails>* PrepareAsyncGetTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::EstimateFeeResponse>* AsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::EstimateFeeResponse>* PrepareAsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendCoinsResponse>* AsyncSendCoinsRaw(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendCoinsResponse>* PrepareAsyncSendCoinsRaw(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListUnspentResponse>* AsyncListUnspentRaw(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListUnspentResponse>* PrepareAsyncListUnspentRaw(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::Transaction>* SubscribeTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::Transaction>* AsyncSubscribeTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::Transaction>* PrepareAsyncSubscribeTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendManyResponse>* AsyncSendManyRaw(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendManyResponse>* PrepareAsyncSendManyRaw(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NewAddressResponse>* AsyncNewAddressRaw(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NewAddressResponse>* PrepareAsyncNewAddressRaw(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SignMessageResponse>* AsyncSignMessageRaw(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SignMessageResponse>* PrepareAsyncSignMessageRaw(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyMessageResponse>* AsyncVerifyMessageRaw(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyMessageResponse>* PrepareAsyncVerifyMessageRaw(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ConnectPeerResponse>* AsyncConnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ConnectPeerResponse>* PrepareAsyncConnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DisconnectPeerResponse>* AsyncDisconnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DisconnectPeerResponse>* PrepareAsyncDisconnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPeersResponse>* AsyncListPeersRaw(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPeersResponse>* PrepareAsyncListPeersRaw(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::PeerEvent>* SubscribePeerEventsRaw(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::PeerEvent>* AsyncSubscribePeerEventsRaw(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::PeerEvent>* PrepareAsyncSubscribePeerEventsRaw(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetInfoResponse>* AsyncGetInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetInfoResponse>* PrepareAsyncGetInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetRecoveryInfoResponse>* AsyncGetRecoveryInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::GetRecoveryInfoResponse>* PrepareAsyncGetRecoveryInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PendingChannelsResponse>* AsyncPendingChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PendingChannelsResponse>* PrepareAsyncPendingChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListChannelsResponse>* AsyncListChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListChannelsResponse>* PrepareAsyncListChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::ChannelEventUpdate>* SubscribeChannelEventsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChannelEventUpdate>* AsyncSubscribeChannelEventsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChannelEventUpdate>* PrepareAsyncSubscribeChannelEventsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ClosedChannelsResponse>* AsyncClosedChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ClosedChannelsResponse>* PrepareAsyncClosedChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelPoint>* AsyncOpenChannelSyncRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelPoint>* PrepareAsyncOpenChannelSyncRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::OpenStatusUpdate>* OpenChannelRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::OpenStatusUpdate>* AsyncOpenChannelRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::OpenStatusUpdate>* PrepareAsyncOpenChannelRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FundingStateStepResp>* AsyncFundingStateStepRaw(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FundingStateStepResp>* PrepareAsyncFundingStateStepRaw(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* ChannelAcceptorRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* AsyncChannelAcceptorRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* PrepareAsyncChannelAcceptorRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::CloseStatusUpdate>* CloseChannelRaw(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::CloseStatusUpdate>* AsyncCloseChannelRaw(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::CloseStatusUpdate>* PrepareAsyncCloseChannelRaw(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AbandonChannelResponse>* AsyncAbandonChannelRaw(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AbandonChannelResponse>* PrepareAsyncAbandonChannelRaw(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* SendPaymentRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* AsyncSendPaymentRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* PrepareAsyncSendPaymentRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>* AsyncSendPaymentSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>* PrepareAsyncSendPaymentSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* SendToRouteRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* AsyncSendToRouteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* PrepareAsyncSendToRouteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>* AsyncSendToRouteSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::SendResponse>* PrepareAsyncSendToRouteSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AddInvoiceResponse>* AsyncAddInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::AddInvoiceResponse>* PrepareAsyncAddInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListInvoiceResponse>* AsyncListInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListInvoiceResponse>* PrepareAsyncListInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::Invoice>* AsyncLookupInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::Invoice>* PrepareAsyncLookupInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::Invoice>* SubscribeInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::Invoice>* AsyncSubscribeInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::Invoice>* PrepareAsyncSubscribeInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PayReq>* AsyncDecodePayReqRaw(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PayReq>* PrepareAsyncDecodePayReqRaw(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPaymentsResponse>* AsyncListPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPaymentsResponse>* PrepareAsyncListPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteAllPaymentsResponse>* AsyncDeleteAllPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteAllPaymentsResponse>* PrepareAsyncDeleteAllPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelGraph>* AsyncDescribeGraphRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelGraph>* PrepareAsyncDescribeGraphRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeMetricsResponse>* AsyncGetNodeMetricsRaw(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeMetricsResponse>* PrepareAsyncGetNodeMetricsRaw(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelEdge>* AsyncGetChanInfoRaw(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelEdge>* PrepareAsyncGetChanInfoRaw(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeInfo>* AsyncGetNodeInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NodeInfo>* PrepareAsyncGetNodeInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::QueryRoutesResponse>* AsyncQueryRoutesRaw(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::QueryRoutesResponse>* PrepareAsyncQueryRoutesRaw(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NetworkInfo>* AsyncGetNetworkInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::NetworkInfo>* PrepareAsyncGetNetworkInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::StopResponse>* AsyncStopDaemonRaw(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::StopResponse>* PrepareAsyncStopDaemonRaw(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::GraphTopologyUpdate>* SubscribeChannelGraphRaw(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::GraphTopologyUpdate>* AsyncSubscribeChannelGraphRaw(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::GraphTopologyUpdate>* PrepareAsyncSubscribeChannelGraphRaw(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DebugLevelResponse>* AsyncDebugLevelRaw(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DebugLevelResponse>* PrepareAsyncDebugLevelRaw(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FeeReportResponse>* AsyncFeeReportRaw(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::FeeReportResponse>* PrepareAsyncFeeReportRaw(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PolicyUpdateResponse>* AsyncUpdateChannelPolicyRaw(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::PolicyUpdateResponse>* PrepareAsyncUpdateChannelPolicyRaw(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ForwardingHistoryResponse>* AsyncForwardingHistoryRaw(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ForwardingHistoryResponse>* PrepareAsyncForwardingHistoryRaw(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBackup>* AsyncExportChannelBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChannelBackup>* PrepareAsyncExportChannelBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChanBackupSnapshot>* AsyncExportAllChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ChanBackupSnapshot>* PrepareAsyncExportAllChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyChanBackupResponse>* AsyncVerifyChanBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::VerifyChanBackupResponse>* PrepareAsyncVerifyChanBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::RestoreBackupResponse>* AsyncRestoreChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::RestoreBackupResponse>* PrepareAsyncRestoreChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lnrpc::ChanBackupSnapshot>* SubscribeChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChanBackupSnapshot>* AsyncSubscribeChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lnrpc::ChanBackupSnapshot>* PrepareAsyncSubscribeChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::BakeMacaroonResponse>* AsyncBakeMacaroonRaw(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::BakeMacaroonResponse>* PrepareAsyncBakeMacaroonRaw(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListMacaroonIDsResponse>* AsyncListMacaroonIDsRaw(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListMacaroonIDsResponse>* PrepareAsyncListMacaroonIDsRaw(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteMacaroonIDResponse>* AsyncDeleteMacaroonIDRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::DeleteMacaroonIDResponse>* PrepareAsyncDeleteMacaroonIDRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPermissionsResponse>* AsyncListPermissionsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lnrpc::ListPermissionsResponse>* PrepareAsyncListPermissionsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::lnrpc::WalletBalanceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::WalletBalanceResponse>> AsyncWalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::WalletBalanceResponse>>(AsyncWalletBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::WalletBalanceResponse>> PrepareAsyncWalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::WalletBalanceResponse>>(PrepareAsyncWalletBalanceRaw(context, request, cq));
    }
    ::grpc::Status ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::lnrpc::ChannelBalanceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBalanceResponse>> AsyncChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBalanceResponse>>(AsyncChannelBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBalanceResponse>> PrepareAsyncChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBalanceResponse>>(PrepareAsyncChannelBalanceRaw(context, request, cq));
    }
    ::grpc::Status GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::lnrpc::TransactionDetails* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::TransactionDetails>> AsyncGetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::TransactionDetails>>(AsyncGetTransactionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::TransactionDetails>> PrepareAsyncGetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::TransactionDetails>>(PrepareAsyncGetTransactionsRaw(context, request, cq));
    }
    ::grpc::Status EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::lnrpc::EstimateFeeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::EstimateFeeResponse>> AsyncEstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::EstimateFeeResponse>>(AsyncEstimateFeeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::EstimateFeeResponse>> PrepareAsyncEstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::EstimateFeeResponse>>(PrepareAsyncEstimateFeeRaw(context, request, cq));
    }
    ::grpc::Status SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::lnrpc::SendCoinsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendCoinsResponse>> AsyncSendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendCoinsResponse>>(AsyncSendCoinsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendCoinsResponse>> PrepareAsyncSendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendCoinsResponse>>(PrepareAsyncSendCoinsRaw(context, request, cq));
    }
    ::grpc::Status ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::lnrpc::ListUnspentResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListUnspentResponse>> AsyncListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListUnspentResponse>>(AsyncListUnspentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListUnspentResponse>> PrepareAsyncListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListUnspentResponse>>(PrepareAsyncListUnspentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::Transaction>> SubscribeTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::Transaction>>(SubscribeTransactionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Transaction>> AsyncSubscribeTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Transaction>>(AsyncSubscribeTransactionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Transaction>> PrepareAsyncSubscribeTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Transaction>>(PrepareAsyncSubscribeTransactionsRaw(context, request, cq));
    }
    ::grpc::Status SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::lnrpc::SendManyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendManyResponse>> AsyncSendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendManyResponse>>(AsyncSendManyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendManyResponse>> PrepareAsyncSendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendManyResponse>>(PrepareAsyncSendManyRaw(context, request, cq));
    }
    ::grpc::Status NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::lnrpc::NewAddressResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NewAddressResponse>> AsyncNewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NewAddressResponse>>(AsyncNewAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NewAddressResponse>> PrepareAsyncNewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NewAddressResponse>>(PrepareAsyncNewAddressRaw(context, request, cq));
    }
    ::grpc::Status SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::lnrpc::SignMessageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SignMessageResponse>> AsyncSignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SignMessageResponse>>(AsyncSignMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SignMessageResponse>> PrepareAsyncSignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SignMessageResponse>>(PrepareAsyncSignMessageRaw(context, request, cq));
    }
    ::grpc::Status VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::lnrpc::VerifyMessageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyMessageResponse>> AsyncVerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyMessageResponse>>(AsyncVerifyMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyMessageResponse>> PrepareAsyncVerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyMessageResponse>>(PrepareAsyncVerifyMessageRaw(context, request, cq));
    }
    ::grpc::Status ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::lnrpc::ConnectPeerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ConnectPeerResponse>> AsyncConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ConnectPeerResponse>>(AsyncConnectPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ConnectPeerResponse>> PrepareAsyncConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ConnectPeerResponse>>(PrepareAsyncConnectPeerRaw(context, request, cq));
    }
    ::grpc::Status DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::lnrpc::DisconnectPeerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DisconnectPeerResponse>> AsyncDisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DisconnectPeerResponse>>(AsyncDisconnectPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DisconnectPeerResponse>> PrepareAsyncDisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DisconnectPeerResponse>>(PrepareAsyncDisconnectPeerRaw(context, request, cq));
    }
    ::grpc::Status ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::lnrpc::ListPeersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPeersResponse>> AsyncListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPeersResponse>>(AsyncListPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPeersResponse>> PrepareAsyncListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPeersResponse>>(PrepareAsyncListPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::PeerEvent>> SubscribePeerEvents(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::PeerEvent>>(SubscribePeerEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::PeerEvent>> AsyncSubscribePeerEvents(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::PeerEvent>>(AsyncSubscribePeerEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::PeerEvent>> PrepareAsyncSubscribePeerEvents(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::PeerEvent>>(PrepareAsyncSubscribePeerEventsRaw(context, request, cq));
    }
    ::grpc::Status GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::lnrpc::GetInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetInfoResponse>> AsyncGetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetInfoResponse>>(AsyncGetInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetInfoResponse>> PrepareAsyncGetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetInfoResponse>>(PrepareAsyncGetInfoRaw(context, request, cq));
    }
    ::grpc::Status GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::lnrpc::GetRecoveryInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetRecoveryInfoResponse>> AsyncGetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetRecoveryInfoResponse>>(AsyncGetRecoveryInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetRecoveryInfoResponse>> PrepareAsyncGetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::GetRecoveryInfoResponse>>(PrepareAsyncGetRecoveryInfoRaw(context, request, cq));
    }
    ::grpc::Status PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::lnrpc::PendingChannelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PendingChannelsResponse>> AsyncPendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PendingChannelsResponse>>(AsyncPendingChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PendingChannelsResponse>> PrepareAsyncPendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PendingChannelsResponse>>(PrepareAsyncPendingChannelsRaw(context, request, cq));
    }
    ::grpc::Status ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::lnrpc::ListChannelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListChannelsResponse>> AsyncListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListChannelsResponse>>(AsyncListChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListChannelsResponse>> PrepareAsyncListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListChannelsResponse>>(PrepareAsyncListChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::ChannelEventUpdate>> SubscribeChannelEvents(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::ChannelEventUpdate>>(SubscribeChannelEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChannelEventUpdate>> AsyncSubscribeChannelEvents(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChannelEventUpdate>>(AsyncSubscribeChannelEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChannelEventUpdate>> PrepareAsyncSubscribeChannelEvents(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChannelEventUpdate>>(PrepareAsyncSubscribeChannelEventsRaw(context, request, cq));
    }
    ::grpc::Status ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::lnrpc::ClosedChannelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ClosedChannelsResponse>> AsyncClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ClosedChannelsResponse>>(AsyncClosedChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ClosedChannelsResponse>> PrepareAsyncClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ClosedChannelsResponse>>(PrepareAsyncClosedChannelsRaw(context, request, cq));
    }
    ::grpc::Status OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::lnrpc::ChannelPoint* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelPoint>> AsyncOpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelPoint>>(AsyncOpenChannelSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelPoint>> PrepareAsyncOpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelPoint>>(PrepareAsyncOpenChannelSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::OpenStatusUpdate>> OpenChannel(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::OpenStatusUpdate>>(OpenChannelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::OpenStatusUpdate>> AsyncOpenChannel(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::OpenStatusUpdate>>(AsyncOpenChannelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::OpenStatusUpdate>> PrepareAsyncOpenChannel(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::OpenStatusUpdate>>(PrepareAsyncOpenChannelRaw(context, request, cq));
    }
    ::grpc::Status FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::lnrpc::FundingStateStepResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FundingStateStepResp>> AsyncFundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FundingStateStepResp>>(AsyncFundingStateStepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FundingStateStepResp>> PrepareAsyncFundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FundingStateStepResp>>(PrepareAsyncFundingStateStepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>> ChannelAcceptor(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>>(ChannelAcceptorRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>> AsyncChannelAcceptor(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>>(AsyncChannelAcceptorRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>> PrepareAsyncChannelAcceptor(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>>(PrepareAsyncChannelAcceptorRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::CloseStatusUpdate>> CloseChannel(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::CloseStatusUpdate>>(CloseChannelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::CloseStatusUpdate>> AsyncCloseChannel(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::CloseStatusUpdate>>(AsyncCloseChannelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::CloseStatusUpdate>> PrepareAsyncCloseChannel(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::CloseStatusUpdate>>(PrepareAsyncCloseChannelRaw(context, request, cq));
    }
    ::grpc::Status AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::lnrpc::AbandonChannelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AbandonChannelResponse>> AsyncAbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AbandonChannelResponse>>(AsyncAbandonChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AbandonChannelResponse>> PrepareAsyncAbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AbandonChannelResponse>>(PrepareAsyncAbandonChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>> SendPayment(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>>(SendPaymentRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>> AsyncSendPayment(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>>(AsyncSendPaymentRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>> PrepareAsyncSendPayment(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>>(PrepareAsyncSendPaymentRaw(context, cq));
    }
    ::grpc::Status SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::lnrpc::SendResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>> AsyncSendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>>(AsyncSendPaymentSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>> PrepareAsyncSendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>>(PrepareAsyncSendPaymentSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>> SendToRoute(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>>(SendToRouteRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>> AsyncSendToRoute(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>>(AsyncSendToRouteRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>> PrepareAsyncSendToRoute(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>>(PrepareAsyncSendToRouteRaw(context, cq));
    }
    ::grpc::Status SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::lnrpc::SendResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>> AsyncSendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>>(AsyncSendToRouteSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>> PrepareAsyncSendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>>(PrepareAsyncSendToRouteSyncRaw(context, request, cq));
    }
    ::grpc::Status AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::lnrpc::AddInvoiceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AddInvoiceResponse>> AsyncAddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AddInvoiceResponse>>(AsyncAddInvoiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AddInvoiceResponse>> PrepareAsyncAddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::AddInvoiceResponse>>(PrepareAsyncAddInvoiceRaw(context, request, cq));
    }
    ::grpc::Status ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::lnrpc::ListInvoiceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListInvoiceResponse>> AsyncListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListInvoiceResponse>>(AsyncListInvoicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListInvoiceResponse>> PrepareAsyncListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListInvoiceResponse>>(PrepareAsyncListInvoicesRaw(context, request, cq));
    }
    ::grpc::Status LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::lnrpc::Invoice* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::Invoice>> AsyncLookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::Invoice>>(AsyncLookupInvoiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::Invoice>> PrepareAsyncLookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::Invoice>>(PrepareAsyncLookupInvoiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::Invoice>> SubscribeInvoices(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::Invoice>>(SubscribeInvoicesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Invoice>> AsyncSubscribeInvoices(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Invoice>>(AsyncSubscribeInvoicesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Invoice>> PrepareAsyncSubscribeInvoices(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::Invoice>>(PrepareAsyncSubscribeInvoicesRaw(context, request, cq));
    }
    ::grpc::Status DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::lnrpc::PayReq* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PayReq>> AsyncDecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PayReq>>(AsyncDecodePayReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PayReq>> PrepareAsyncDecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PayReq>>(PrepareAsyncDecodePayReqRaw(context, request, cq));
    }
    ::grpc::Status ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::lnrpc::ListPaymentsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPaymentsResponse>> AsyncListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPaymentsResponse>>(AsyncListPaymentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPaymentsResponse>> PrepareAsyncListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPaymentsResponse>>(PrepareAsyncListPaymentsRaw(context, request, cq));
    }
    ::grpc::Status DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::lnrpc::DeleteAllPaymentsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteAllPaymentsResponse>> AsyncDeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteAllPaymentsResponse>>(AsyncDeleteAllPaymentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteAllPaymentsResponse>> PrepareAsyncDeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteAllPaymentsResponse>>(PrepareAsyncDeleteAllPaymentsRaw(context, request, cq));
    }
    ::grpc::Status DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::lnrpc::ChannelGraph* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelGraph>> AsyncDescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelGraph>>(AsyncDescribeGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelGraph>> PrepareAsyncDescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelGraph>>(PrepareAsyncDescribeGraphRaw(context, request, cq));
    }
    ::grpc::Status GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::lnrpc::NodeMetricsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeMetricsResponse>> AsyncGetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeMetricsResponse>>(AsyncGetNodeMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeMetricsResponse>> PrepareAsyncGetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeMetricsResponse>>(PrepareAsyncGetNodeMetricsRaw(context, request, cq));
    }
    ::grpc::Status GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::lnrpc::ChannelEdge* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelEdge>> AsyncGetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelEdge>>(AsyncGetChanInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelEdge>> PrepareAsyncGetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelEdge>>(PrepareAsyncGetChanInfoRaw(context, request, cq));
    }
    ::grpc::Status GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::lnrpc::NodeInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeInfo>> AsyncGetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeInfo>>(AsyncGetNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeInfo>> PrepareAsyncGetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeInfo>>(PrepareAsyncGetNodeInfoRaw(context, request, cq));
    }
    ::grpc::Status QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::lnrpc::QueryRoutesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::QueryRoutesResponse>> AsyncQueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::QueryRoutesResponse>>(AsyncQueryRoutesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::QueryRoutesResponse>> PrepareAsyncQueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::QueryRoutesResponse>>(PrepareAsyncQueryRoutesRaw(context, request, cq));
    }
    ::grpc::Status GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::lnrpc::NetworkInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NetworkInfo>> AsyncGetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NetworkInfo>>(AsyncGetNetworkInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NetworkInfo>> PrepareAsyncGetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::NetworkInfo>>(PrepareAsyncGetNetworkInfoRaw(context, request, cq));
    }
    ::grpc::Status StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::lnrpc::StopResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::StopResponse>> AsyncStopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::StopResponse>>(AsyncStopDaemonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::StopResponse>> PrepareAsyncStopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::StopResponse>>(PrepareAsyncStopDaemonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::GraphTopologyUpdate>> SubscribeChannelGraph(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::GraphTopologyUpdate>>(SubscribeChannelGraphRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::GraphTopologyUpdate>> AsyncSubscribeChannelGraph(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::GraphTopologyUpdate>>(AsyncSubscribeChannelGraphRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::GraphTopologyUpdate>> PrepareAsyncSubscribeChannelGraph(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::GraphTopologyUpdate>>(PrepareAsyncSubscribeChannelGraphRaw(context, request, cq));
    }
    ::grpc::Status DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::lnrpc::DebugLevelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DebugLevelResponse>> AsyncDebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DebugLevelResponse>>(AsyncDebugLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DebugLevelResponse>> PrepareAsyncDebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DebugLevelResponse>>(PrepareAsyncDebugLevelRaw(context, request, cq));
    }
    ::grpc::Status FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::lnrpc::FeeReportResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FeeReportResponse>> AsyncFeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FeeReportResponse>>(AsyncFeeReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FeeReportResponse>> PrepareAsyncFeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::FeeReportResponse>>(PrepareAsyncFeeReportRaw(context, request, cq));
    }
    ::grpc::Status UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::lnrpc::PolicyUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PolicyUpdateResponse>> AsyncUpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PolicyUpdateResponse>>(AsyncUpdateChannelPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PolicyUpdateResponse>> PrepareAsyncUpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::PolicyUpdateResponse>>(PrepareAsyncUpdateChannelPolicyRaw(context, request, cq));
    }
    ::grpc::Status ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::lnrpc::ForwardingHistoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ForwardingHistoryResponse>> AsyncForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ForwardingHistoryResponse>>(AsyncForwardingHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ForwardingHistoryResponse>> PrepareAsyncForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ForwardingHistoryResponse>>(PrepareAsyncForwardingHistoryRaw(context, request, cq));
    }
    ::grpc::Status ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::lnrpc::ChannelBackup* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBackup>> AsyncExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBackup>>(AsyncExportChannelBackupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBackup>> PrepareAsyncExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBackup>>(PrepareAsyncExportChannelBackupRaw(context, request, cq));
    }
    ::grpc::Status ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::lnrpc::ChanBackupSnapshot* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChanBackupSnapshot>> AsyncExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChanBackupSnapshot>>(AsyncExportAllChannelBackupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChanBackupSnapshot>> PrepareAsyncExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ChanBackupSnapshot>>(PrepareAsyncExportAllChannelBackupsRaw(context, request, cq));
    }
    ::grpc::Status VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::lnrpc::VerifyChanBackupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyChanBackupResponse>> AsyncVerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyChanBackupResponse>>(AsyncVerifyChanBackupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyChanBackupResponse>> PrepareAsyncVerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyChanBackupResponse>>(PrepareAsyncVerifyChanBackupRaw(context, request, cq));
    }
    ::grpc::Status RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::lnrpc::RestoreBackupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::RestoreBackupResponse>> AsyncRestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::RestoreBackupResponse>>(AsyncRestoreChannelBackupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::RestoreBackupResponse>> PrepareAsyncRestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::RestoreBackupResponse>>(PrepareAsyncRestoreChannelBackupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lnrpc::ChanBackupSnapshot>> SubscribeChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lnrpc::ChanBackupSnapshot>>(SubscribeChannelBackupsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChanBackupSnapshot>> AsyncSubscribeChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChanBackupSnapshot>>(AsyncSubscribeChannelBackupsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChanBackupSnapshot>> PrepareAsyncSubscribeChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lnrpc::ChanBackupSnapshot>>(PrepareAsyncSubscribeChannelBackupsRaw(context, request, cq));
    }
    ::grpc::Status BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::lnrpc::BakeMacaroonResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::BakeMacaroonResponse>> AsyncBakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::BakeMacaroonResponse>>(AsyncBakeMacaroonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::BakeMacaroonResponse>> PrepareAsyncBakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::BakeMacaroonResponse>>(PrepareAsyncBakeMacaroonRaw(context, request, cq));
    }
    ::grpc::Status ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::lnrpc::ListMacaroonIDsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListMacaroonIDsResponse>> AsyncListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListMacaroonIDsResponse>>(AsyncListMacaroonIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListMacaroonIDsResponse>> PrepareAsyncListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListMacaroonIDsResponse>>(PrepareAsyncListMacaroonIDsRaw(context, request, cq));
    }
    ::grpc::Status DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::lnrpc::DeleteMacaroonIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteMacaroonIDResponse>> AsyncDeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteMacaroonIDResponse>>(AsyncDeleteMacaroonIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteMacaroonIDResponse>> PrepareAsyncDeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteMacaroonIDResponse>>(PrepareAsyncDeleteMacaroonIDRaw(context, request, cq));
    }
    ::grpc::Status ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::lnrpc::ListPermissionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPermissionsResponse>> AsyncListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPermissionsResponse>>(AsyncListPermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPermissionsResponse>> PrepareAsyncListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPermissionsResponse>>(PrepareAsyncListPermissionsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response, std::function<void(::grpc::Status)>) override;
      void WalletBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::WalletBalanceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WalletBalance(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WalletBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WalletBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::WalletBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response, std::function<void(::grpc::Status)>) override;
      void ChannelBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBalanceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChannelBalance(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChannelBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChannelBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response, std::function<void(::grpc::Status)>) override;
      void GetTransactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::TransactionDetails* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTransactions(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTransactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::TransactionDetails* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTransactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::TransactionDetails* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response, std::function<void(::grpc::Status)>) override;
      void EstimateFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::EstimateFeeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EstimateFee(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EstimateFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EstimateFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::EstimateFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response, std::function<void(::grpc::Status)>) override;
      void SendCoins(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendCoinsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendCoins(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendCoins(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendCoinsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendCoins(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendCoinsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response, std::function<void(::grpc::Status)>) override;
      void ListUnspent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListUnspentResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListUnspent(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListUnspent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListUnspentResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListUnspent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListUnspentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeTransactions(::grpc::ClientContext* context, ::lnrpc::GetTransactionsRequest* request, ::grpc::ClientReadReactor< ::lnrpc::Transaction>* reactor) override;
      #else
      void SubscribeTransactions(::grpc::ClientContext* context, ::lnrpc::GetTransactionsRequest* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::Transaction>* reactor) override;
      #endif
      void SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response, std::function<void(::grpc::Status)>) override;
      void SendMany(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendManyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMany(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMany(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendManyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMany(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendManyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response, std::function<void(::grpc::Status)>) override;
      void NewAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NewAddressResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NewAddress(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NewAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NewAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NewAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NewAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response, std::function<void(::grpc::Status)>) override;
      void SignMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SignMessageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SignMessage(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SignMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SignMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SignMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SignMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response, std::function<void(::grpc::Status)>) override;
      void VerifyMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyMessageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VerifyMessage(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VerifyMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VerifyMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response, std::function<void(::grpc::Status)>) override;
      void ConnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ConnectPeerResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ConnectPeer(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ConnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ConnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ConnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response, std::function<void(::grpc::Status)>) override;
      void DisconnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DisconnectPeerResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DisconnectPeer(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DisconnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DisconnectPeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DisconnectPeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPeersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPeers(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPeersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPeersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribePeerEvents(::grpc::ClientContext* context, ::lnrpc::PeerEventSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::PeerEvent>* reactor) override;
      #else
      void SubscribePeerEvents(::grpc::ClientContext* context, ::lnrpc::PeerEventSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::PeerEvent>* reactor) override;
      #endif
      void GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetInfoResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInfo(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRecoveryInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetRecoveryInfoResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRecoveryInfo(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRecoveryInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRecoveryInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::GetRecoveryInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      void PendingChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PendingChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PendingChannels(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PendingChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PendingChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PendingChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListChannels(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeChannelEvents(::grpc::ClientContext* context, ::lnrpc::ChannelEventSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::ChannelEventUpdate>* reactor) override;
      #else
      void SubscribeChannelEvents(::grpc::ClientContext* context, ::lnrpc::ChannelEventSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::ChannelEventUpdate>* reactor) override;
      #endif
      void ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      void ClosedChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ClosedChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ClosedChannels(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ClosedChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ClosedChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ClosedChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response, std::function<void(::grpc::Status)>) override;
      void OpenChannelSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelPoint* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OpenChannelSync(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OpenChannelSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelPoint* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OpenChannelSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelPoint* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OpenChannel(::grpc::ClientContext* context, ::lnrpc::OpenChannelRequest* request, ::grpc::ClientReadReactor< ::lnrpc::OpenStatusUpdate>* reactor) override;
      #else
      void OpenChannel(::grpc::ClientContext* context, ::lnrpc::OpenChannelRequest* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::OpenStatusUpdate>* reactor) override;
      #endif
      void FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response, std::function<void(::grpc::Status)>) override;
      void FundingStateStep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FundingStateStepResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FundingStateStep(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FundingStateStep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FundingStateStepResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FundingStateStep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FundingStateStepResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChannelAcceptor(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::lnrpc::ChannelAcceptResponse,::lnrpc::ChannelAcceptRequest>* reactor) override;
      #else
      void ChannelAcceptor(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::lnrpc::ChannelAcceptResponse,::lnrpc::ChannelAcceptRequest>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CloseChannel(::grpc::ClientContext* context, ::lnrpc::CloseChannelRequest* request, ::grpc::ClientReadReactor< ::lnrpc::CloseStatusUpdate>* reactor) override;
      #else
      void CloseChannel(::grpc::ClientContext* context, ::lnrpc::CloseChannelRequest* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::CloseStatusUpdate>* reactor) override;
      #endif
      void AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response, std::function<void(::grpc::Status)>) override;
      void AbandonChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AbandonChannelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AbandonChannel(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AbandonChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AbandonChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AbandonChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendPayment(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::lnrpc::SendRequest,::lnrpc::SendResponse>* reactor) override;
      #else
      void SendPayment(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::lnrpc::SendRequest,::lnrpc::SendResponse>* reactor) override;
      #endif
      void SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) override;
      void SendPaymentSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendPaymentSync(::grpc::ClientContext* context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendPaymentSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendPaymentSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendToRoute(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::lnrpc::SendToRouteRequest,::lnrpc::SendResponse>* reactor) override;
      #else
      void SendToRoute(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::lnrpc::SendToRouteRequest,::lnrpc::SendResponse>* reactor) override;
      #endif
      void SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) override;
      void SendToRouteSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendToRouteSync(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendToRouteSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendToRouteSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::SendResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response, std::function<void(::grpc::Status)>) override;
      void AddInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AddInvoiceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddInvoice(::grpc::ClientContext* context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::AddInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response, std::function<void(::grpc::Status)>) override;
      void ListInvoices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListInvoiceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListInvoices(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListInvoices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListInvoices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListInvoiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response, std::function<void(::grpc::Status)>) override;
      void LookupInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::Invoice* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LookupInvoice(::grpc::ClientContext* context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LookupInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::Invoice* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LookupInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::Invoice* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeInvoices(::grpc::ClientContext* context, ::lnrpc::InvoiceSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::Invoice>* reactor) override;
      #else
      void SubscribeInvoices(::grpc::ClientContext* context, ::lnrpc::InvoiceSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::Invoice>* reactor) override;
      #endif
      void DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response, std::function<void(::grpc::Status)>) override;
      void DecodePayReq(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PayReq* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DecodePayReq(::grpc::ClientContext* context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DecodePayReq(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PayReq* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DecodePayReq(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PayReq* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPaymentsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPayments(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteAllPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteAllPaymentsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAllPayments(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAllPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAllPayments(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteAllPaymentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response, std::function<void(::grpc::Status)>) override;
      void DescribeGraph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelGraph* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DescribeGraph(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DescribeGraph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelGraph* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DescribeGraph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelGraph* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNodeMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNodeMetrics(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNodeMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNodeMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response, std::function<void(::grpc::Status)>) override;
      void GetChanInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelEdge* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetChanInfo(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChanInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelEdge* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetChanInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelEdge* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response, std::function<void(::grpc::Status)>) override;
      void GetNodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeInfo* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNodeInfo(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NodeInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response, std::function<void(::grpc::Status)>) override;
      void QueryRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::QueryRoutesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void QueryRoutes(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void QueryRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void QueryRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::QueryRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response, std::function<void(::grpc::Status)>) override;
      void GetNetworkInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NetworkInfo* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNetworkInfo(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNetworkInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NetworkInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNetworkInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response, std::function<void(::grpc::Status)>) override;
      void StopDaemon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::StopResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StopDaemon(::grpc::ClientContext* context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StopDaemon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StopDaemon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeChannelGraph(::grpc::ClientContext* context, ::lnrpc::GraphTopologySubscription* request, ::grpc::ClientReadReactor< ::lnrpc::GraphTopologyUpdate>* reactor) override;
      #else
      void SubscribeChannelGraph(::grpc::ClientContext* context, ::lnrpc::GraphTopologySubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::GraphTopologyUpdate>* reactor) override;
      #endif
      void DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response, std::function<void(::grpc::Status)>) override;
      void DebugLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DebugLevelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DebugLevel(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DebugLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DebugLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DebugLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DebugLevelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response, std::function<void(::grpc::Status)>) override;
      void FeeReport(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FeeReportResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FeeReport(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FeeReport(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FeeReportResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FeeReport(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::FeeReportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateChannelPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PolicyUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateChannelPolicy(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateChannelPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateChannelPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::PolicyUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response, std::function<void(::grpc::Status)>) override;
      void ForwardingHistory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ForwardingHistoryResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ForwardingHistory(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ForwardingHistory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ForwardingHistory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ForwardingHistoryResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response, std::function<void(::grpc::Status)>) override;
      void ExportChannelBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBackup* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExportChannelBackup(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExportChannelBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBackup* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExportChannelBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChannelBackup* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response, std::function<void(::grpc::Status)>) override;
      void ExportAllChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChanBackupSnapshot* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExportAllChannelBackups(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExportAllChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExportAllChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ChanBackupSnapshot* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response, std::function<void(::grpc::Status)>) override;
      void VerifyChanBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyChanBackupResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VerifyChanBackup(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VerifyChanBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VerifyChanBackup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::VerifyChanBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response, std::function<void(::grpc::Status)>) override;
      void RestoreChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::RestoreBackupResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RestoreChannelBackups(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RestoreChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RestoreChannelBackups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::RestoreBackupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeChannelBackups(::grpc::ClientContext* context, ::lnrpc::ChannelBackupSubscription* request, ::grpc::ClientReadReactor< ::lnrpc::ChanBackupSnapshot>* reactor) override;
      #else
      void SubscribeChannelBackups(::grpc::ClientContext* context, ::lnrpc::ChannelBackupSubscription* request, ::grpc::experimental::ClientReadReactor< ::lnrpc::ChanBackupSnapshot>* reactor) override;
      #endif
      void BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response, std::function<void(::grpc::Status)>) override;
      void BakeMacaroon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::BakeMacaroonResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BakeMacaroon(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BakeMacaroon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BakeMacaroon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::BakeMacaroonResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListMacaroonIDs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListMacaroonIDsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListMacaroonIDs(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListMacaroonIDs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListMacaroonIDs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListMacaroonIDsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteMacaroonID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteMacaroonIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteMacaroonID(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteMacaroonID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteMacaroonID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::DeleteMacaroonIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPermissions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPermissionsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPermissions(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPermissions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPermissions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lnrpc::ListPermissionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::lnrpc::WalletBalanceResponse>* AsyncWalletBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::WalletBalanceResponse>* PrepareAsyncWalletBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::WalletBalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBalanceResponse>* AsyncChannelBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBalanceResponse>* PrepareAsyncChannelBalanceRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::TransactionDetails>* AsyncGetTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::TransactionDetails>* PrepareAsyncGetTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::EstimateFeeResponse>* AsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::EstimateFeeResponse>* PrepareAsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::lnrpc::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendCoinsResponse>* AsyncSendCoinsRaw(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendCoinsResponse>* PrepareAsyncSendCoinsRaw(::grpc::ClientContext* context, const ::lnrpc::SendCoinsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListUnspentResponse>* AsyncListUnspentRaw(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListUnspentResponse>* PrepareAsyncListUnspentRaw(::grpc::ClientContext* context, const ::lnrpc::ListUnspentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::Transaction>* SubscribeTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::Transaction>* AsyncSubscribeTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::Transaction>* PrepareAsyncSubscribeTransactionsRaw(::grpc::ClientContext* context, const ::lnrpc::GetTransactionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendManyResponse>* AsyncSendManyRaw(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendManyResponse>* PrepareAsyncSendManyRaw(::grpc::ClientContext* context, const ::lnrpc::SendManyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NewAddressResponse>* AsyncNewAddressRaw(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NewAddressResponse>* PrepareAsyncNewAddressRaw(::grpc::ClientContext* context, const ::lnrpc::NewAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SignMessageResponse>* AsyncSignMessageRaw(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SignMessageResponse>* PrepareAsyncSignMessageRaw(::grpc::ClientContext* context, const ::lnrpc::SignMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyMessageResponse>* AsyncVerifyMessageRaw(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyMessageResponse>* PrepareAsyncVerifyMessageRaw(::grpc::ClientContext* context, const ::lnrpc::VerifyMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ConnectPeerResponse>* AsyncConnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ConnectPeerResponse>* PrepareAsyncConnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::ConnectPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DisconnectPeerResponse>* AsyncDisconnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DisconnectPeerResponse>* PrepareAsyncDisconnectPeerRaw(::grpc::ClientContext* context, const ::lnrpc::DisconnectPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPeersResponse>* AsyncListPeersRaw(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPeersResponse>* PrepareAsyncListPeersRaw(::grpc::ClientContext* context, const ::lnrpc::ListPeersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::PeerEvent>* SubscribePeerEventsRaw(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::PeerEvent>* AsyncSubscribePeerEventsRaw(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::PeerEvent>* PrepareAsyncSubscribePeerEventsRaw(::grpc::ClientContext* context, const ::lnrpc::PeerEventSubscription& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::GetInfoResponse>* AsyncGetInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::GetInfoResponse>* PrepareAsyncGetInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::GetRecoveryInfoResponse>* AsyncGetRecoveryInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::GetRecoveryInfoResponse>* PrepareAsyncGetRecoveryInfoRaw(::grpc::ClientContext* context, const ::lnrpc::GetRecoveryInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::PendingChannelsResponse>* AsyncPendingChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::PendingChannelsResponse>* PrepareAsyncPendingChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::PendingChannelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListChannelsResponse>* AsyncListChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListChannelsResponse>* PrepareAsyncListChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ListChannelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::ChannelEventUpdate>* SubscribeChannelEventsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::ChannelEventUpdate>* AsyncSubscribeChannelEventsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::ChannelEventUpdate>* PrepareAsyncSubscribeChannelEventsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelEventSubscription& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ClosedChannelsResponse>* AsyncClosedChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ClosedChannelsResponse>* PrepareAsyncClosedChannelsRaw(::grpc::ClientContext* context, const ::lnrpc::ClosedChannelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelPoint>* AsyncOpenChannelSyncRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelPoint>* PrepareAsyncOpenChannelSyncRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::OpenStatusUpdate>* OpenChannelRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::OpenStatusUpdate>* AsyncOpenChannelRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::OpenStatusUpdate>* PrepareAsyncOpenChannelRaw(::grpc::ClientContext* context, const ::lnrpc::OpenChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::FundingStateStepResp>* AsyncFundingStateStepRaw(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::FundingStateStepResp>* PrepareAsyncFundingStateStepRaw(::grpc::ClientContext* context, const ::lnrpc::FundingTransitionMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* ChannelAcceptorRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* AsyncChannelAcceptorRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* PrepareAsyncChannelAcceptorRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::CloseStatusUpdate>* CloseChannelRaw(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::CloseStatusUpdate>* AsyncCloseChannelRaw(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::CloseStatusUpdate>* PrepareAsyncCloseChannelRaw(::grpc::ClientContext* context, const ::lnrpc::CloseChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::AbandonChannelResponse>* AsyncAbandonChannelRaw(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::AbandonChannelResponse>* PrepareAsyncAbandonChannelRaw(::grpc::ClientContext* context, const ::lnrpc::AbandonChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* SendPaymentRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* AsyncSendPaymentRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* PrepareAsyncSendPaymentRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>* AsyncSendPaymentSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>* PrepareAsyncSendPaymentSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* SendToRouteRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* AsyncSendToRouteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* PrepareAsyncSendToRouteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>* AsyncSendToRouteSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::SendResponse>* PrepareAsyncSendToRouteSyncRaw(::grpc::ClientContext* context, const ::lnrpc::SendToRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::AddInvoiceResponse>* AsyncAddInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::AddInvoiceResponse>* PrepareAsyncAddInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::Invoice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListInvoiceResponse>* AsyncListInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListInvoiceResponse>* PrepareAsyncListInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::ListInvoiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::Invoice>* AsyncLookupInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::Invoice>* PrepareAsyncLookupInvoiceRaw(::grpc::ClientContext* context, const ::lnrpc::PaymentHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::Invoice>* SubscribeInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::Invoice>* AsyncSubscribeInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::Invoice>* PrepareAsyncSubscribeInvoicesRaw(::grpc::ClientContext* context, const ::lnrpc::InvoiceSubscription& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::PayReq>* AsyncDecodePayReqRaw(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::PayReq>* PrepareAsyncDecodePayReqRaw(::grpc::ClientContext* context, const ::lnrpc::PayReqString& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPaymentsResponse>* AsyncListPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPaymentsResponse>* PrepareAsyncListPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPaymentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteAllPaymentsResponse>* AsyncDeleteAllPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteAllPaymentsResponse>* PrepareAsyncDeleteAllPaymentsRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteAllPaymentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelGraph>* AsyncDescribeGraphRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelGraph>* PrepareAsyncDescribeGraphRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeMetricsResponse>* AsyncGetNodeMetricsRaw(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeMetricsResponse>* PrepareAsyncGetNodeMetricsRaw(::grpc::ClientContext* context, const ::lnrpc::NodeMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelEdge>* AsyncGetChanInfoRaw(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelEdge>* PrepareAsyncGetChanInfoRaw(::grpc::ClientContext* context, const ::lnrpc::ChanInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeInfo>* AsyncGetNodeInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NodeInfo>* PrepareAsyncGetNodeInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NodeInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::QueryRoutesResponse>* AsyncQueryRoutesRaw(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::QueryRoutesResponse>* PrepareAsyncQueryRoutesRaw(::grpc::ClientContext* context, const ::lnrpc::QueryRoutesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NetworkInfo>* AsyncGetNetworkInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::NetworkInfo>* PrepareAsyncGetNetworkInfoRaw(::grpc::ClientContext* context, const ::lnrpc::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::StopResponse>* AsyncStopDaemonRaw(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::StopResponse>* PrepareAsyncStopDaemonRaw(::grpc::ClientContext* context, const ::lnrpc::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::GraphTopologyUpdate>* SubscribeChannelGraphRaw(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::GraphTopologyUpdate>* AsyncSubscribeChannelGraphRaw(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::GraphTopologyUpdate>* PrepareAsyncSubscribeChannelGraphRaw(::grpc::ClientContext* context, const ::lnrpc::GraphTopologySubscription& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DebugLevelResponse>* AsyncDebugLevelRaw(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DebugLevelResponse>* PrepareAsyncDebugLevelRaw(::grpc::ClientContext* context, const ::lnrpc::DebugLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::FeeReportResponse>* AsyncFeeReportRaw(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::FeeReportResponse>* PrepareAsyncFeeReportRaw(::grpc::ClientContext* context, const ::lnrpc::FeeReportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::PolicyUpdateResponse>* AsyncUpdateChannelPolicyRaw(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::PolicyUpdateResponse>* PrepareAsyncUpdateChannelPolicyRaw(::grpc::ClientContext* context, const ::lnrpc::PolicyUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ForwardingHistoryResponse>* AsyncForwardingHistoryRaw(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ForwardingHistoryResponse>* PrepareAsyncForwardingHistoryRaw(::grpc::ClientContext* context, const ::lnrpc::ForwardingHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBackup>* AsyncExportChannelBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChannelBackup>* PrepareAsyncExportChannelBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ExportChannelBackupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChanBackupSnapshot>* AsyncExportAllChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ChanBackupSnapshot>* PrepareAsyncExportAllChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupExportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyChanBackupResponse>* AsyncVerifyChanBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::VerifyChanBackupResponse>* PrepareAsyncVerifyChanBackupRaw(::grpc::ClientContext* context, const ::lnrpc::ChanBackupSnapshot& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::RestoreBackupResponse>* AsyncRestoreChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::RestoreBackupResponse>* PrepareAsyncRestoreChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::RestoreChanBackupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lnrpc::ChanBackupSnapshot>* SubscribeChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request) override;
    ::grpc::ClientAsyncReader< ::lnrpc::ChanBackupSnapshot>* AsyncSubscribeChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lnrpc::ChanBackupSnapshot>* PrepareAsyncSubscribeChannelBackupsRaw(::grpc::ClientContext* context, const ::lnrpc::ChannelBackupSubscription& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::BakeMacaroonResponse>* AsyncBakeMacaroonRaw(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::BakeMacaroonResponse>* PrepareAsyncBakeMacaroonRaw(::grpc::ClientContext* context, const ::lnrpc::BakeMacaroonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListMacaroonIDsResponse>* AsyncListMacaroonIDsRaw(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListMacaroonIDsResponse>* PrepareAsyncListMacaroonIDsRaw(::grpc::ClientContext* context, const ::lnrpc::ListMacaroonIDsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteMacaroonIDResponse>* AsyncDeleteMacaroonIDRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::DeleteMacaroonIDResponse>* PrepareAsyncDeleteMacaroonIDRaw(::grpc::ClientContext* context, const ::lnrpc::DeleteMacaroonIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPermissionsResponse>* AsyncListPermissionsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lnrpc::ListPermissionsResponse>* PrepareAsyncListPermissionsRaw(::grpc::ClientContext* context, const ::lnrpc::ListPermissionsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_WalletBalance_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelBalance_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTransactions_;
    const ::grpc::internal::RpcMethod rpcmethod_EstimateFee_;
    const ::grpc::internal::RpcMethod rpcmethod_SendCoins_;
    const ::grpc::internal::RpcMethod rpcmethod_ListUnspent_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeTransactions_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMany_;
    const ::grpc::internal::RpcMethod rpcmethod_NewAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_SignMessage_;
    const ::grpc::internal::RpcMethod rpcmethod_VerifyMessage_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectPeer_;
    const ::grpc::internal::RpcMethod rpcmethod_DisconnectPeer_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPeers_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribePeerEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_GetInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRecoveryInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_PendingChannels_;
    const ::grpc::internal::RpcMethod rpcmethod_ListChannels_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeChannelEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_ClosedChannels_;
    const ::grpc::internal::RpcMethod rpcmethod_OpenChannelSync_;
    const ::grpc::internal::RpcMethod rpcmethod_OpenChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_FundingStateStep_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelAcceptor_;
    const ::grpc::internal::RpcMethod rpcmethod_CloseChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_AbandonChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_SendPayment_;
    const ::grpc::internal::RpcMethod rpcmethod_SendPaymentSync_;
    const ::grpc::internal::RpcMethod rpcmethod_SendToRoute_;
    const ::grpc::internal::RpcMethod rpcmethod_SendToRouteSync_;
    const ::grpc::internal::RpcMethod rpcmethod_AddInvoice_;
    const ::grpc::internal::RpcMethod rpcmethod_ListInvoices_;
    const ::grpc::internal::RpcMethod rpcmethod_LookupInvoice_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeInvoices_;
    const ::grpc::internal::RpcMethod rpcmethod_DecodePayReq_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPayments_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAllPayments_;
    const ::grpc::internal::RpcMethod rpcmethod_DescribeGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNodeMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_GetChanInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNodeInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_QueryRoutes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNetworkInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_StopDaemon_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeChannelGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_DebugLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_FeeReport_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateChannelPolicy_;
    const ::grpc::internal::RpcMethod rpcmethod_ForwardingHistory_;
    const ::grpc::internal::RpcMethod rpcmethod_ExportChannelBackup_;
    const ::grpc::internal::RpcMethod rpcmethod_ExportAllChannelBackups_;
    const ::grpc::internal::RpcMethod rpcmethod_VerifyChanBackup_;
    const ::grpc::internal::RpcMethod rpcmethod_RestoreChannelBackups_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeChannelBackups_;
    const ::grpc::internal::RpcMethod rpcmethod_BakeMacaroon_;
    const ::grpc::internal::RpcMethod rpcmethod_ListMacaroonIDs_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteMacaroonID_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPermissions_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // lncli: `walletbalance`
    // WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
    // confirmed unspent outputs and all unconfirmed unspent outputs under control
    // of the wallet.
    virtual ::grpc::Status WalletBalance(::grpc::ServerContext* context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response);
    // lncli: `channelbalance`
    // ChannelBalance returns a report on the total funds across all open channels,
    // categorized in local/remote, pending local/remote and unsettled local/remote
    // balances.
    virtual ::grpc::Status ChannelBalance(::grpc::ServerContext* context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response);
    // lncli: `listchaintxns`
    // GetTransactions returns a list describing all the known transactions
    // relevant to the wallet.
    virtual ::grpc::Status GetTransactions(::grpc::ServerContext* context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response);
    // lncli: `estimatefee`
    // EstimateFee asks the chain backend to estimate the fee rate and total fees
    // for a transaction that pays to multiple specified outputs.
    //
    // When using REST, the `AddrToAmount` map type can be set by appending
    // `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
    // map type doesn't appear in the REST API documentation because of a bug in
    // the grpc-gateway library.
    virtual ::grpc::Status EstimateFee(::grpc::ServerContext* context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response);
    // lncli: `sendcoins`
    // SendCoins executes a request to send coins to a particular address. Unlike
    // SendMany, this RPC call only allows creating a single output at a time. If
    // neither target_conf, or sat_per_vbyte are set, then the internal wallet will
    // consult its fee model to determine a fee for the default confirmation
    // target.
    virtual ::grpc::Status SendCoins(::grpc::ServerContext* context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response);
    // lncli: `listunspent`
    // Deprecated, use walletrpc.ListUnspent instead.
    //
    // ListUnspent returns a list of all utxos spendable by the wallet with a
    // number of confirmations between the specified minimum and maximum.
    virtual ::grpc::Status ListUnspent(::grpc::ServerContext* context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response);
    //
    // SubscribeTransactions creates a uni-directional stream from the server to
    // the client in which any newly discovered transactions relevant to the
    // wallet are sent over.
    virtual ::grpc::Status SubscribeTransactions(::grpc::ServerContext* context, const ::lnrpc::GetTransactionsRequest* request, ::grpc::ServerWriter< ::lnrpc::Transaction>* writer);
    // lncli: `sendmany`
    // SendMany handles a request for a transaction that creates multiple specified
    // outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
    // the internal wallet will consult its fee model to determine a fee for the
    // default confirmation target.
    virtual ::grpc::Status SendMany(::grpc::ServerContext* context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response);
    // lncli: `newaddress`
    // NewAddress creates a new address under control of the local wallet.
    virtual ::grpc::Status NewAddress(::grpc::ServerContext* context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response);
    // lncli: `signmessage`
    // SignMessage signs a message with this node's private key. The returned
    // signature string is `zbase32` encoded and pubkey recoverable, meaning that
    // only the message digest and signature are needed for verification.
    virtual ::grpc::Status SignMessage(::grpc::ServerContext* context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response);
    // lncli: `verifymessage`
    // VerifyMessage verifies a signature over a msg. The signature must be
    // zbase32 encoded and signed by an active node in the resident node's
    // channel database. In addition to returning the validity of the signature,
    // VerifyMessage also returns the recovered pubkey from the signature.
    virtual ::grpc::Status VerifyMessage(::grpc::ServerContext* context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response);
    // lncli: `connect`
    // ConnectPeer attempts to establish a connection to a remote peer. This is at
    // the networking level, and is used for communication between nodes. This is
    // distinct from establishing a channel with a peer.
    virtual ::grpc::Status ConnectPeer(::grpc::ServerContext* context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response);
    // lncli: `disconnect`
    // DisconnectPeer attempts to disconnect one peer from another identified by a
    // given pubKey. In the case that we currently have a pending or active channel
    // with the target peer, then this action will be not be allowed.
    virtual ::grpc::Status DisconnectPeer(::grpc::ServerContext* context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response);
    // lncli: `listpeers`
    // ListPeers returns a verbose listing of all currently active peers.
    virtual ::grpc::Status ListPeers(::grpc::ServerContext* context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response);
    //
    // SubscribePeerEvents creates a uni-directional stream from the server to
    // the client in which any events relevant to the state of peers are sent
    // over. Events include peers going online and offline.
    virtual ::grpc::Status SubscribePeerEvents(::grpc::ServerContext* context, const ::lnrpc::PeerEventSubscription* request, ::grpc::ServerWriter< ::lnrpc::PeerEvent>* writer);
    // lncli: `getinfo`
    // GetInfo returns general information concerning the lightning node including
    // it's identity pubkey, alias, the chains it is connected to, and information
    // concerning the number of open+pending channels.
    virtual ::grpc::Status GetInfo(::grpc::ServerContext* context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response);
    // * lncli: `getrecoveryinfo`
    // GetRecoveryInfo returns information concerning the recovery mode including
    // whether it's in a recovery mode, whether the recovery is finished, and the
    // progress made so far.
    virtual ::grpc::Status GetRecoveryInfo(::grpc::ServerContext* context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response);
    // TODO(roasbeef): merge with below with bool?
    //
    // lncli: `pendingchannels`
    // PendingChannels returns a list of all the channels that are currently
    // considered "pending". A channel is pending if it has finished the funding
    // workflow and is waiting for confirmations for the funding txn, or is in the
    // process of closure, either initiated cooperatively or non-cooperatively.
    virtual ::grpc::Status PendingChannels(::grpc::ServerContext* context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response);
    // lncli: `listchannels`
    // ListChannels returns a description of all the open channels that this node
    // is a participant in.
    virtual ::grpc::Status ListChannels(::grpc::ServerContext* context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response);
    //
    // SubscribeChannelEvents creates a uni-directional stream from the server to
    // the client in which any updates relevant to the state of the channels are
    // sent over. Events include new active channels, inactive channels, and closed
    // channels.
    virtual ::grpc::Status SubscribeChannelEvents(::grpc::ServerContext* context, const ::lnrpc::ChannelEventSubscription* request, ::grpc::ServerWriter< ::lnrpc::ChannelEventUpdate>* writer);
    // lncli: `closedchannels`
    // ClosedChannels returns a description of all the closed channels that
    // this node was a participant in.
    virtual ::grpc::Status ClosedChannels(::grpc::ServerContext* context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response);
    //
    // OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
    // call is meant to be consumed by clients to the REST proxy. As with all
    // other sync calls, all byte slices are intended to be populated as hex
    // encoded strings.
    virtual ::grpc::Status OpenChannelSync(::grpc::ServerContext* context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response);
    // lncli: `openchannel`
    // OpenChannel attempts to open a singly funded channel specified in the
    // request to a remote peer. Users are able to specify a target number of
    // blocks that the funding transaction should be confirmed in, or a manual fee
    // rate to us for the funding transaction. If neither are specified, then a
    // lax block confirmation target is used. Each OpenStatusUpdate will return
    // the pending channel ID of the in-progress channel. Depending on the
    // arguments specified in the OpenChannelRequest, this pending channel ID can
    // then be used to manually progress the channel funding flow.
    virtual ::grpc::Status OpenChannel(::grpc::ServerContext* context, const ::lnrpc::OpenChannelRequest* request, ::grpc::ServerWriter< ::lnrpc::OpenStatusUpdate>* writer);
    //
    // FundingStateStep is an advanced funding related call that allows the caller
    // to either execute some preparatory steps for a funding workflow, or
    // manually progress a funding workflow. The primary way a funding flow is
    // identified is via its pending channel ID. As an example, this method can be
    // used to specify that we're expecting a funding flow for a particular
    // pending channel ID, for which we need to use specific parameters.
    // Alternatively, this can be used to interactively drive PSBT signing for
    // funding for partially complete funding transactions.
    virtual ::grpc::Status FundingStateStep(::grpc::ServerContext* context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response);
    //
    // ChannelAcceptor dispatches a bi-directional streaming RPC in which
    // OpenChannel requests are sent to the client and the client responds with
    // a boolean that tells LND whether or not to accept the channel. This allows
    // node operators to specify their own criteria for accepting inbound channels
    // through a single persistent connection.
    virtual ::grpc::Status ChannelAcceptor(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::lnrpc::ChannelAcceptRequest, ::lnrpc::ChannelAcceptResponse>* stream);
    // lncli: `closechannel`
    // CloseChannel attempts to close an active channel identified by its channel
    // outpoint (ChannelPoint). The actions of this method can additionally be
    // augmented to attempt a force close after a timeout period in the case of an
    // inactive peer. If a non-force close (cooperative closure) is requested,
    // then the user can specify either a target number of blocks until the
    // closure transaction is confirmed, or a manual fee rate. If neither are
    // specified, then a default lax, block confirmation target is used.
    virtual ::grpc::Status CloseChannel(::grpc::ServerContext* context, const ::lnrpc::CloseChannelRequest* request, ::grpc::ServerWriter< ::lnrpc::CloseStatusUpdate>* writer);
    // lncli: `abandonchannel`
    // AbandonChannel removes all channel state from the database except for a
    // close summary. This method can be used to get rid of permanently unusable
    // channels due to bugs fixed in newer versions of lnd. This method can also be
    // used to remove externally funded channels where the funding transaction was
    // never broadcast. Only available for non-externally funded channels in dev
    // build.
    virtual ::grpc::Status AbandonChannel(::grpc::ServerContext* context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response);
    // lncli: `sendpayment`
    // Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
    // bi-directional streaming RPC for sending payments through the Lightning
    // Network. A single RPC invocation creates a persistent bi-directional
    // stream allowing clients to rapidly send payments through the Lightning
    // Network with a single persistent connection.
    virtual ::grpc::Status SendPayment(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendRequest>* stream);
    //
    // SendPaymentSync is the synchronous non-streaming version of SendPayment.
    // This RPC is intended to be consumed by clients of the REST proxy.
    // Additionally, this RPC expects the destination's public key and the payment
    // hash (if any) to be encoded as hex strings.
    virtual ::grpc::Status SendPaymentSync(::grpc::ServerContext* context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response);
    // lncli: `sendtoroute`
    // Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
    // streaming RPC for sending payment through the Lightning Network. This
    // method differs from SendPayment in that it allows users to specify a full
    // route manually. This can be used for things like rebalancing, and atomic
    // swaps.
    virtual ::grpc::Status SendToRoute(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendToRouteRequest>* stream);
    //
    // SendToRouteSync is a synchronous version of SendToRoute. It Will block
    // until the payment either fails or succeeds.
    virtual ::grpc::Status SendToRouteSync(::grpc::ServerContext* context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response);
    // lncli: `addinvoice`
    // AddInvoice attempts to add a new invoice to the invoice database. Any
    // duplicated invoices are rejected, therefore all invoices *must* have a
    // unique payment preimage.
    virtual ::grpc::Status AddInvoice(::grpc::ServerContext* context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response);
    // lncli: `listinvoices`
    // ListInvoices returns a list of all the invoices currently stored within the
    // database. Any active debug invoices are ignored. It has full support for
    // paginated responses, allowing users to query for specific invoices through
    // their add_index. This can be done by using either the first_index_offset or
    // last_index_offset fields included in the response as the index_offset of the
    // next request. By default, the first 100 invoices created will be returned.
    // Backwards pagination is also supported through the Reversed flag.
    virtual ::grpc::Status ListInvoices(::grpc::ServerContext* context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response);
    // lncli: `lookupinvoice`
    // LookupInvoice attempts to look up an invoice according to its payment hash.
    // The passed payment hash *must* be exactly 32 bytes, if not, an error is
    // returned.
    virtual ::grpc::Status LookupInvoice(::grpc::ServerContext* context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response);
    //
    // SubscribeInvoices returns a uni-directional stream (server -> client) for
    // notifying the client of newly added/settled invoices. The caller can
    // optionally specify the add_index and/or the settle_index. If the add_index
    // is specified, then we'll first start by sending add invoice events for all
    // invoices with an add_index greater than the specified value. If the
    // settle_index is specified, the next, we'll send out all settle events for
    // invoices with a settle_index greater than the specified value. One or both
    // of these fields can be set. If no fields are set, then we'll only send out
    // the latest add/settle events.
    virtual ::grpc::Status SubscribeInvoices(::grpc::ServerContext* context, const ::lnrpc::InvoiceSubscription* request, ::grpc::ServerWriter< ::lnrpc::Invoice>* writer);
    // lncli: `decodepayreq`
    // DecodePayReq takes an encoded payment request string and attempts to decode
    // it, returning a full description of the conditions encoded within the
    // payment request.
    virtual ::grpc::Status DecodePayReq(::grpc::ServerContext* context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response);
    // lncli: `listpayments`
    // ListPayments returns a list of all outgoing payments.
    virtual ::grpc::Status ListPayments(::grpc::ServerContext* context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response);
    //
    // DeleteAllPayments deletes all outgoing payments from DB.
    virtual ::grpc::Status DeleteAllPayments(::grpc::ServerContext* context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response);
    // lncli: `describegraph`
    // DescribeGraph returns a description of the latest graph state from the
    // point of view of the node. The graph information is partitioned into two
    // components: all the nodes/vertexes, and all the edges that connect the
    // vertexes themselves. As this is a directed graph, the edges also contain
    // the node directional specific routing policy which includes: the time lock
    // delta, fee information, etc.
    virtual ::grpc::Status DescribeGraph(::grpc::ServerContext* context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response);
    // lncli: `getnodemetrics`
    // GetNodeMetrics returns node metrics calculated from the graph. Currently
    // the only supported metric is betweenness centrality of individual nodes.
    virtual ::grpc::Status GetNodeMetrics(::grpc::ServerContext* context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response);
    // lncli: `getchaninfo`
    // GetChanInfo returns the latest authenticated network announcement for the
    // given channel identified by its channel ID: an 8-byte integer which
    // uniquely identifies the location of transaction's funding output within the
    // blockchain.
    virtual ::grpc::Status GetChanInfo(::grpc::ServerContext* context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response);
    // lncli: `getnodeinfo`
    // GetNodeInfo returns the latest advertised, aggregated, and authenticated
    // channel information for the specified node identified by its public key.
    virtual ::grpc::Status GetNodeInfo(::grpc::ServerContext* context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response);
    // lncli: `queryroutes`
    // QueryRoutes attempts to query the daemon's Channel Router for a possible
    // route to a target destination capable of carrying a specific amount of
    // satoshis. The returned route contains the full details required to craft and
    // send an HTLC, also including the necessary information that should be
    // present within the Sphinx packet encapsulated within the HTLC.
    //
    // When using REST, the `dest_custom_records` map type can be set by appending
    // `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
    // to the URL. Unfortunately this map type doesn't appear in the REST API
    // documentation because of a bug in the grpc-gateway library.
    virtual ::grpc::Status QueryRoutes(::grpc::ServerContext* context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response);
    // lncli: `getnetworkinfo`
    // GetNetworkInfo returns some basic stats about the known channel graph from
    // the point of view of the node.
    virtual ::grpc::Status GetNetworkInfo(::grpc::ServerContext* context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response);
    // lncli: `stop`
    // StopDaemon will send a shutdown request to the interrupt handler, triggering
    // a graceful shutdown of the daemon.
    virtual ::grpc::Status StopDaemon(::grpc::ServerContext* context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response);
    //
    // SubscribeChannelGraph launches a streaming RPC that allows the caller to
    // receive notifications upon any changes to the channel graph topology from
    // the point of view of the responding node. Events notified include: new
    // nodes coming online, nodes updating their authenticated attributes, new
    // channels being advertised, updates in the routing policy for a directional
    // channel edge, and when channels are closed on-chain.
    virtual ::grpc::Status SubscribeChannelGraph(::grpc::ServerContext* context, const ::lnrpc::GraphTopologySubscription* request, ::grpc::ServerWriter< ::lnrpc::GraphTopologyUpdate>* writer);
    // lncli: `debuglevel`
    // DebugLevel allows a caller to programmatically set the logging verbosity of
    // lnd. The logging can be targeted according to a coarse daemon-wide logging
    // level, or in a granular fashion to specify the logging for a target
    // sub-system.
    virtual ::grpc::Status DebugLevel(::grpc::ServerContext* context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response);
    // lncli: `feereport`
    // FeeReport allows the caller to obtain a report detailing the current fee
    // schedule enforced by the node globally for each channel.
    virtual ::grpc::Status FeeReport(::grpc::ServerContext* context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response);
    // lncli: `updatechanpolicy`
    // UpdateChannelPolicy allows the caller to update the fee schedule and
    // channel policies for all channels globally, or a particular channel.
    virtual ::grpc::Status UpdateChannelPolicy(::grpc::ServerContext* context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response);
    // lncli: `fwdinghistory`
    // ForwardingHistory allows the caller to query the htlcswitch for a record of
    // all HTLCs forwarded within the target time range, and integer offset
    // within that time range. If no time-range is specified, then the first chunk
    // of the past 24 hrs of forwarding history are returned.
    //
    // A list of forwarding events are returned. The size of each forwarding event
    // is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
    // As a result each message can only contain 50k entries. Each response has
    // the index offset of the last entry. The index offset can be provided to the
    // request to allow the caller to skip a series of records.
    virtual ::grpc::Status ForwardingHistory(::grpc::ServerContext* context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response);
    // lncli: `exportchanbackup`
    // ExportChannelBackup attempts to return an encrypted static channel backup
    // for the target channel identified by it channel point. The backup is
    // encrypted with a key generated from the aezeed seed of the user. The
    // returned backup can either be restored using the RestoreChannelBackup
    // method once lnd is running, or via the InitWallet and UnlockWallet methods
    // from the WalletUnlocker service.
    virtual ::grpc::Status ExportChannelBackup(::grpc::ServerContext* context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response);
    //
    // ExportAllChannelBackups returns static channel backups for all existing
    // channels known to lnd. A set of regular singular static channel backups for
    // each channel are returned. Additionally, a multi-channel backup is returned
    // as well, which contains a single encrypted blob containing the backups of
    // each channel.
    virtual ::grpc::Status ExportAllChannelBackups(::grpc::ServerContext* context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response);
    //
    // VerifyChanBackup allows a caller to verify the integrity of a channel backup
    // snapshot. This method will accept either a packed Single or a packed Multi.
    // Specifying both will result in an error.
    virtual ::grpc::Status VerifyChanBackup(::grpc::ServerContext* context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response);
    // lncli: `restorechanbackup`
    // RestoreChannelBackups accepts a set of singular channel backups, or a
    // single encrypted multi-chan backup and attempts to recover any funds
    // remaining within the channel. If we are able to unpack the backup, then the
    // new channel will be shown under listchannels, as well as pending channels.
    virtual ::grpc::Status RestoreChannelBackups(::grpc::ServerContext* context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response);
    //
    // SubscribeChannelBackups allows a client to sub-subscribe to the most up to
    // date information concerning the state of all channel backups. Each time a
    // new channel is added, we return the new set of channels, along with a
    // multi-chan backup containing the backup info for all channels. Each time a
    // channel is closed, we send a new update, which contains new new chan back
    // ups, but the updated set of encrypted multi-chan backups with the closed
    // channel(s) removed.
    virtual ::grpc::Status SubscribeChannelBackups(::grpc::ServerContext* context, const ::lnrpc::ChannelBackupSubscription* request, ::grpc::ServerWriter< ::lnrpc::ChanBackupSnapshot>* writer);
    // lncli: `bakemacaroon`
    // BakeMacaroon allows the creation of a new macaroon with custom read and
    // write permissions. No first-party caveats are added since this can be done
    // offline.
    virtual ::grpc::Status BakeMacaroon(::grpc::ServerContext* context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response);
    // lncli: `listmacaroonids`
    // ListMacaroonIDs returns all root key IDs that are in use.
    virtual ::grpc::Status ListMacaroonIDs(::grpc::ServerContext* context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response);
    // lncli: `deletemacaroonid`
    // DeleteMacaroonID deletes the specified macaroon ID and invalidates all
    // macaroons derived from that ID.
    virtual ::grpc::Status DeleteMacaroonID(::grpc::ServerContext* context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response);
    // lncli: `listpermissions`
    // ListPermissions lists all RPC method URIs and their required macaroon
    // permissions to access them.
    virtual ::grpc::Status ListPermissions(::grpc::ServerContext* context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_WalletBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WalletBalance() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_WalletBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WalletBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWalletBalance(::grpc::ServerContext* context, ::lnrpc::WalletBalanceRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::WalletBalanceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelBalance() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ChannelBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelBalance(::grpc::ServerContext* context, ::lnrpc::ChannelBalanceRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ChannelBalanceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTransactions() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactions(::grpc::ServerContext* context, ::lnrpc::GetTransactionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::TransactionDetails>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EstimateFee() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateFee(::grpc::ServerContext* context, ::lnrpc::EstimateFeeRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::EstimateFeeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendCoins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendCoins() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SendCoins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCoins(::grpc::ServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendCoins(::grpc::ServerContext* context, ::lnrpc::SendCoinsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::SendCoinsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListUnspent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListUnspent() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListUnspent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUnspent(::grpc::ServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUnspent(::grpc::ServerContext* context, ::lnrpc::ListUnspentRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ListUnspentResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeTransactions() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SubscribeTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::Transaction>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeTransactions(::grpc::ServerContext* context, ::lnrpc::GetTransactionsRequest* request, ::grpc::ServerAsyncWriter< ::lnrpc::Transaction>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMany() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SendMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMany(::grpc::ServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMany(::grpc::ServerContext* context, ::lnrpc::SendManyRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::SendManyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NewAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NewAddress() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_NewAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewAddress(::grpc::ServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewAddress(::grpc::ServerContext* context, ::lnrpc::NewAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::NewAddressResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SignMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SignMessage() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_SignMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SignMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSignMessage(::grpc::ServerContext* context, ::lnrpc::SignMessageRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::SignMessageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VerifyMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VerifyMessage() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_VerifyMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVerifyMessage(::grpc::ServerContext* context, ::lnrpc::VerifyMessageRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::VerifyMessageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectPeer() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ConnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectPeer(::grpc::ServerContext* context, ::lnrpc::ConnectPeerRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ConnectPeerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisconnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisconnectPeer() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_DisconnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisconnectPeer(::grpc::ServerContext* context, ::lnrpc::DisconnectPeerRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::DisconnectPeerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPeers() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ListPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPeers(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPeers(::grpc::ServerContext* context, ::lnrpc::ListPeersRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ListPeersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribePeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribePeerEvents() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_SubscribePeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribePeerEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribePeerEvents(::grpc::ServerContext* context, ::lnrpc::PeerEventSubscription* request, ::grpc::ServerAsyncWriter< ::lnrpc::PeerEvent>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetInfo() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInfo(::grpc::ServerContext* context, ::lnrpc::GetInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::GetInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRecoveryInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRecoveryInfo() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetRecoveryInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecoveryInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecoveryInfo(::grpc::ServerContext* context, ::lnrpc::GetRecoveryInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::GetRecoveryInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PendingChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PendingChannels() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_PendingChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPendingChannels(::grpc::ServerContext* context, ::lnrpc::PendingChannelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::PendingChannelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListChannels() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ListChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListChannels(::grpc::ServerContext* context, ::lnrpc::ListChannelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ListChannelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeChannelEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeChannelEvents() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_SubscribeChannelEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChannelEventUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeChannelEvents(::grpc::ServerContext* context, ::lnrpc::ChannelEventSubscription* request, ::grpc::ServerAsyncWriter< ::lnrpc::ChannelEventUpdate>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(19, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClosedChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClosedChannels() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_ClosedChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClosedChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClosedChannels(::grpc::ServerContext* context, ::lnrpc::ClosedChannelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ClosedChannelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OpenChannelSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OpenChannelSync() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_OpenChannelSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannelSync(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenChannelSync(::grpc::ServerContext* context, ::lnrpc::OpenChannelRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ChannelPoint>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OpenChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OpenChannel() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_OpenChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::OpenStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenChannel(::grpc::ServerContext* context, ::lnrpc::OpenChannelRequest* request, ::grpc::ServerAsyncWriter< ::lnrpc::OpenStatusUpdate>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FundingStateStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FundingStateStep() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_FundingStateStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingStateStep(::grpc::ServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFundingStateStep(::grpc::ServerContext* context, ::lnrpc::FundingTransitionMsg* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::FundingStateStepResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelAcceptor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelAcceptor() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_ChannelAcceptor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAcceptor(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::ChannelAcceptRequest, ::lnrpc::ChannelAcceptResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelAcceptor(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::lnrpc::ChannelAcceptRequest, ::lnrpc::ChannelAcceptResponse>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(24, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CloseChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CloseChannel() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_CloseChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::CloseStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCloseChannel(::grpc::ServerContext* context, ::lnrpc::CloseChannelRequest* request, ::grpc::ServerAsyncWriter< ::lnrpc::CloseStatusUpdate>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AbandonChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AbandonChannel() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_AbandonChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAbandonChannel(::grpc::ServerContext* context, ::lnrpc::AbandonChannelRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::AbandonChannelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendPayment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendPayment() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_SendPayment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPayment(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendPayment(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(27, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendPaymentSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendPaymentSync() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_SendPaymentSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPaymentSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendPaymentSync(::grpc::ServerContext* context, ::lnrpc::SendRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::SendResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendToRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendToRoute() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_SendToRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRoute(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendToRouteRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendToRoute(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendToRouteRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(29, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendToRouteSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendToRouteSync() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_SendToRouteSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRouteSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendToRouteSync(::grpc::ServerContext* context, ::lnrpc::SendToRouteRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::SendResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddInvoice() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_AddInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddInvoice(::grpc::ServerContext* context, ::lnrpc::Invoice* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::AddInvoiceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListInvoices() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_ListInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListInvoices(::grpc::ServerContext* context, ::lnrpc::ListInvoiceRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ListInvoiceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LookupInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LookupInvoice() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_LookupInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LookupInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLookupInvoice(::grpc::ServerContext* context, ::lnrpc::PaymentHash* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::Invoice>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeInvoices() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_SubscribeInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::Invoice>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeInvoices(::grpc::ServerContext* context, ::lnrpc::InvoiceSubscription* request, ::grpc::ServerAsyncWriter< ::lnrpc::Invoice>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(34, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DecodePayReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DecodePayReq() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_DecodePayReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DecodePayReq(::grpc::ServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDecodePayReq(::grpc::ServerContext* context, ::lnrpc::PayReqString* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::PayReq>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPayments() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_ListPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPayments(::grpc::ServerContext* context, ::lnrpc::ListPaymentsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ListPaymentsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAllPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteAllPayments() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_DeleteAllPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAllPayments(::grpc::ServerContext* context, ::lnrpc::DeleteAllPaymentsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::DeleteAllPaymentsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DescribeGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DescribeGraph() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_DescribeGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDescribeGraph(::grpc::ServerContext* context, ::lnrpc::ChannelGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ChannelGraph>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNodeMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNodeMetrics() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_GetNodeMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeMetrics(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeMetrics(::grpc::ServerContext* context, ::lnrpc::NodeMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::NodeMetricsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetChanInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetChanInfo() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_GetChanInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChanInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChanInfo(::grpc::ServerContext* context, ::lnrpc::ChanInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ChannelEdge>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNodeInfo() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_GetNodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeInfo(::grpc::ServerContext* context, ::lnrpc::NodeInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::NodeInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryRoutes() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_QueryRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryRoutes(::grpc::ServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryRoutes(::grpc::ServerContext* context, ::lnrpc::QueryRoutesRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::QueryRoutesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNetworkInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNetworkInfo() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetNetworkInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkInfo(::grpc::ServerContext* context, ::lnrpc::NetworkInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::NetworkInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopDaemon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopDaemon() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_StopDaemon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopDaemon(::grpc::ServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopDaemon(::grpc::ServerContext* context, ::lnrpc::StopRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::StopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeChannelGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeChannelGraph() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_SubscribeChannelGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::GraphTopologyUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeChannelGraph(::grpc::ServerContext* context, ::lnrpc::GraphTopologySubscription* request, ::grpc::ServerAsyncWriter< ::lnrpc::GraphTopologyUpdate>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DebugLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DebugLevel() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_DebugLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DebugLevel(::grpc::ServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDebugLevel(::grpc::ServerContext* context, ::lnrpc::DebugLevelRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::DebugLevelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FeeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FeeReport() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_FeeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeReport(::grpc::ServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeReport(::grpc::ServerContext* context, ::lnrpc::FeeReportRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::FeeReportResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateChannelPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateChannelPolicy() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_UpdateChannelPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateChannelPolicy(::grpc::ServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateChannelPolicy(::grpc::ServerContext* context, ::lnrpc::PolicyUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::PolicyUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ForwardingHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ForwardingHistory() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_ForwardingHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardingHistory(::grpc::ServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestForwardingHistory(::grpc::ServerContext* context, ::lnrpc::ForwardingHistoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ForwardingHistoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExportChannelBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExportChannelBackup() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_ExportChannelBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportChannelBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportChannelBackup(::grpc::ServerContext* context, ::lnrpc::ExportChannelBackupRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ChannelBackup>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExportAllChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExportAllChannelBackups() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_ExportAllChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportAllChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportAllChannelBackups(::grpc::ServerContext* context, ::lnrpc::ChanBackupExportRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ChanBackupSnapshot>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VerifyChanBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VerifyChanBackup() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_VerifyChanBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyChanBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVerifyChanBackup(::grpc::ServerContext* context, ::lnrpc::ChanBackupSnapshot* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::VerifyChanBackupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RestoreChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RestoreChannelBackups() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_RestoreChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestoreChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRestoreChannelBackups(::grpc::ServerContext* context, ::lnrpc::RestoreChanBackupRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::RestoreBackupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeChannelBackups() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_SubscribeChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChanBackupSnapshot>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeChannelBackups(::grpc::ServerContext* context, ::lnrpc::ChannelBackupSubscription* request, ::grpc::ServerAsyncWriter< ::lnrpc::ChanBackupSnapshot>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(54, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BakeMacaroon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BakeMacaroon() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_BakeMacaroon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BakeMacaroon(::grpc::ServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBakeMacaroon(::grpc::ServerContext* context, ::lnrpc::BakeMacaroonRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::BakeMacaroonResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListMacaroonIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListMacaroonIDs() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_ListMacaroonIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMacaroonIDs(::grpc::ServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMacaroonIDs(::grpc::ServerContext* context, ::lnrpc::ListMacaroonIDsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ListMacaroonIDsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteMacaroonID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteMacaroonID() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_DeleteMacaroonID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMacaroonID(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMacaroonID(::grpc::ServerContext* context, ::lnrpc::DeleteMacaroonIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::DeleteMacaroonIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPermissions() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_ListPermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPermissions(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPermissions(::grpc::ServerContext* context, ::lnrpc::ListPermissionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::lnrpc::ListPermissionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_WalletBalance<WithAsyncMethod_ChannelBalance<WithAsyncMethod_GetTransactions<WithAsyncMethod_EstimateFee<WithAsyncMethod_SendCoins<WithAsyncMethod_ListUnspent<WithAsyncMethod_SubscribeTransactions<WithAsyncMethod_SendMany<WithAsyncMethod_NewAddress<WithAsyncMethod_SignMessage<WithAsyncMethod_VerifyMessage<WithAsyncMethod_ConnectPeer<WithAsyncMethod_DisconnectPeer<WithAsyncMethod_ListPeers<WithAsyncMethod_SubscribePeerEvents<WithAsyncMethod_GetInfo<WithAsyncMethod_GetRecoveryInfo<WithAsyncMethod_PendingChannels<WithAsyncMethod_ListChannels<WithAsyncMethod_SubscribeChannelEvents<WithAsyncMethod_ClosedChannels<WithAsyncMethod_OpenChannelSync<WithAsyncMethod_OpenChannel<WithAsyncMethod_FundingStateStep<WithAsyncMethod_ChannelAcceptor<WithAsyncMethod_CloseChannel<WithAsyncMethod_AbandonChannel<WithAsyncMethod_SendPayment<WithAsyncMethod_SendPaymentSync<WithAsyncMethod_SendToRoute<WithAsyncMethod_SendToRouteSync<WithAsyncMethod_AddInvoice<WithAsyncMethod_ListInvoices<WithAsyncMethod_LookupInvoice<WithAsyncMethod_SubscribeInvoices<WithAsyncMethod_DecodePayReq<WithAsyncMethod_ListPayments<WithAsyncMethod_DeleteAllPayments<WithAsyncMethod_DescribeGraph<WithAsyncMethod_GetNodeMetrics<WithAsyncMethod_GetChanInfo<WithAsyncMethod_GetNodeInfo<WithAsyncMethod_QueryRoutes<WithAsyncMethod_GetNetworkInfo<WithAsyncMethod_StopDaemon<WithAsyncMethod_SubscribeChannelGraph<WithAsyncMethod_DebugLevel<WithAsyncMethod_FeeReport<WithAsyncMethod_UpdateChannelPolicy<WithAsyncMethod_ForwardingHistory<WithAsyncMethod_ExportChannelBackup<WithAsyncMethod_ExportAllChannelBackups<WithAsyncMethod_VerifyChanBackup<WithAsyncMethod_RestoreChannelBackups<WithAsyncMethod_SubscribeChannelBackups<WithAsyncMethod_BakeMacaroon<WithAsyncMethod_ListMacaroonIDs<WithAsyncMethod_DeleteMacaroonID<WithAsyncMethod_ListPermissions<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WalletBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WalletBalance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::WalletBalanceRequest, ::lnrpc::WalletBalanceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::WalletBalanceRequest* request, ::lnrpc::WalletBalanceResponse* response) { return this->WalletBalance(context, request, response); }));}
    void SetMessageAllocatorFor_WalletBalance(
        ::grpc::experimental::MessageAllocator< ::lnrpc::WalletBalanceRequest, ::lnrpc::WalletBalanceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::WalletBalanceRequest, ::lnrpc::WalletBalanceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WalletBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WalletBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WalletBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WalletBalance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChannelBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChannelBalance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChannelBalanceRequest, ::lnrpc::ChannelBalanceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ChannelBalanceRequest* request, ::lnrpc::ChannelBalanceResponse* response) { return this->ChannelBalance(context, request, response); }));}
    void SetMessageAllocatorFor_ChannelBalance(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ChannelBalanceRequest, ::lnrpc::ChannelBalanceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChannelBalanceRequest, ::lnrpc::ChannelBalanceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ChannelBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChannelBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChannelBalance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTransactions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::GetTransactionsRequest, ::lnrpc::TransactionDetails>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::GetTransactionsRequest* request, ::lnrpc::TransactionDetails* response) { return this->GetTransactions(context, request, response); }));}
    void SetMessageAllocatorFor_GetTransactions(
        ::grpc::experimental::MessageAllocator< ::lnrpc::GetTransactionsRequest, ::lnrpc::TransactionDetails>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::GetTransactionsRequest, ::lnrpc::TransactionDetails>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTransactions(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTransactions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EstimateFee() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::EstimateFeeRequest, ::lnrpc::EstimateFeeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::EstimateFeeRequest* request, ::lnrpc::EstimateFeeResponse* response) { return this->EstimateFee(context, request, response); }));}
    void SetMessageAllocatorFor_EstimateFee(
        ::grpc::experimental::MessageAllocator< ::lnrpc::EstimateFeeRequest, ::lnrpc::EstimateFeeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::EstimateFeeRequest, ::lnrpc::EstimateFeeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateFee(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateFee(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendCoins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendCoins() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendCoinsRequest, ::lnrpc::SendCoinsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::SendCoinsRequest* request, ::lnrpc::SendCoinsResponse* response) { return this->SendCoins(context, request, response); }));}
    void SetMessageAllocatorFor_SendCoins(
        ::grpc::experimental::MessageAllocator< ::lnrpc::SendCoinsRequest, ::lnrpc::SendCoinsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendCoinsRequest, ::lnrpc::SendCoinsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendCoins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCoins(::grpc::ServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendCoins(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendCoins(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListUnspent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListUnspent() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListUnspentRequest, ::lnrpc::ListUnspentResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ListUnspentRequest* request, ::lnrpc::ListUnspentResponse* response) { return this->ListUnspent(context, request, response); }));}
    void SetMessageAllocatorFor_ListUnspent(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ListUnspentRequest, ::lnrpc::ListUnspentResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListUnspentRequest, ::lnrpc::ListUnspentResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListUnspent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUnspent(::grpc::ServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListUnspent(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListUnspent(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeTransactions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::GetTransactionsRequest, ::lnrpc::Transaction>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::GetTransactionsRequest* request) { return this->SubscribeTransactions(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::Transaction>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::Transaction>* SubscribeTransactions(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::Transaction>* SubscribeTransactions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendMany() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendManyRequest, ::lnrpc::SendManyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::SendManyRequest* request, ::lnrpc::SendManyResponse* response) { return this->SendMany(context, request, response); }));}
    void SetMessageAllocatorFor_SendMany(
        ::grpc::experimental::MessageAllocator< ::lnrpc::SendManyRequest, ::lnrpc::SendManyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendManyRequest, ::lnrpc::SendManyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMany(::grpc::ServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMany(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMany(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NewAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NewAddress() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NewAddressRequest, ::lnrpc::NewAddressResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::NewAddressRequest* request, ::lnrpc::NewAddressResponse* response) { return this->NewAddress(context, request, response); }));}
    void SetMessageAllocatorFor_NewAddress(
        ::grpc::experimental::MessageAllocator< ::lnrpc::NewAddressRequest, ::lnrpc::NewAddressResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NewAddressRequest, ::lnrpc::NewAddressResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NewAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewAddress(::grpc::ServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NewAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NewAddress(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SignMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SignMessage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SignMessageRequest, ::lnrpc::SignMessageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::SignMessageRequest* request, ::lnrpc::SignMessageResponse* response) { return this->SignMessage(context, request, response); }));}
    void SetMessageAllocatorFor_SignMessage(
        ::grpc::experimental::MessageAllocator< ::lnrpc::SignMessageRequest, ::lnrpc::SignMessageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SignMessageRequest, ::lnrpc::SignMessageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SignMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SignMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SignMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SignMessage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VerifyMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VerifyMessage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::VerifyMessageRequest, ::lnrpc::VerifyMessageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::VerifyMessageRequest* request, ::lnrpc::VerifyMessageResponse* response) { return this->VerifyMessage(context, request, response); }));}
    void SetMessageAllocatorFor_VerifyMessage(
        ::grpc::experimental::MessageAllocator< ::lnrpc::VerifyMessageRequest, ::lnrpc::VerifyMessageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::VerifyMessageRequest, ::lnrpc::VerifyMessageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VerifyMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VerifyMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VerifyMessage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ConnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ConnectPeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ConnectPeerRequest, ::lnrpc::ConnectPeerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ConnectPeerRequest* request, ::lnrpc::ConnectPeerResponse* response) { return this->ConnectPeer(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectPeer(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ConnectPeerRequest, ::lnrpc::ConnectPeerResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ConnectPeerRequest, ::lnrpc::ConnectPeerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ConnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ConnectPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ConnectPeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DisconnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DisconnectPeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DisconnectPeerRequest, ::lnrpc::DisconnectPeerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::DisconnectPeerRequest* request, ::lnrpc::DisconnectPeerResponse* response) { return this->DisconnectPeer(context, request, response); }));}
    void SetMessageAllocatorFor_DisconnectPeer(
        ::grpc::experimental::MessageAllocator< ::lnrpc::DisconnectPeerRequest, ::lnrpc::DisconnectPeerResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DisconnectPeerRequest, ::lnrpc::DisconnectPeerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DisconnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DisconnectPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DisconnectPeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListPeers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListPeersRequest, ::lnrpc::ListPeersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ListPeersRequest* request, ::lnrpc::ListPeersResponse* response) { return this->ListPeers(context, request, response); }));}
    void SetMessageAllocatorFor_ListPeers(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ListPeersRequest, ::lnrpc::ListPeersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListPeersRequest, ::lnrpc::ListPeersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPeers(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPeers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribePeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribePeerEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::PeerEventSubscription, ::lnrpc::PeerEvent>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::PeerEventSubscription* request) { return this->SubscribePeerEvents(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribePeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribePeerEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::PeerEvent>* SubscribePeerEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::PeerEvent>* SubscribePeerEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::GetInfoRequest, ::lnrpc::GetInfoResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::GetInfoRequest* request, ::lnrpc::GetInfoResponse* response) { return this->GetInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetInfo(
        ::grpc::experimental::MessageAllocator< ::lnrpc::GetInfoRequest, ::lnrpc::GetInfoResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::GetInfoRequest, ::lnrpc::GetInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRecoveryInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRecoveryInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::GetRecoveryInfoRequest, ::lnrpc::GetRecoveryInfoResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::GetRecoveryInfoRequest* request, ::lnrpc::GetRecoveryInfoResponse* response) { return this->GetRecoveryInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetRecoveryInfo(
        ::grpc::experimental::MessageAllocator< ::lnrpc::GetRecoveryInfoRequest, ::lnrpc::GetRecoveryInfoResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::GetRecoveryInfoRequest, ::lnrpc::GetRecoveryInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRecoveryInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecoveryInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRecoveryInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRecoveryInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PendingChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PendingChannels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PendingChannelsRequest, ::lnrpc::PendingChannelsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::PendingChannelsRequest* request, ::lnrpc::PendingChannelsResponse* response) { return this->PendingChannels(context, request, response); }));}
    void SetMessageAllocatorFor_PendingChannels(
        ::grpc::experimental::MessageAllocator< ::lnrpc::PendingChannelsRequest, ::lnrpc::PendingChannelsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PendingChannelsRequest, ::lnrpc::PendingChannelsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PendingChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PendingChannels(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PendingChannels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListChannels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListChannelsRequest, ::lnrpc::ListChannelsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ListChannelsRequest* request, ::lnrpc::ListChannelsResponse* response) { return this->ListChannels(context, request, response); }));}
    void SetMessageAllocatorFor_ListChannels(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ListChannelsRequest, ::lnrpc::ListChannelsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListChannelsRequest, ::lnrpc::ListChannelsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListChannels(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListChannels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeChannelEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeChannelEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::ChannelEventSubscription, ::lnrpc::ChannelEventUpdate>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ChannelEventSubscription* request) { return this->SubscribeChannelEvents(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeChannelEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChannelEventUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::ChannelEventUpdate>* SubscribeChannelEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::ChannelEventUpdate>* SubscribeChannelEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ClosedChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ClosedChannels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ClosedChannelsRequest, ::lnrpc::ClosedChannelsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ClosedChannelsRequest* request, ::lnrpc::ClosedChannelsResponse* response) { return this->ClosedChannels(context, request, response); }));}
    void SetMessageAllocatorFor_ClosedChannels(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ClosedChannelsRequest, ::lnrpc::ClosedChannelsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ClosedChannelsRequest, ::lnrpc::ClosedChannelsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ClosedChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClosedChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClosedChannels(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClosedChannels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OpenChannelSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OpenChannelSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::OpenChannelRequest, ::lnrpc::ChannelPoint>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::OpenChannelRequest* request, ::lnrpc::ChannelPoint* response) { return this->OpenChannelSync(context, request, response); }));}
    void SetMessageAllocatorFor_OpenChannelSync(
        ::grpc::experimental::MessageAllocator< ::lnrpc::OpenChannelRequest, ::lnrpc::ChannelPoint>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::OpenChannelRequest, ::lnrpc::ChannelPoint>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OpenChannelSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannelSync(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OpenChannelSync(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OpenChannelSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OpenChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OpenChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::OpenChannelRequest, ::lnrpc::OpenStatusUpdate>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::OpenChannelRequest* request) { return this->OpenChannel(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_OpenChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::OpenStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::OpenStatusUpdate>* OpenChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::OpenStatusUpdate>* OpenChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FundingStateStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FundingStateStep() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::FundingTransitionMsg, ::lnrpc::FundingStateStepResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::FundingTransitionMsg* request, ::lnrpc::FundingStateStepResp* response) { return this->FundingStateStep(context, request, response); }));}
    void SetMessageAllocatorFor_FundingStateStep(
        ::grpc::experimental::MessageAllocator< ::lnrpc::FundingTransitionMsg, ::lnrpc::FundingStateStepResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::FundingTransitionMsg, ::lnrpc::FundingStateStepResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FundingStateStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingStateStep(::grpc::ServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FundingStateStep(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FundingStateStep(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChannelAcceptor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChannelAcceptor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc_impl::internal::CallbackBidiHandler< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ChannelAcceptor(context); }));
    }
    ~ExperimentalWithCallbackMethod_ChannelAcceptor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAcceptor(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::ChannelAcceptRequest, ::lnrpc::ChannelAcceptResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* ChannelAcceptor(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::lnrpc::ChannelAcceptResponse, ::lnrpc::ChannelAcceptRequest>* ChannelAcceptor(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CloseChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CloseChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::CloseChannelRequest, ::lnrpc::CloseStatusUpdate>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::CloseChannelRequest* request) { return this->CloseChannel(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_CloseChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::CloseStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::CloseStatusUpdate>* CloseChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::CloseStatusUpdate>* CloseChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AbandonChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AbandonChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::AbandonChannelRequest, ::lnrpc::AbandonChannelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::AbandonChannelRequest* request, ::lnrpc::AbandonChannelResponse* response) { return this->AbandonChannel(context, request, response); }));}
    void SetMessageAllocatorFor_AbandonChannel(
        ::grpc::experimental::MessageAllocator< ::lnrpc::AbandonChannelRequest, ::lnrpc::AbandonChannelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::AbandonChannelRequest, ::lnrpc::AbandonChannelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AbandonChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AbandonChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AbandonChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendPayment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendPayment() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc_impl::internal::CallbackBidiHandler< ::lnrpc::SendRequest, ::lnrpc::SendResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->SendPayment(context); }));
    }
    ~ExperimentalWithCallbackMethod_SendPayment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPayment(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* SendPayment(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* SendPayment(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendPaymentSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendPaymentSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendRequest, ::lnrpc::SendResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::SendRequest* request, ::lnrpc::SendResponse* response) { return this->SendPaymentSync(context, request, response); }));}
    void SetMessageAllocatorFor_SendPaymentSync(
        ::grpc::experimental::MessageAllocator< ::lnrpc::SendRequest, ::lnrpc::SendResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendRequest, ::lnrpc::SendResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendPaymentSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPaymentSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendPaymentSync(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendPaymentSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendToRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendToRoute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc_impl::internal::CallbackBidiHandler< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->SendToRoute(context); }));
    }
    ~ExperimentalWithCallbackMethod_SendToRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRoute(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendToRouteRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* SendToRoute(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* SendToRoute(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendToRouteSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendToRouteSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::SendToRouteRequest* request, ::lnrpc::SendResponse* response) { return this->SendToRouteSync(context, request, response); }));}
    void SetMessageAllocatorFor_SendToRouteSync(
        ::grpc::experimental::MessageAllocator< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(30);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendToRouteSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRouteSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendToRouteSync(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendToRouteSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddInvoice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::Invoice, ::lnrpc::AddInvoiceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::Invoice* request, ::lnrpc::AddInvoiceResponse* response) { return this->AddInvoice(context, request, response); }));}
    void SetMessageAllocatorFor_AddInvoice(
        ::grpc::experimental::MessageAllocator< ::lnrpc::Invoice, ::lnrpc::AddInvoiceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(31);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::Invoice, ::lnrpc::AddInvoiceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddInvoice(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddInvoice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListInvoices() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListInvoiceRequest, ::lnrpc::ListInvoiceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ListInvoiceRequest* request, ::lnrpc::ListInvoiceResponse* response) { return this->ListInvoices(context, request, response); }));}
    void SetMessageAllocatorFor_ListInvoices(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ListInvoiceRequest, ::lnrpc::ListInvoiceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(32);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListInvoiceRequest, ::lnrpc::ListInvoiceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListInvoices(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListInvoices(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LookupInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LookupInvoice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(33,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PaymentHash, ::lnrpc::Invoice>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::PaymentHash* request, ::lnrpc::Invoice* response) { return this->LookupInvoice(context, request, response); }));}
    void SetMessageAllocatorFor_LookupInvoice(
        ::grpc::experimental::MessageAllocator< ::lnrpc::PaymentHash, ::lnrpc::Invoice>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(33);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PaymentHash, ::lnrpc::Invoice>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LookupInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LookupInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LookupInvoice(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LookupInvoice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeInvoices() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(34,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::InvoiceSubscription, ::lnrpc::Invoice>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::InvoiceSubscription* request) { return this->SubscribeInvoices(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::Invoice>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::Invoice>* SubscribeInvoices(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::Invoice>* SubscribeInvoices(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DecodePayReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DecodePayReq() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(35,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PayReqString, ::lnrpc::PayReq>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::PayReqString* request, ::lnrpc::PayReq* response) { return this->DecodePayReq(context, request, response); }));}
    void SetMessageAllocatorFor_DecodePayReq(
        ::grpc::experimental::MessageAllocator< ::lnrpc::PayReqString, ::lnrpc::PayReq>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(35);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PayReqString, ::lnrpc::PayReq>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DecodePayReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DecodePayReq(::grpc::ServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DecodePayReq(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DecodePayReq(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListPayments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(36,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListPaymentsRequest, ::lnrpc::ListPaymentsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ListPaymentsRequest* request, ::lnrpc::ListPaymentsResponse* response) { return this->ListPayments(context, request, response); }));}
    void SetMessageAllocatorFor_ListPayments(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ListPaymentsRequest, ::lnrpc::ListPaymentsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(36);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListPaymentsRequest, ::lnrpc::ListPaymentsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPayments(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPayments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteAllPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteAllPayments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(37,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DeleteAllPaymentsRequest, ::lnrpc::DeleteAllPaymentsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::DeleteAllPaymentsRequest* request, ::lnrpc::DeleteAllPaymentsResponse* response) { return this->DeleteAllPayments(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteAllPayments(
        ::grpc::experimental::MessageAllocator< ::lnrpc::DeleteAllPaymentsRequest, ::lnrpc::DeleteAllPaymentsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(37);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DeleteAllPaymentsRequest, ::lnrpc::DeleteAllPaymentsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteAllPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAllPayments(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAllPayments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DescribeGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DescribeGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(38,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChannelGraphRequest, ::lnrpc::ChannelGraph>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ChannelGraphRequest* request, ::lnrpc::ChannelGraph* response) { return this->DescribeGraph(context, request, response); }));}
    void SetMessageAllocatorFor_DescribeGraph(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ChannelGraphRequest, ::lnrpc::ChannelGraph>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(38);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChannelGraphRequest, ::lnrpc::ChannelGraph>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DescribeGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DescribeGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DescribeGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNodeMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNodeMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(39,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NodeMetricsRequest, ::lnrpc::NodeMetricsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::NodeMetricsRequest* request, ::lnrpc::NodeMetricsResponse* response) { return this->GetNodeMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_GetNodeMetrics(
        ::grpc::experimental::MessageAllocator< ::lnrpc::NodeMetricsRequest, ::lnrpc::NodeMetricsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(39);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NodeMetricsRequest, ::lnrpc::NodeMetricsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNodeMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeMetrics(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNodeMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNodeMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetChanInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetChanInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(40,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChanInfoRequest, ::lnrpc::ChannelEdge>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ChanInfoRequest* request, ::lnrpc::ChannelEdge* response) { return this->GetChanInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetChanInfo(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ChanInfoRequest, ::lnrpc::ChannelEdge>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(40);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChanInfoRequest, ::lnrpc::ChannelEdge>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetChanInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChanInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChanInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChanInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNodeInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(41,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NodeInfoRequest, ::lnrpc::NodeInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::NodeInfoRequest* request, ::lnrpc::NodeInfo* response) { return this->GetNodeInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetNodeInfo(
        ::grpc::experimental::MessageAllocator< ::lnrpc::NodeInfoRequest, ::lnrpc::NodeInfo>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(41);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NodeInfoRequest, ::lnrpc::NodeInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNodeInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_QueryRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_QueryRoutes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(42,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::QueryRoutesRequest, ::lnrpc::QueryRoutesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::QueryRoutesRequest* request, ::lnrpc::QueryRoutesResponse* response) { return this->QueryRoutes(context, request, response); }));}
    void SetMessageAllocatorFor_QueryRoutes(
        ::grpc::experimental::MessageAllocator< ::lnrpc::QueryRoutesRequest, ::lnrpc::QueryRoutesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(42);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::QueryRoutesRequest, ::lnrpc::QueryRoutesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_QueryRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryRoutes(::grpc::ServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* QueryRoutes(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* QueryRoutes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNetworkInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNetworkInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(43,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NetworkInfoRequest, ::lnrpc::NetworkInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::NetworkInfoRequest* request, ::lnrpc::NetworkInfo* response) { return this->GetNetworkInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetNetworkInfo(
        ::grpc::experimental::MessageAllocator< ::lnrpc::NetworkInfoRequest, ::lnrpc::NetworkInfo>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(43);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::NetworkInfoRequest, ::lnrpc::NetworkInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNetworkInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNetworkInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNetworkInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopDaemon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StopDaemon() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(44,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::StopRequest, ::lnrpc::StopResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::StopRequest* request, ::lnrpc::StopResponse* response) { return this->StopDaemon(context, request, response); }));}
    void SetMessageAllocatorFor_StopDaemon(
        ::grpc::experimental::MessageAllocator< ::lnrpc::StopRequest, ::lnrpc::StopResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(44);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::StopRequest, ::lnrpc::StopResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopDaemon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopDaemon(::grpc::ServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopDaemon(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopDaemon(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeChannelGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeChannelGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(45,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::GraphTopologySubscription, ::lnrpc::GraphTopologyUpdate>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::GraphTopologySubscription* request) { return this->SubscribeChannelGraph(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeChannelGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::GraphTopologyUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::GraphTopologyUpdate>* SubscribeChannelGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::GraphTopologyUpdate>* SubscribeChannelGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DebugLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DebugLevel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(46,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DebugLevelRequest, ::lnrpc::DebugLevelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::DebugLevelRequest* request, ::lnrpc::DebugLevelResponse* response) { return this->DebugLevel(context, request, response); }));}
    void SetMessageAllocatorFor_DebugLevel(
        ::grpc::experimental::MessageAllocator< ::lnrpc::DebugLevelRequest, ::lnrpc::DebugLevelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(46);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DebugLevelRequest, ::lnrpc::DebugLevelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DebugLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DebugLevel(::grpc::ServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DebugLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DebugLevel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FeeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FeeReport() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(47,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::FeeReportRequest, ::lnrpc::FeeReportResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::FeeReportRequest* request, ::lnrpc::FeeReportResponse* response) { return this->FeeReport(context, request, response); }));}
    void SetMessageAllocatorFor_FeeReport(
        ::grpc::experimental::MessageAllocator< ::lnrpc::FeeReportRequest, ::lnrpc::FeeReportResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(47);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::FeeReportRequest, ::lnrpc::FeeReportResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FeeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeReport(::grpc::ServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FeeReport(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FeeReport(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateChannelPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateChannelPolicy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(48,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PolicyUpdateRequest, ::lnrpc::PolicyUpdateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::PolicyUpdateRequest* request, ::lnrpc::PolicyUpdateResponse* response) { return this->UpdateChannelPolicy(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateChannelPolicy(
        ::grpc::experimental::MessageAllocator< ::lnrpc::PolicyUpdateRequest, ::lnrpc::PolicyUpdateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(48);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::PolicyUpdateRequest, ::lnrpc::PolicyUpdateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateChannelPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateChannelPolicy(::grpc::ServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateChannelPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateChannelPolicy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ForwardingHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ForwardingHistory() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(49,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ForwardingHistoryRequest, ::lnrpc::ForwardingHistoryResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ForwardingHistoryRequest* request, ::lnrpc::ForwardingHistoryResponse* response) { return this->ForwardingHistory(context, request, response); }));}
    void SetMessageAllocatorFor_ForwardingHistory(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ForwardingHistoryRequest, ::lnrpc::ForwardingHistoryResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(49);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ForwardingHistoryRequest, ::lnrpc::ForwardingHistoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ForwardingHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardingHistory(::grpc::ServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ForwardingHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ForwardingHistory(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExportChannelBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExportChannelBackup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(50,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ExportChannelBackupRequest, ::lnrpc::ChannelBackup>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ExportChannelBackupRequest* request, ::lnrpc::ChannelBackup* response) { return this->ExportChannelBackup(context, request, response); }));}
    void SetMessageAllocatorFor_ExportChannelBackup(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ExportChannelBackupRequest, ::lnrpc::ChannelBackup>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(50);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ExportChannelBackupRequest, ::lnrpc::ChannelBackup>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExportChannelBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportChannelBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExportChannelBackup(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExportChannelBackup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExportAllChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExportAllChannelBackups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(51,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChanBackupExportRequest, ::lnrpc::ChanBackupSnapshot>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ChanBackupExportRequest* request, ::lnrpc::ChanBackupSnapshot* response) { return this->ExportAllChannelBackups(context, request, response); }));}
    void SetMessageAllocatorFor_ExportAllChannelBackups(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ChanBackupExportRequest, ::lnrpc::ChanBackupSnapshot>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(51);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChanBackupExportRequest, ::lnrpc::ChanBackupSnapshot>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExportAllChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportAllChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExportAllChannelBackups(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExportAllChannelBackups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VerifyChanBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VerifyChanBackup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(52,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChanBackupSnapshot, ::lnrpc::VerifyChanBackupResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ChanBackupSnapshot* request, ::lnrpc::VerifyChanBackupResponse* response) { return this->VerifyChanBackup(context, request, response); }));}
    void SetMessageAllocatorFor_VerifyChanBackup(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ChanBackupSnapshot, ::lnrpc::VerifyChanBackupResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(52);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ChanBackupSnapshot, ::lnrpc::VerifyChanBackupResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VerifyChanBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyChanBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VerifyChanBackup(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VerifyChanBackup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RestoreChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RestoreChannelBackups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(53,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::RestoreChanBackupRequest, ::lnrpc::RestoreBackupResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::RestoreChanBackupRequest* request, ::lnrpc::RestoreBackupResponse* response) { return this->RestoreChannelBackups(context, request, response); }));}
    void SetMessageAllocatorFor_RestoreChannelBackups(
        ::grpc::experimental::MessageAllocator< ::lnrpc::RestoreChanBackupRequest, ::lnrpc::RestoreBackupResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(53);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::RestoreChanBackupRequest, ::lnrpc::RestoreBackupResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RestoreChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestoreChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RestoreChannelBackups(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RestoreChannelBackups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeChannelBackups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(54,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lnrpc::ChannelBackupSubscription, ::lnrpc::ChanBackupSnapshot>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ChannelBackupSubscription* request) { return this->SubscribeChannelBackups(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChanBackupSnapshot>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lnrpc::ChanBackupSnapshot>* SubscribeChannelBackups(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lnrpc::ChanBackupSnapshot>* SubscribeChannelBackups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BakeMacaroon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BakeMacaroon() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(55,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::BakeMacaroonRequest, ::lnrpc::BakeMacaroonResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::BakeMacaroonRequest* request, ::lnrpc::BakeMacaroonResponse* response) { return this->BakeMacaroon(context, request, response); }));}
    void SetMessageAllocatorFor_BakeMacaroon(
        ::grpc::experimental::MessageAllocator< ::lnrpc::BakeMacaroonRequest, ::lnrpc::BakeMacaroonResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(55);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::BakeMacaroonRequest, ::lnrpc::BakeMacaroonResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BakeMacaroon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BakeMacaroon(::grpc::ServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BakeMacaroon(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BakeMacaroon(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListMacaroonIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListMacaroonIDs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(56,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListMacaroonIDsRequest, ::lnrpc::ListMacaroonIDsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ListMacaroonIDsRequest* request, ::lnrpc::ListMacaroonIDsResponse* response) { return this->ListMacaroonIDs(context, request, response); }));}
    void SetMessageAllocatorFor_ListMacaroonIDs(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ListMacaroonIDsRequest, ::lnrpc::ListMacaroonIDsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(56);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListMacaroonIDsRequest, ::lnrpc::ListMacaroonIDsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListMacaroonIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMacaroonIDs(::grpc::ServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListMacaroonIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListMacaroonIDs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteMacaroonID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteMacaroonID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(57,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DeleteMacaroonIDRequest, ::lnrpc::DeleteMacaroonIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::DeleteMacaroonIDRequest* request, ::lnrpc::DeleteMacaroonIDResponse* response) { return this->DeleteMacaroonID(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteMacaroonID(
        ::grpc::experimental::MessageAllocator< ::lnrpc::DeleteMacaroonIDRequest, ::lnrpc::DeleteMacaroonIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(57);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::DeleteMacaroonIDRequest, ::lnrpc::DeleteMacaroonIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteMacaroonID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMacaroonID(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteMacaroonID(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteMacaroonID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListPermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListPermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(58,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListPermissionsRequest, ::lnrpc::ListPermissionsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lnrpc::ListPermissionsRequest* request, ::lnrpc::ListPermissionsResponse* response) { return this->ListPermissions(context, request, response); }));}
    void SetMessageAllocatorFor_ListPermissions(
        ::grpc::experimental::MessageAllocator< ::lnrpc::ListPermissionsRequest, ::lnrpc::ListPermissionsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(58);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lnrpc::ListPermissionsRequest, ::lnrpc::ListPermissionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListPermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPermissions(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_WalletBalance<ExperimentalWithCallbackMethod_ChannelBalance<ExperimentalWithCallbackMethod_GetTransactions<ExperimentalWithCallbackMethod_EstimateFee<ExperimentalWithCallbackMethod_SendCoins<ExperimentalWithCallbackMethod_ListUnspent<ExperimentalWithCallbackMethod_SubscribeTransactions<ExperimentalWithCallbackMethod_SendMany<ExperimentalWithCallbackMethod_NewAddress<ExperimentalWithCallbackMethod_SignMessage<ExperimentalWithCallbackMethod_VerifyMessage<ExperimentalWithCallbackMethod_ConnectPeer<ExperimentalWithCallbackMethod_DisconnectPeer<ExperimentalWithCallbackMethod_ListPeers<ExperimentalWithCallbackMethod_SubscribePeerEvents<ExperimentalWithCallbackMethod_GetInfo<ExperimentalWithCallbackMethod_GetRecoveryInfo<ExperimentalWithCallbackMethod_PendingChannels<ExperimentalWithCallbackMethod_ListChannels<ExperimentalWithCallbackMethod_SubscribeChannelEvents<ExperimentalWithCallbackMethod_ClosedChannels<ExperimentalWithCallbackMethod_OpenChannelSync<ExperimentalWithCallbackMethod_OpenChannel<ExperimentalWithCallbackMethod_FundingStateStep<ExperimentalWithCallbackMethod_ChannelAcceptor<ExperimentalWithCallbackMethod_CloseChannel<ExperimentalWithCallbackMethod_AbandonChannel<ExperimentalWithCallbackMethod_SendPayment<ExperimentalWithCallbackMethod_SendPaymentSync<ExperimentalWithCallbackMethod_SendToRoute<ExperimentalWithCallbackMethod_SendToRouteSync<ExperimentalWithCallbackMethod_AddInvoice<ExperimentalWithCallbackMethod_ListInvoices<ExperimentalWithCallbackMethod_LookupInvoice<ExperimentalWithCallbackMethod_SubscribeInvoices<ExperimentalWithCallbackMethod_DecodePayReq<ExperimentalWithCallbackMethod_ListPayments<ExperimentalWithCallbackMethod_DeleteAllPayments<ExperimentalWithCallbackMethod_DescribeGraph<ExperimentalWithCallbackMethod_GetNodeMetrics<ExperimentalWithCallbackMethod_GetChanInfo<ExperimentalWithCallbackMethod_GetNodeInfo<ExperimentalWithCallbackMethod_QueryRoutes<ExperimentalWithCallbackMethod_GetNetworkInfo<ExperimentalWithCallbackMethod_StopDaemon<ExperimentalWithCallbackMethod_SubscribeChannelGraph<ExperimentalWithCallbackMethod_DebugLevel<ExperimentalWithCallbackMethod_FeeReport<ExperimentalWithCallbackMethod_UpdateChannelPolicy<ExperimentalWithCallbackMethod_ForwardingHistory<ExperimentalWithCallbackMethod_ExportChannelBackup<ExperimentalWithCallbackMethod_ExportAllChannelBackups<ExperimentalWithCallbackMethod_VerifyChanBackup<ExperimentalWithCallbackMethod_RestoreChannelBackups<ExperimentalWithCallbackMethod_SubscribeChannelBackups<ExperimentalWithCallbackMethod_BakeMacaroon<ExperimentalWithCallbackMethod_ListMacaroonIDs<ExperimentalWithCallbackMethod_DeleteMacaroonID<ExperimentalWithCallbackMethod_ListPermissions<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_WalletBalance<ExperimentalWithCallbackMethod_ChannelBalance<ExperimentalWithCallbackMethod_GetTransactions<ExperimentalWithCallbackMethod_EstimateFee<ExperimentalWithCallbackMethod_SendCoins<ExperimentalWithCallbackMethod_ListUnspent<ExperimentalWithCallbackMethod_SubscribeTransactions<ExperimentalWithCallbackMethod_SendMany<ExperimentalWithCallbackMethod_NewAddress<ExperimentalWithCallbackMethod_SignMessage<ExperimentalWithCallbackMethod_VerifyMessage<ExperimentalWithCallbackMethod_ConnectPeer<ExperimentalWithCallbackMethod_DisconnectPeer<ExperimentalWithCallbackMethod_ListPeers<ExperimentalWithCallbackMethod_SubscribePeerEvents<ExperimentalWithCallbackMethod_GetInfo<ExperimentalWithCallbackMethod_GetRecoveryInfo<ExperimentalWithCallbackMethod_PendingChannels<ExperimentalWithCallbackMethod_ListChannels<ExperimentalWithCallbackMethod_SubscribeChannelEvents<ExperimentalWithCallbackMethod_ClosedChannels<ExperimentalWithCallbackMethod_OpenChannelSync<ExperimentalWithCallbackMethod_OpenChannel<ExperimentalWithCallbackMethod_FundingStateStep<ExperimentalWithCallbackMethod_ChannelAcceptor<ExperimentalWithCallbackMethod_CloseChannel<ExperimentalWithCallbackMethod_AbandonChannel<ExperimentalWithCallbackMethod_SendPayment<ExperimentalWithCallbackMethod_SendPaymentSync<ExperimentalWithCallbackMethod_SendToRoute<ExperimentalWithCallbackMethod_SendToRouteSync<ExperimentalWithCallbackMethod_AddInvoice<ExperimentalWithCallbackMethod_ListInvoices<ExperimentalWithCallbackMethod_LookupInvoice<ExperimentalWithCallbackMethod_SubscribeInvoices<ExperimentalWithCallbackMethod_DecodePayReq<ExperimentalWithCallbackMethod_ListPayments<ExperimentalWithCallbackMethod_DeleteAllPayments<ExperimentalWithCallbackMethod_DescribeGraph<ExperimentalWithCallbackMethod_GetNodeMetrics<ExperimentalWithCallbackMethod_GetChanInfo<ExperimentalWithCallbackMethod_GetNodeInfo<ExperimentalWithCallbackMethod_QueryRoutes<ExperimentalWithCallbackMethod_GetNetworkInfo<ExperimentalWithCallbackMethod_StopDaemon<ExperimentalWithCallbackMethod_SubscribeChannelGraph<ExperimentalWithCallbackMethod_DebugLevel<ExperimentalWithCallbackMethod_FeeReport<ExperimentalWithCallbackMethod_UpdateChannelPolicy<ExperimentalWithCallbackMethod_ForwardingHistory<ExperimentalWithCallbackMethod_ExportChannelBackup<ExperimentalWithCallbackMethod_ExportAllChannelBackups<ExperimentalWithCallbackMethod_VerifyChanBackup<ExperimentalWithCallbackMethod_RestoreChannelBackups<ExperimentalWithCallbackMethod_SubscribeChannelBackups<ExperimentalWithCallbackMethod_BakeMacaroon<ExperimentalWithCallbackMethod_ListMacaroonIDs<ExperimentalWithCallbackMethod_DeleteMacaroonID<ExperimentalWithCallbackMethod_ListPermissions<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_WalletBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WalletBalance() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_WalletBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WalletBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelBalance() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ChannelBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTransactions() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EstimateFee() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendCoins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendCoins() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SendCoins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCoins(::grpc::ServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListUnspent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListUnspent() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListUnspent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUnspent(::grpc::ServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeTransactions() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SubscribeTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::Transaction>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMany() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SendMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMany(::grpc::ServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NewAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NewAddress() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_NewAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewAddress(::grpc::ServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SignMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SignMessage() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_SignMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SignMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VerifyMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VerifyMessage() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_VerifyMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectPeer() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ConnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisconnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisconnectPeer() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_DisconnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPeers() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ListPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPeers(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribePeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribePeerEvents() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_SubscribePeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribePeerEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetInfo() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRecoveryInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRecoveryInfo() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetRecoveryInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecoveryInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PendingChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PendingChannels() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_PendingChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListChannels() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ListChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeChannelEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeChannelEvents() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_SubscribeChannelEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChannelEventUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClosedChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClosedChannels() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_ClosedChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClosedChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OpenChannelSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OpenChannelSync() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_OpenChannelSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannelSync(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OpenChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OpenChannel() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_OpenChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::OpenStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FundingStateStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FundingStateStep() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_FundingStateStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingStateStep(::grpc::ServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelAcceptor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelAcceptor() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_ChannelAcceptor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAcceptor(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::ChannelAcceptRequest, ::lnrpc::ChannelAcceptResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CloseChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CloseChannel() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_CloseChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::CloseStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AbandonChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AbandonChannel() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_AbandonChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendPayment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendPayment() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_SendPayment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPayment(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendPaymentSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendPaymentSync() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_SendPaymentSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPaymentSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendToRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendToRoute() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_SendToRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRoute(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendToRouteRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendToRouteSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendToRouteSync() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_SendToRouteSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRouteSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddInvoice() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_AddInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListInvoices() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_ListInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LookupInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LookupInvoice() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_LookupInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LookupInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeInvoices() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_SubscribeInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::Invoice>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DecodePayReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DecodePayReq() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_DecodePayReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DecodePayReq(::grpc::ServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPayments() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_ListPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAllPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteAllPayments() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_DeleteAllPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DescribeGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DescribeGraph() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_DescribeGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNodeMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNodeMetrics() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_GetNodeMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeMetrics(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetChanInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetChanInfo() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_GetChanInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChanInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNodeInfo() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_GetNodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QueryRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryRoutes() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_QueryRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryRoutes(::grpc::ServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNetworkInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNetworkInfo() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetNetworkInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopDaemon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopDaemon() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_StopDaemon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopDaemon(::grpc::ServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeChannelGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeChannelGraph() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_SubscribeChannelGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::GraphTopologyUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DebugLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DebugLevel() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_DebugLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DebugLevel(::grpc::ServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FeeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FeeReport() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_FeeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeReport(::grpc::ServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateChannelPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateChannelPolicy() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_UpdateChannelPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateChannelPolicy(::grpc::ServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ForwardingHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ForwardingHistory() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_ForwardingHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardingHistory(::grpc::ServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExportChannelBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExportChannelBackup() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_ExportChannelBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportChannelBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExportAllChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExportAllChannelBackups() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_ExportAllChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportAllChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VerifyChanBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VerifyChanBackup() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_VerifyChanBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyChanBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RestoreChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RestoreChannelBackups() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_RestoreChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestoreChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeChannelBackups() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_SubscribeChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChanBackupSnapshot>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BakeMacaroon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BakeMacaroon() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_BakeMacaroon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BakeMacaroon(::grpc::ServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListMacaroonIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListMacaroonIDs() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_ListMacaroonIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMacaroonIDs(::grpc::ServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteMacaroonID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteMacaroonID() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_DeleteMacaroonID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMacaroonID(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPermissions() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_ListPermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPermissions(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_WalletBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WalletBalance() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_WalletBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WalletBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWalletBalance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelBalance() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ChannelBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelBalance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTransactions() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EstimateFee() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateFee(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendCoins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendCoins() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SendCoins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCoins(::grpc::ServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendCoins(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListUnspent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListUnspent() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ListUnspent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUnspent(::grpc::ServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUnspent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeTransactions() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SubscribeTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::Transaction>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeTransactions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMany() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SendMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMany(::grpc::ServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMany(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NewAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NewAddress() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_NewAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewAddress(::grpc::ServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SignMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SignMessage() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_SignMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SignMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSignMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VerifyMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VerifyMessage() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_VerifyMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVerifyMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectPeer() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ConnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectPeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisconnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisconnectPeer() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_DisconnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisconnectPeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPeers() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ListPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPeers(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPeers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribePeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribePeerEvents() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_SubscribePeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribePeerEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribePeerEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetInfo() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRecoveryInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRecoveryInfo() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetRecoveryInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecoveryInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecoveryInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PendingChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PendingChannels() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_PendingChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPendingChannels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListChannels() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_ListChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListChannels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeChannelEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeChannelEvents() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_SubscribeChannelEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChannelEventUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeChannelEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(19, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClosedChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClosedChannels() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_ClosedChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClosedChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClosedChannels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OpenChannelSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OpenChannelSync() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_OpenChannelSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannelSync(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenChannelSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OpenChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OpenChannel() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_OpenChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::OpenStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FundingStateStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FundingStateStep() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_FundingStateStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingStateStep(::grpc::ServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFundingStateStep(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelAcceptor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelAcceptor() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_ChannelAcceptor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAcceptor(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::ChannelAcceptRequest, ::lnrpc::ChannelAcceptResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelAcceptor(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(24, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CloseChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CloseChannel() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_CloseChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::CloseStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCloseChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AbandonChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AbandonChannel() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_AbandonChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAbandonChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendPayment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendPayment() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_SendPayment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPayment(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendPayment(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(27, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendPaymentSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendPaymentSync() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_SendPaymentSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPaymentSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendPaymentSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendToRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendToRoute() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_SendToRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRoute(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendToRouteRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendToRoute(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(29, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendToRouteSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendToRouteSync() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_SendToRouteSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRouteSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendToRouteSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddInvoice() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_AddInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddInvoice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListInvoices() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_ListInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListInvoices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LookupInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LookupInvoice() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_LookupInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LookupInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLookupInvoice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeInvoices() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_SubscribeInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::Invoice>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeInvoices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(34, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DecodePayReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DecodePayReq() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_DecodePayReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DecodePayReq(::grpc::ServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDecodePayReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPayments() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_ListPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPayments(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAllPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteAllPayments() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_DeleteAllPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAllPayments(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DescribeGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DescribeGraph() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_DescribeGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDescribeGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNodeMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNodeMetrics() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_GetNodeMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeMetrics(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetChanInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetChanInfo() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_GetChanInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChanInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChanInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNodeInfo() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_GetNodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryRoutes() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_QueryRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryRoutes(::grpc::ServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryRoutes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNetworkInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNetworkInfo() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetNetworkInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopDaemon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopDaemon() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_StopDaemon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopDaemon(::grpc::ServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopDaemon(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeChannelGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeChannelGraph() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_SubscribeChannelGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::GraphTopologyUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeChannelGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DebugLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DebugLevel() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_DebugLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DebugLevel(::grpc::ServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDebugLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FeeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FeeReport() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_FeeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeReport(::grpc::ServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeReport(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateChannelPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateChannelPolicy() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_UpdateChannelPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateChannelPolicy(::grpc::ServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateChannelPolicy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ForwardingHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ForwardingHistory() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_ForwardingHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardingHistory(::grpc::ServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestForwardingHistory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExportChannelBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExportChannelBackup() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_ExportChannelBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportChannelBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportChannelBackup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExportAllChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExportAllChannelBackups() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_ExportAllChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportAllChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportAllChannelBackups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VerifyChanBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VerifyChanBackup() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_VerifyChanBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyChanBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVerifyChanBackup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RestoreChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RestoreChannelBackups() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_RestoreChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestoreChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRestoreChannelBackups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeChannelBackups() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_SubscribeChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChanBackupSnapshot>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeChannelBackups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(54, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BakeMacaroon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BakeMacaroon() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_BakeMacaroon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BakeMacaroon(::grpc::ServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBakeMacaroon(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListMacaroonIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListMacaroonIDs() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_ListMacaroonIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMacaroonIDs(::grpc::ServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMacaroonIDs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteMacaroonID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteMacaroonID() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_DeleteMacaroonID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMacaroonID(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMacaroonID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPermissions() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_ListPermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPermissions(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPermissions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WalletBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WalletBalance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WalletBalance(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WalletBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WalletBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WalletBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WalletBalance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChannelBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChannelBalance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChannelBalance(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChannelBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChannelBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChannelBalance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTransactions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTransactions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTransactions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTransactions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EstimateFee() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EstimateFee(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateFee(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateFee(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendCoins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendCoins() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendCoins(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendCoins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCoins(::grpc::ServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendCoins(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendCoins(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListUnspent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListUnspent() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListUnspent(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListUnspent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUnspent(::grpc::ServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListUnspent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListUnspent(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeTransactions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeTransactions(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::Transaction>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeTransactions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeTransactions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendMany() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMany(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMany(::grpc::ServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMany(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMany(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NewAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NewAddress() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NewAddress(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NewAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewAddress(::grpc::ServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NewAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NewAddress(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SignMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SignMessage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SignMessage(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SignMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SignMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SignMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SignMessage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VerifyMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VerifyMessage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VerifyMessage(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_VerifyMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VerifyMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VerifyMessage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ConnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ConnectPeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectPeer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ConnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ConnectPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ConnectPeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DisconnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DisconnectPeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisconnectPeer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DisconnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DisconnectPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DisconnectPeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListPeers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPeers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPeers(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPeers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribePeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribePeerEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribePeerEvents(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribePeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribePeerEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribePeerEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribePeerEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRecoveryInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRecoveryInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRecoveryInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRecoveryInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecoveryInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRecoveryInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRecoveryInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PendingChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PendingChannels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PendingChannels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PendingChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PendingChannels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PendingChannels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListChannels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListChannels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListChannels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListChannels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeChannelEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeChannelEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeChannelEvents(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeChannelEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChannelEventUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeChannelEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeChannelEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ClosedChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ClosedChannels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClosedChannels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ClosedChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClosedChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClosedChannels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClosedChannels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OpenChannelSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OpenChannelSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OpenChannelSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OpenChannelSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannelSync(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OpenChannelSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OpenChannelSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OpenChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OpenChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->OpenChannel(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_OpenChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::OpenStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* OpenChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* OpenChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FundingStateStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FundingStateStep() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FundingStateStep(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FundingStateStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingStateStep(::grpc::ServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FundingStateStep(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FundingStateStep(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChannelAcceptor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChannelAcceptor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ChannelAcceptor(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChannelAcceptor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAcceptor(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::ChannelAcceptRequest, ::lnrpc::ChannelAcceptResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ChannelAcceptor(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ChannelAcceptor(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CloseChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CloseChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->CloseChannel(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_CloseChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::CloseStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* CloseChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* CloseChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AbandonChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AbandonChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AbandonChannel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AbandonChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AbandonChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AbandonChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendPayment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendPayment() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->SendPayment(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendPayment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPayment(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SendPayment(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SendPayment(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendPaymentSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendPaymentSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendPaymentSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendPaymentSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPaymentSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendPaymentSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendPaymentSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendToRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendToRoute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->SendToRoute(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendToRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRoute(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::lnrpc::SendResponse, ::lnrpc::SendToRouteRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SendToRoute(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SendToRoute(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendToRouteSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendToRouteSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendToRouteSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendToRouteSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToRouteSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendToRouteSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendToRouteSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddInvoice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddInvoice(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddInvoice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddInvoice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListInvoices() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListInvoices(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListInvoices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListInvoices(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LookupInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LookupInvoice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(33,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LookupInvoice(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LookupInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LookupInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LookupInvoice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LookupInvoice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeInvoices() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(34,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeInvoices(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::Invoice>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeInvoices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeInvoices(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DecodePayReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DecodePayReq() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(35,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DecodePayReq(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DecodePayReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DecodePayReq(::grpc::ServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DecodePayReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DecodePayReq(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListPayments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(36,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPayments(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPayments(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPayments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteAllPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteAllPayments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(37,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteAllPayments(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteAllPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAllPayments(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAllPayments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DescribeGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DescribeGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(38,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DescribeGraph(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DescribeGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DescribeGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DescribeGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNodeMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNodeMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(39,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNodeMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNodeMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeMetrics(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNodeMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNodeMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetChanInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetChanInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(40,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetChanInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetChanInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChanInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChanInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChanInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNodeInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(41,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNodeInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNodeInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_QueryRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_QueryRoutes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(42,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryRoutes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_QueryRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryRoutes(::grpc::ServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* QueryRoutes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* QueryRoutes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNetworkInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNetworkInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(43,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNetworkInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNetworkInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNetworkInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNetworkInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopDaemon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StopDaemon() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(44,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopDaemon(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StopDaemon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopDaemon(::grpc::ServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopDaemon(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopDaemon(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeChannelGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeChannelGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(45,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeChannelGraph(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeChannelGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::GraphTopologyUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeChannelGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeChannelGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DebugLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DebugLevel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(46,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DebugLevel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DebugLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DebugLevel(::grpc::ServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DebugLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DebugLevel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FeeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FeeReport() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(47,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FeeReport(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FeeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeReport(::grpc::ServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FeeReport(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FeeReport(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateChannelPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateChannelPolicy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(48,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateChannelPolicy(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateChannelPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateChannelPolicy(::grpc::ServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateChannelPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateChannelPolicy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ForwardingHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ForwardingHistory() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(49,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ForwardingHistory(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ForwardingHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardingHistory(::grpc::ServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ForwardingHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ForwardingHistory(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExportChannelBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExportChannelBackup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(50,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExportChannelBackup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExportChannelBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportChannelBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExportChannelBackup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExportChannelBackup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExportAllChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExportAllChannelBackups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(51,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExportAllChannelBackups(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExportAllChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportAllChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExportAllChannelBackups(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExportAllChannelBackups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VerifyChanBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VerifyChanBackup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(52,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VerifyChanBackup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_VerifyChanBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyChanBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VerifyChanBackup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VerifyChanBackup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RestoreChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RestoreChannelBackups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(53,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RestoreChannelBackups(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RestoreChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestoreChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RestoreChannelBackups(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RestoreChannelBackups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeChannelBackups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(54,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeChannelBackups(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChanBackupSnapshot>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeChannelBackups(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeChannelBackups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BakeMacaroon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BakeMacaroon() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(55,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BakeMacaroon(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BakeMacaroon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BakeMacaroon(::grpc::ServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BakeMacaroon(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BakeMacaroon(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListMacaroonIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListMacaroonIDs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(56,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListMacaroonIDs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListMacaroonIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMacaroonIDs(::grpc::ServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListMacaroonIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListMacaroonIDs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteMacaroonID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteMacaroonID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(57,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteMacaroonID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteMacaroonID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMacaroonID(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteMacaroonID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteMacaroonID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListPermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListPermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(58,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPermissions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListPermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPermissions(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WalletBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WalletBalance() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::WalletBalanceRequest, ::lnrpc::WalletBalanceResponse>(std::bind(&WithStreamedUnaryMethod_WalletBalance<BaseClass>::StreamedWalletBalance, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WalletBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WalletBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::WalletBalanceRequest* /*request*/, ::lnrpc::WalletBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWalletBalance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::WalletBalanceRequest,::lnrpc::WalletBalanceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChannelBalance() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ChannelBalanceRequest, ::lnrpc::ChannelBalanceResponse>(std::bind(&WithStreamedUnaryMethod_ChannelBalance<BaseClass>::StreamedChannelBalance, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ChannelBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelBalance(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBalanceRequest* /*request*/, ::lnrpc::ChannelBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelBalance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ChannelBalanceRequest,::lnrpc::ChannelBalanceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTransactions() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::GetTransactionsRequest, ::lnrpc::TransactionDetails>(std::bind(&WithStreamedUnaryMethod_GetTransactions<BaseClass>::StreamedGetTransactions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::lnrpc::TransactionDetails* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTransactions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::GetTransactionsRequest,::lnrpc::TransactionDetails>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EstimateFee() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::EstimateFeeRequest, ::lnrpc::EstimateFeeResponse>(std::bind(&WithStreamedUnaryMethod_EstimateFee<BaseClass>::StreamedEstimateFee, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::lnrpc::EstimateFeeRequest* /*request*/, ::lnrpc::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEstimateFee(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::EstimateFeeRequest,::lnrpc::EstimateFeeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendCoins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendCoins() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::SendCoinsRequest, ::lnrpc::SendCoinsResponse>(std::bind(&WithStreamedUnaryMethod_SendCoins<BaseClass>::StreamedSendCoins, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SendCoins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendCoins(::grpc::ServerContext* /*context*/, const ::lnrpc::SendCoinsRequest* /*request*/, ::lnrpc::SendCoinsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendCoins(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::SendCoinsRequest,::lnrpc::SendCoinsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListUnspent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListUnspent() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ListUnspentRequest, ::lnrpc::ListUnspentResponse>(std::bind(&WithStreamedUnaryMethod_ListUnspent<BaseClass>::StreamedListUnspent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListUnspent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListUnspent(::grpc::ServerContext* /*context*/, const ::lnrpc::ListUnspentRequest* /*request*/, ::lnrpc::ListUnspentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListUnspent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ListUnspentRequest,::lnrpc::ListUnspentResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMany() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::SendManyRequest, ::lnrpc::SendManyResponse>(std::bind(&WithStreamedUnaryMethod_SendMany<BaseClass>::StreamedSendMany, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SendMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMany(::grpc::ServerContext* /*context*/, const ::lnrpc::SendManyRequest* /*request*/, ::lnrpc::SendManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMany(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::SendManyRequest,::lnrpc::SendManyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NewAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NewAddress() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::NewAddressRequest, ::lnrpc::NewAddressResponse>(std::bind(&WithStreamedUnaryMethod_NewAddress<BaseClass>::StreamedNewAddress, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NewAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NewAddress(::grpc::ServerContext* /*context*/, const ::lnrpc::NewAddressRequest* /*request*/, ::lnrpc::NewAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNewAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::NewAddressRequest,::lnrpc::NewAddressResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SignMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SignMessage() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::SignMessageRequest, ::lnrpc::SignMessageResponse>(std::bind(&WithStreamedUnaryMethod_SignMessage<BaseClass>::StreamedSignMessage, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SignMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SignMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::SignMessageRequest* /*request*/, ::lnrpc::SignMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSignMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::SignMessageRequest,::lnrpc::SignMessageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VerifyMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VerifyMessage() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::VerifyMessageRequest, ::lnrpc::VerifyMessageResponse>(std::bind(&WithStreamedUnaryMethod_VerifyMessage<BaseClass>::StreamedVerifyMessage, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VerifyMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VerifyMessage(::grpc::ServerContext* /*context*/, const ::lnrpc::VerifyMessageRequest* /*request*/, ::lnrpc::VerifyMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVerifyMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::VerifyMessageRequest,::lnrpc::VerifyMessageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectPeer() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ConnectPeerRequest, ::lnrpc::ConnectPeerResponse>(std::bind(&WithStreamedUnaryMethod_ConnectPeer<BaseClass>::StreamedConnectPeer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ConnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::ConnectPeerRequest* /*request*/, ::lnrpc::ConnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectPeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ConnectPeerRequest,::lnrpc::ConnectPeerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisconnectPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisconnectPeer() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::DisconnectPeerRequest, ::lnrpc::DisconnectPeerResponse>(std::bind(&WithStreamedUnaryMethod_DisconnectPeer<BaseClass>::StreamedDisconnectPeer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DisconnectPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisconnectPeer(::grpc::ServerContext* /*context*/, const ::lnrpc::DisconnectPeerRequest* /*request*/, ::lnrpc::DisconnectPeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisconnectPeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::DisconnectPeerRequest,::lnrpc::DisconnectPeerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPeers() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ListPeersRequest, ::lnrpc::ListPeersResponse>(std::bind(&WithStreamedUnaryMethod_ListPeers<BaseClass>::StreamedListPeers, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPeers(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPeersRequest* /*request*/, ::lnrpc::ListPeersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPeers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ListPeersRequest,::lnrpc::ListPeersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetInfo() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::GetInfoRequest, ::lnrpc::GetInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetInfo<BaseClass>::StreamedGetInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetInfoRequest* /*request*/, ::lnrpc::GetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::GetInfoRequest,::lnrpc::GetInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRecoveryInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRecoveryInfo() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::GetRecoveryInfoRequest, ::lnrpc::GetRecoveryInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetRecoveryInfo<BaseClass>::StreamedGetRecoveryInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRecoveryInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRecoveryInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::GetRecoveryInfoRequest* /*request*/, ::lnrpc::GetRecoveryInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRecoveryInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::GetRecoveryInfoRequest,::lnrpc::GetRecoveryInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PendingChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PendingChannels() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::PendingChannelsRequest, ::lnrpc::PendingChannelsResponse>(std::bind(&WithStreamedUnaryMethod_PendingChannels<BaseClass>::StreamedPendingChannels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PendingChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PendingChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::PendingChannelsRequest* /*request*/, ::lnrpc::PendingChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPendingChannels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::PendingChannelsRequest,::lnrpc::PendingChannelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListChannels() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ListChannelsRequest, ::lnrpc::ListChannelsResponse>(std::bind(&WithStreamedUnaryMethod_ListChannels<BaseClass>::StreamedListChannels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ListChannelsRequest* /*request*/, ::lnrpc::ListChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListChannels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ListChannelsRequest,::lnrpc::ListChannelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClosedChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClosedChannels() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ClosedChannelsRequest, ::lnrpc::ClosedChannelsResponse>(std::bind(&WithStreamedUnaryMethod_ClosedChannels<BaseClass>::StreamedClosedChannels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ClosedChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClosedChannels(::grpc::ServerContext* /*context*/, const ::lnrpc::ClosedChannelsRequest* /*request*/, ::lnrpc::ClosedChannelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClosedChannels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ClosedChannelsRequest,::lnrpc::ClosedChannelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OpenChannelSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OpenChannelSync() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::OpenChannelRequest, ::lnrpc::ChannelPoint>(std::bind(&WithStreamedUnaryMethod_OpenChannelSync<BaseClass>::StreamedOpenChannelSync, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_OpenChannelSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OpenChannelSync(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::lnrpc::ChannelPoint* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOpenChannelSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::OpenChannelRequest,::lnrpc::ChannelPoint>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FundingStateStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FundingStateStep() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::FundingTransitionMsg, ::lnrpc::FundingStateStepResp>(std::bind(&WithStreamedUnaryMethod_FundingStateStep<BaseClass>::StreamedFundingStateStep, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FundingStateStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FundingStateStep(::grpc::ServerContext* /*context*/, const ::lnrpc::FundingTransitionMsg* /*request*/, ::lnrpc::FundingStateStepResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFundingStateStep(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::FundingTransitionMsg,::lnrpc::FundingStateStepResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AbandonChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AbandonChannel() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::AbandonChannelRequest, ::lnrpc::AbandonChannelResponse>(std::bind(&WithStreamedUnaryMethod_AbandonChannel<BaseClass>::StreamedAbandonChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AbandonChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AbandonChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::AbandonChannelRequest* /*request*/, ::lnrpc::AbandonChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAbandonChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::AbandonChannelRequest,::lnrpc::AbandonChannelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendPaymentSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendPaymentSync() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::SendRequest, ::lnrpc::SendResponse>(std::bind(&WithStreamedUnaryMethod_SendPaymentSync<BaseClass>::StreamedSendPaymentSync, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SendPaymentSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendPaymentSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendPaymentSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::SendRequest,::lnrpc::SendResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendToRouteSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendToRouteSync() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::SendToRouteRequest, ::lnrpc::SendResponse>(std::bind(&WithStreamedUnaryMethod_SendToRouteSync<BaseClass>::StreamedSendToRouteSync, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SendToRouteSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendToRouteSync(::grpc::ServerContext* /*context*/, const ::lnrpc::SendToRouteRequest* /*request*/, ::lnrpc::SendResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendToRouteSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::SendToRouteRequest,::lnrpc::SendResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddInvoice() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::Invoice, ::lnrpc::AddInvoiceResponse>(std::bind(&WithStreamedUnaryMethod_AddInvoice<BaseClass>::StreamedAddInvoice, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AddInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::Invoice* /*request*/, ::lnrpc::AddInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddInvoice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::Invoice,::lnrpc::AddInvoiceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListInvoices() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ListInvoiceRequest, ::lnrpc::ListInvoiceResponse>(std::bind(&WithStreamedUnaryMethod_ListInvoices<BaseClass>::StreamedListInvoices, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::ListInvoiceRequest* /*request*/, ::lnrpc::ListInvoiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListInvoices(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ListInvoiceRequest,::lnrpc::ListInvoiceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LookupInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LookupInvoice() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::PaymentHash, ::lnrpc::Invoice>(std::bind(&WithStreamedUnaryMethod_LookupInvoice<BaseClass>::StreamedLookupInvoice, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_LookupInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LookupInvoice(::grpc::ServerContext* /*context*/, const ::lnrpc::PaymentHash* /*request*/, ::lnrpc::Invoice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLookupInvoice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::PaymentHash,::lnrpc::Invoice>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DecodePayReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DecodePayReq() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::PayReqString, ::lnrpc::PayReq>(std::bind(&WithStreamedUnaryMethod_DecodePayReq<BaseClass>::StreamedDecodePayReq, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DecodePayReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DecodePayReq(::grpc::ServerContext* /*context*/, const ::lnrpc::PayReqString* /*request*/, ::lnrpc::PayReq* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDecodePayReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::PayReqString,::lnrpc::PayReq>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPayments() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ListPaymentsRequest, ::lnrpc::ListPaymentsResponse>(std::bind(&WithStreamedUnaryMethod_ListPayments<BaseClass>::StreamedListPayments, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPaymentsRequest* /*request*/, ::lnrpc::ListPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPayments(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ListPaymentsRequest,::lnrpc::ListPaymentsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAllPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteAllPayments() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::DeleteAllPaymentsRequest, ::lnrpc::DeleteAllPaymentsResponse>(std::bind(&WithStreamedUnaryMethod_DeleteAllPayments<BaseClass>::StreamedDeleteAllPayments, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteAllPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAllPayments(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteAllPaymentsRequest* /*request*/, ::lnrpc::DeleteAllPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAllPayments(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::DeleteAllPaymentsRequest,::lnrpc::DeleteAllPaymentsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DescribeGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DescribeGraph() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ChannelGraphRequest, ::lnrpc::ChannelGraph>(std::bind(&WithStreamedUnaryMethod_DescribeGraph<BaseClass>::StreamedDescribeGraph, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DescribeGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DescribeGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelGraphRequest* /*request*/, ::lnrpc::ChannelGraph* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDescribeGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ChannelGraphRequest,::lnrpc::ChannelGraph>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNodeMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNodeMetrics() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::NodeMetricsRequest, ::lnrpc::NodeMetricsResponse>(std::bind(&WithStreamedUnaryMethod_GetNodeMetrics<BaseClass>::StreamedGetNodeMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNodeMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNodeMetrics(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeMetricsRequest* /*request*/, ::lnrpc::NodeMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNodeMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::NodeMetricsRequest,::lnrpc::NodeMetricsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetChanInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetChanInfo() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ChanInfoRequest, ::lnrpc::ChannelEdge>(std::bind(&WithStreamedUnaryMethod_GetChanInfo<BaseClass>::StreamedGetChanInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetChanInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetChanInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanInfoRequest* /*request*/, ::lnrpc::ChannelEdge* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetChanInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ChanInfoRequest,::lnrpc::ChannelEdge>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNodeInfo() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::NodeInfoRequest, ::lnrpc::NodeInfo>(std::bind(&WithStreamedUnaryMethod_GetNodeInfo<BaseClass>::StreamedGetNodeInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNodeInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NodeInfoRequest* /*request*/, ::lnrpc::NodeInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNodeInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::NodeInfoRequest,::lnrpc::NodeInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryRoutes() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::QueryRoutesRequest, ::lnrpc::QueryRoutesResponse>(std::bind(&WithStreamedUnaryMethod_QueryRoutes<BaseClass>::StreamedQueryRoutes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_QueryRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryRoutes(::grpc::ServerContext* /*context*/, const ::lnrpc::QueryRoutesRequest* /*request*/, ::lnrpc::QueryRoutesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryRoutes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::QueryRoutesRequest,::lnrpc::QueryRoutesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNetworkInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNetworkInfo() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::NetworkInfoRequest, ::lnrpc::NetworkInfo>(std::bind(&WithStreamedUnaryMethod_GetNetworkInfo<BaseClass>::StreamedGetNetworkInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNetworkInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNetworkInfo(::grpc::ServerContext* /*context*/, const ::lnrpc::NetworkInfoRequest* /*request*/, ::lnrpc::NetworkInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNetworkInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::NetworkInfoRequest,::lnrpc::NetworkInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopDaemon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopDaemon() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::StopRequest, ::lnrpc::StopResponse>(std::bind(&WithStreamedUnaryMethod_StopDaemon<BaseClass>::StreamedStopDaemon, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopDaemon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopDaemon(::grpc::ServerContext* /*context*/, const ::lnrpc::StopRequest* /*request*/, ::lnrpc::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopDaemon(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::StopRequest,::lnrpc::StopResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DebugLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DebugLevel() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::DebugLevelRequest, ::lnrpc::DebugLevelResponse>(std::bind(&WithStreamedUnaryMethod_DebugLevel<BaseClass>::StreamedDebugLevel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DebugLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DebugLevel(::grpc::ServerContext* /*context*/, const ::lnrpc::DebugLevelRequest* /*request*/, ::lnrpc::DebugLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDebugLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::DebugLevelRequest,::lnrpc::DebugLevelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FeeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FeeReport() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::FeeReportRequest, ::lnrpc::FeeReportResponse>(std::bind(&WithStreamedUnaryMethod_FeeReport<BaseClass>::StreamedFeeReport, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FeeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FeeReport(::grpc::ServerContext* /*context*/, const ::lnrpc::FeeReportRequest* /*request*/, ::lnrpc::FeeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFeeReport(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::FeeReportRequest,::lnrpc::FeeReportResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateChannelPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateChannelPolicy() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::PolicyUpdateRequest, ::lnrpc::PolicyUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateChannelPolicy<BaseClass>::StreamedUpdateChannelPolicy, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateChannelPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateChannelPolicy(::grpc::ServerContext* /*context*/, const ::lnrpc::PolicyUpdateRequest* /*request*/, ::lnrpc::PolicyUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateChannelPolicy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::PolicyUpdateRequest,::lnrpc::PolicyUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ForwardingHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ForwardingHistory() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ForwardingHistoryRequest, ::lnrpc::ForwardingHistoryResponse>(std::bind(&WithStreamedUnaryMethod_ForwardingHistory<BaseClass>::StreamedForwardingHistory, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ForwardingHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ForwardingHistory(::grpc::ServerContext* /*context*/, const ::lnrpc::ForwardingHistoryRequest* /*request*/, ::lnrpc::ForwardingHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedForwardingHistory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ForwardingHistoryRequest,::lnrpc::ForwardingHistoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExportChannelBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExportChannelBackup() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ExportChannelBackupRequest, ::lnrpc::ChannelBackup>(std::bind(&WithStreamedUnaryMethod_ExportChannelBackup<BaseClass>::StreamedExportChannelBackup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ExportChannelBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExportChannelBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ExportChannelBackupRequest* /*request*/, ::lnrpc::ChannelBackup* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExportChannelBackup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ExportChannelBackupRequest,::lnrpc::ChannelBackup>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExportAllChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExportAllChannelBackups() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ChanBackupExportRequest, ::lnrpc::ChanBackupSnapshot>(std::bind(&WithStreamedUnaryMethod_ExportAllChannelBackups<BaseClass>::StreamedExportAllChannelBackups, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ExportAllChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExportAllChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupExportRequest* /*request*/, ::lnrpc::ChanBackupSnapshot* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExportAllChannelBackups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ChanBackupExportRequest,::lnrpc::ChanBackupSnapshot>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VerifyChanBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VerifyChanBackup() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ChanBackupSnapshot, ::lnrpc::VerifyChanBackupResponse>(std::bind(&WithStreamedUnaryMethod_VerifyChanBackup<BaseClass>::StreamedVerifyChanBackup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VerifyChanBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VerifyChanBackup(::grpc::ServerContext* /*context*/, const ::lnrpc::ChanBackupSnapshot* /*request*/, ::lnrpc::VerifyChanBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVerifyChanBackup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ChanBackupSnapshot,::lnrpc::VerifyChanBackupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RestoreChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RestoreChannelBackups() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::RestoreChanBackupRequest, ::lnrpc::RestoreBackupResponse>(std::bind(&WithStreamedUnaryMethod_RestoreChannelBackups<BaseClass>::StreamedRestoreChannelBackups, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RestoreChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RestoreChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::RestoreChanBackupRequest* /*request*/, ::lnrpc::RestoreBackupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRestoreChannelBackups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::RestoreChanBackupRequest,::lnrpc::RestoreBackupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BakeMacaroon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BakeMacaroon() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::BakeMacaroonRequest, ::lnrpc::BakeMacaroonResponse>(std::bind(&WithStreamedUnaryMethod_BakeMacaroon<BaseClass>::StreamedBakeMacaroon, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_BakeMacaroon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BakeMacaroon(::grpc::ServerContext* /*context*/, const ::lnrpc::BakeMacaroonRequest* /*request*/, ::lnrpc::BakeMacaroonResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBakeMacaroon(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::BakeMacaroonRequest,::lnrpc::BakeMacaroonResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListMacaroonIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListMacaroonIDs() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ListMacaroonIDsRequest, ::lnrpc::ListMacaroonIDsResponse>(std::bind(&WithStreamedUnaryMethod_ListMacaroonIDs<BaseClass>::StreamedListMacaroonIDs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListMacaroonIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListMacaroonIDs(::grpc::ServerContext* /*context*/, const ::lnrpc::ListMacaroonIDsRequest* /*request*/, ::lnrpc::ListMacaroonIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListMacaroonIDs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ListMacaroonIDsRequest,::lnrpc::ListMacaroonIDsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteMacaroonID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteMacaroonID() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::DeleteMacaroonIDRequest, ::lnrpc::DeleteMacaroonIDResponse>(std::bind(&WithStreamedUnaryMethod_DeleteMacaroonID<BaseClass>::StreamedDeleteMacaroonID, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteMacaroonID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteMacaroonID(::grpc::ServerContext* /*context*/, const ::lnrpc::DeleteMacaroonIDRequest* /*request*/, ::lnrpc::DeleteMacaroonIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteMacaroonID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::DeleteMacaroonIDRequest,::lnrpc::DeleteMacaroonIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPermissions() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler< ::lnrpc::ListPermissionsRequest, ::lnrpc::ListPermissionsResponse>(std::bind(&WithStreamedUnaryMethod_ListPermissions<BaseClass>::StreamedListPermissions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListPermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPermissions(::grpc::ServerContext* /*context*/, const ::lnrpc::ListPermissionsRequest* /*request*/, ::lnrpc::ListPermissionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPermissions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lnrpc::ListPermissionsRequest,::lnrpc::ListPermissionsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_WalletBalance<WithStreamedUnaryMethod_ChannelBalance<WithStreamedUnaryMethod_GetTransactions<WithStreamedUnaryMethod_EstimateFee<WithStreamedUnaryMethod_SendCoins<WithStreamedUnaryMethod_ListUnspent<WithStreamedUnaryMethod_SendMany<WithStreamedUnaryMethod_NewAddress<WithStreamedUnaryMethod_SignMessage<WithStreamedUnaryMethod_VerifyMessage<WithStreamedUnaryMethod_ConnectPeer<WithStreamedUnaryMethod_DisconnectPeer<WithStreamedUnaryMethod_ListPeers<WithStreamedUnaryMethod_GetInfo<WithStreamedUnaryMethod_GetRecoveryInfo<WithStreamedUnaryMethod_PendingChannels<WithStreamedUnaryMethod_ListChannels<WithStreamedUnaryMethod_ClosedChannels<WithStreamedUnaryMethod_OpenChannelSync<WithStreamedUnaryMethod_FundingStateStep<WithStreamedUnaryMethod_AbandonChannel<WithStreamedUnaryMethod_SendPaymentSync<WithStreamedUnaryMethod_SendToRouteSync<WithStreamedUnaryMethod_AddInvoice<WithStreamedUnaryMethod_ListInvoices<WithStreamedUnaryMethod_LookupInvoice<WithStreamedUnaryMethod_DecodePayReq<WithStreamedUnaryMethod_ListPayments<WithStreamedUnaryMethod_DeleteAllPayments<WithStreamedUnaryMethod_DescribeGraph<WithStreamedUnaryMethod_GetNodeMetrics<WithStreamedUnaryMethod_GetChanInfo<WithStreamedUnaryMethod_GetNodeInfo<WithStreamedUnaryMethod_QueryRoutes<WithStreamedUnaryMethod_GetNetworkInfo<WithStreamedUnaryMethod_StopDaemon<WithStreamedUnaryMethod_DebugLevel<WithStreamedUnaryMethod_FeeReport<WithStreamedUnaryMethod_UpdateChannelPolicy<WithStreamedUnaryMethod_ForwardingHistory<WithStreamedUnaryMethod_ExportChannelBackup<WithStreamedUnaryMethod_ExportAllChannelBackups<WithStreamedUnaryMethod_VerifyChanBackup<WithStreamedUnaryMethod_RestoreChannelBackups<WithStreamedUnaryMethod_BakeMacaroon<WithStreamedUnaryMethod_ListMacaroonIDs<WithStreamedUnaryMethod_DeleteMacaroonID<WithStreamedUnaryMethod_ListPermissions<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeTransactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeTransactions() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::GetTransactionsRequest, ::lnrpc::Transaction>(std::bind(&WithSplitStreamingMethod_SubscribeTransactions<BaseClass>::StreamedSubscribeTransactions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeTransactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeTransactions(::grpc::ServerContext* /*context*/, const ::lnrpc::GetTransactionsRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::Transaction>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeTransactions(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::GetTransactionsRequest,::lnrpc::Transaction>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribePeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribePeerEvents() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::PeerEventSubscription, ::lnrpc::PeerEvent>(std::bind(&WithSplitStreamingMethod_SubscribePeerEvents<BaseClass>::StreamedSubscribePeerEvents, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribePeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribePeerEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::PeerEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribePeerEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::PeerEventSubscription,::lnrpc::PeerEvent>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeChannelEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeChannelEvents() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::ChannelEventSubscription, ::lnrpc::ChannelEventUpdate>(std::bind(&WithSplitStreamingMethod_SubscribeChannelEvents<BaseClass>::StreamedSubscribeChannelEvents, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeChannelEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeChannelEvents(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelEventSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChannelEventUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeChannelEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::ChannelEventSubscription,::lnrpc::ChannelEventUpdate>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_OpenChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_OpenChannel() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::OpenChannelRequest, ::lnrpc::OpenStatusUpdate>(std::bind(&WithSplitStreamingMethod_OpenChannel<BaseClass>::StreamedOpenChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_OpenChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OpenChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::OpenChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::OpenStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOpenChannel(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::OpenChannelRequest,::lnrpc::OpenStatusUpdate>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_CloseChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_CloseChannel() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::CloseChannelRequest, ::lnrpc::CloseStatusUpdate>(std::bind(&WithSplitStreamingMethod_CloseChannel<BaseClass>::StreamedCloseChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_CloseChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CloseChannel(::grpc::ServerContext* /*context*/, const ::lnrpc::CloseChannelRequest* /*request*/, ::grpc::ServerWriter< ::lnrpc::CloseStatusUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedCloseChannel(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::CloseChannelRequest,::lnrpc::CloseStatusUpdate>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeInvoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeInvoices() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::InvoiceSubscription, ::lnrpc::Invoice>(std::bind(&WithSplitStreamingMethod_SubscribeInvoices<BaseClass>::StreamedSubscribeInvoices, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeInvoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeInvoices(::grpc::ServerContext* /*context*/, const ::lnrpc::InvoiceSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::Invoice>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeInvoices(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::InvoiceSubscription,::lnrpc::Invoice>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeChannelGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeChannelGraph() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::GraphTopologySubscription, ::lnrpc::GraphTopologyUpdate>(std::bind(&WithSplitStreamingMethod_SubscribeChannelGraph<BaseClass>::StreamedSubscribeChannelGraph, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeChannelGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeChannelGraph(::grpc::ServerContext* /*context*/, const ::lnrpc::GraphTopologySubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::GraphTopologyUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeChannelGraph(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::GraphTopologySubscription,::lnrpc::GraphTopologyUpdate>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeChannelBackups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeChannelBackups() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::SplitServerStreamingHandler< ::lnrpc::ChannelBackupSubscription, ::lnrpc::ChanBackupSnapshot>(std::bind(&WithSplitStreamingMethod_SubscribeChannelBackups<BaseClass>::StreamedSubscribeChannelBackups, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeChannelBackups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeChannelBackups(::grpc::ServerContext* /*context*/, const ::lnrpc::ChannelBackupSubscription* /*request*/, ::grpc::ServerWriter< ::lnrpc::ChanBackupSnapshot>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeChannelBackups(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lnrpc::ChannelBackupSubscription,::lnrpc::ChanBackupSnapshot>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeTransactions<WithSplitStreamingMethod_SubscribePeerEvents<WithSplitStreamingMethod_SubscribeChannelEvents<WithSplitStreamingMethod_OpenChannel<WithSplitStreamingMethod_CloseChannel<WithSplitStreamingMethod_SubscribeInvoices<WithSplitStreamingMethod_SubscribeChannelGraph<WithSplitStreamingMethod_SubscribeChannelBackups<Service > > > > > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_WalletBalance<WithStreamedUnaryMethod_ChannelBalance<WithStreamedUnaryMethod_GetTransactions<WithStreamedUnaryMethod_EstimateFee<WithStreamedUnaryMethod_SendCoins<WithStreamedUnaryMethod_ListUnspent<WithSplitStreamingMethod_SubscribeTransactions<WithStreamedUnaryMethod_SendMany<WithStreamedUnaryMethod_NewAddress<WithStreamedUnaryMethod_SignMessage<WithStreamedUnaryMethod_VerifyMessage<WithStreamedUnaryMethod_ConnectPeer<WithStreamedUnaryMethod_DisconnectPeer<WithStreamedUnaryMethod_ListPeers<WithSplitStreamingMethod_SubscribePeerEvents<WithStreamedUnaryMethod_GetInfo<WithStreamedUnaryMethod_GetRecoveryInfo<WithStreamedUnaryMethod_PendingChannels<WithStreamedUnaryMethod_ListChannels<WithSplitStreamingMethod_SubscribeChannelEvents<WithStreamedUnaryMethod_ClosedChannels<WithStreamedUnaryMethod_OpenChannelSync<WithSplitStreamingMethod_OpenChannel<WithStreamedUnaryMethod_FundingStateStep<WithSplitStreamingMethod_CloseChannel<WithStreamedUnaryMethod_AbandonChannel<WithStreamedUnaryMethod_SendPaymentSync<WithStreamedUnaryMethod_SendToRouteSync<WithStreamedUnaryMethod_AddInvoice<WithStreamedUnaryMethod_ListInvoices<WithStreamedUnaryMethod_LookupInvoice<WithSplitStreamingMethod_SubscribeInvoices<WithStreamedUnaryMethod_DecodePayReq<WithStreamedUnaryMethod_ListPayments<WithStreamedUnaryMethod_DeleteAllPayments<WithStreamedUnaryMethod_DescribeGraph<WithStreamedUnaryMethod_GetNodeMetrics<WithStreamedUnaryMethod_GetChanInfo<WithStreamedUnaryMethod_GetNodeInfo<WithStreamedUnaryMethod_QueryRoutes<WithStreamedUnaryMethod_GetNetworkInfo<WithStreamedUnaryMethod_StopDaemon<WithSplitStreamingMethod_SubscribeChannelGraph<WithStreamedUnaryMethod_DebugLevel<WithStreamedUnaryMethod_FeeReport<WithStreamedUnaryMethod_UpdateChannelPolicy<WithStreamedUnaryMethod_ForwardingHistory<WithStreamedUnaryMethod_ExportChannelBackup<WithStreamedUnaryMethod_ExportAllChannelBackups<WithStreamedUnaryMethod_VerifyChanBackup<WithStreamedUnaryMethod_RestoreChannelBackups<WithSplitStreamingMethod_SubscribeChannelBackups<WithStreamedUnaryMethod_BakeMacaroon<WithStreamedUnaryMethod_ListMacaroonIDs<WithStreamedUnaryMethod_DeleteMacaroonID<WithStreamedUnaryMethod_ListPermissions<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace lnrpc


#endif  // GRPC_rpc_2eproto__INCLUDED
