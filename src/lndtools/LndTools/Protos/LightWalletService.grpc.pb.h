// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: LightWalletService.proto
#ifndef GRPC_LightWalletService_2eproto__INCLUDED
#define GRPC_LightWalletService_2eproto__INCLUDED

#include "LightWalletService.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace lightwalletrpc {

class LightWalletService final {
 public:
  static constexpr char const* service_full_name() {
    return "lightwalletrpc.LightWalletService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // *
    // GetBestBlock returns the highest block known to lightwallet.
    virtual ::grpc::Status GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::lightwalletrpc::GetChainInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetChainInfoResponse>> AsyncGetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetChainInfoResponse>>(AsyncGetChainInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetChainInfoResponse>> PrepareAsyncGetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetChainInfoResponse>>(PrepareAsyncGetChainInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::lightwalletrpc::BlockHash* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHash>> AsyncGetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHash>>(AsyncGetBlockHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHash>> PrepareAsyncGetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHash>>(PrepareAsyncGetBlockHashRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::GetBlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetBlockResponse>> AsyncGetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetBlockResponse>>(AsyncGetBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetBlockResponse>> PrepareAsyncGetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetBlockResponse>>(PrepareAsyncGetBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::HexEncoded* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>> AsyncGetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>>(AsyncGetBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>> PrepareAsyncGetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>>(PrepareAsyncGetBlockHeaderRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::BlockHeader* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHeader>> AsyncGetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHeader>>(AsyncGetBlockHeaderVerboseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHeader>> PrepareAsyncGetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHeader>>(PrepareAsyncGetBlockHeaderVerboseRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::FilterBlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::FilterBlockResponse>> AsyncGetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::FilterBlockResponse>>(AsyncGetFilterBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::FilterBlockResponse>> PrepareAsyncGetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::FilterBlockResponse>>(PrepareAsyncGetFilterBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::BlockFilter* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockFilter>> AsyncGetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockFilter>>(AsyncGetBlockFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockFilter>> PrepareAsyncGetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockFilter>>(PrepareAsyncGetBlockFilterRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::TxOut* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxOut>> AsyncGetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxOut>>(AsyncGetTxOutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxOut>> PrepareAsyncGetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxOut>>(PrepareAsyncGetTxOutRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::lightwalletrpc::GetRawTransactionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>> AsyncGetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>>(AsyncGetRawTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>> PrepareAsyncGetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>>(PrepareAsyncGetRawTransactionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::lightwalletrpc::GetRawTxByIndexResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTxByIndexResponse>> AsyncGetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTxByIndexResponse>>(AsyncGetRawTxByIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTxByIndexResponse>> PrepareAsyncGetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTxByIndexResponse>>(PrepareAsyncGetRawTxByIndexRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::lightwalletrpc::GetLastAddressResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetLastAddressResponse>> AsyncGetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetLastAddressResponse>>(AsyncGetLastAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetLastAddressResponse>> PrepareAsyncGetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetLastAddressResponse>>(PrepareAsyncGetLastAddressRaw(context, request, cq));
    }
    virtual ::grpc::Status ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::lightwalletrpc::ListUtxoResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::ListUtxoResult>> AsyncListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::ListUtxoResult>>(AsyncListUtxosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::ListUtxoResult>> PrepareAsyncListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::ListUtxoResult>>(PrepareAsyncListUtxosRaw(context, request, cq));
    }
    virtual ::grpc::Status DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::lightwalletrpc::HexEncoded* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>> AsyncDumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>>(AsyncDumpPrivKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>> PrepareAsyncDumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>>(PrepareAsyncDumpPrivKeyRaw(context, request, cq));
    }
    virtual ::grpc::Status SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::lightwalletrpc::TxID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxID>> AsyncSendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxID>>(AsyncSendRawTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxID>> PrepareAsyncSendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxID>>(PrepareAsyncSendRawTransactionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::lightwalletrpc::GetConfirmedBalanceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetConfirmedBalanceResponse>> AsyncGetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetConfirmedBalanceResponse>>(AsyncGetConfirmedBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetConfirmedBalanceResponse>> PrepareAsyncGetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetConfirmedBalanceResponse>>(PrepareAsyncGetConfirmedBalanceRaw(context, request, cq));
    }
    virtual ::grpc::Status Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::lightwalletrpc::GenerateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GenerateResponse>> AsyncGenerate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GenerateResponse>>(AsyncGenerateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GenerateResponse>> PrepareAsyncGenerate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GenerateResponse>>(PrepareAsyncGenerateRaw(context, request, cq));
    }
    virtual ::grpc::Status LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::lightwalletrpc::LoadCacheResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::LoadCacheResponse>> AsyncLoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::LoadCacheResponse>>(AsyncLoadSecondLayerCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::LoadCacheResponse>> PrepareAsyncLoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::LoadCacheResponse>>(PrepareAsyncLoadSecondLayerCacheRaw(context, request, cq));
    }
    virtual ::grpc::Status FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::lightwalletrpc::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>> AsyncFreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>>(AsyncFreeSecondLayerCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>> PrepareAsyncFreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>>(PrepareAsyncFreeSecondLayerCacheRaw(context, request, cq));
    }
    virtual ::grpc::Status EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::lightwalletrpc::EstimateNetworkFeeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::EstimateNetworkFeeResponse>> AsyncEstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::EstimateNetworkFeeResponse>>(AsyncEstimateNetworkFeeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::EstimateNetworkFeeResponse>> PrepareAsyncEstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::EstimateNetworkFeeResponse>>(PrepareAsyncEstimateNetworkFeeRaw(context, request, cq));
    }
    virtual ::grpc::Status LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>> AsyncLockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>>(AsyncLockOutpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>> PrepareAsyncLockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>>(PrepareAsyncLockOutpointRaw(context, request, cq));
    }
    virtual ::grpc::Status UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>> AsyncUnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>>(AsyncUnlockOutpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>> PrepareAsyncUnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>>(PrepareAsyncUnlockOutpointRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::GetRawTransactionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>> AsyncGetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>>(AsyncGetSpendingDetailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>> PrepareAsyncGetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>>(PrepareAsyncGetSpendingDetailsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // *
      // GetBestBlock returns the highest block known to lightwallet.
      virtual void GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetChainInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetChainInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChainInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetChainInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHash(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHash* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHash(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHash* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHash(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHash* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetBlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHeader* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHeader* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHeader* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFilterBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::FilterBlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetFilterBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetFilterBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockFilter(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockFilter* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockFilter(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockFilter* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockFilter(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockFilter* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTxOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxOut* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTxOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxOut* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTxOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxOut* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRawTxByIndex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRawTxByIndex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRawTxByIndex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLastAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetLastAddressResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLastAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLastAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListUtxos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::ListUtxoResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListUtxos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListUtxos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DumpPrivKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DumpPrivKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DumpPrivKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConfirmedBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConfirmedBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConfirmedBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Generate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GenerateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Generate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Generate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::LoadCacheResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LoadSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LoadSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FreeSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FreeSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FreeSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EstimateNetworkFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EstimateNetworkFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EstimateNetworkFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnlockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSpendingDetails(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSpendingDetails(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSpendingDetails(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetChainInfoResponse>* AsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetChainInfoResponse>* PrepareAsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHash>* AsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHash>* PrepareAsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetBlockResponse>* AsyncGetBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetBlockResponse>* PrepareAsyncGetBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>* AsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>* PrepareAsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHeader>* AsyncGetBlockHeaderVerboseRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockHeader>* PrepareAsyncGetBlockHeaderVerboseRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::FilterBlockResponse>* AsyncGetFilterBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::FilterBlockResponse>* PrepareAsyncGetFilterBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockFilter>* AsyncGetBlockFilterRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::BlockFilter>* PrepareAsyncGetBlockFilterRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxOut>* AsyncGetTxOutRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxOut>* PrepareAsyncGetTxOutRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>* AsyncGetRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>* PrepareAsyncGetRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTxByIndexResponse>* AsyncGetRawTxByIndexRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTxByIndexResponse>* PrepareAsyncGetRawTxByIndexRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetLastAddressResponse>* AsyncGetLastAddressRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetLastAddressResponse>* PrepareAsyncGetLastAddressRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::ListUtxoResult>* AsyncListUtxosRaw(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::ListUtxoResult>* PrepareAsyncListUtxosRaw(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>* AsyncDumpPrivKeyRaw(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::HexEncoded>* PrepareAsyncDumpPrivKeyRaw(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxID>* AsyncSendRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::TxID>* PrepareAsyncSendRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetConfirmedBalanceResponse>* AsyncGetConfirmedBalanceRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetConfirmedBalanceResponse>* PrepareAsyncGetConfirmedBalanceRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GenerateResponse>* AsyncGenerateRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GenerateResponse>* PrepareAsyncGenerateRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::LoadCacheResponse>* AsyncLoadSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::LoadCacheResponse>* PrepareAsyncLoadSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>* AsyncFreeSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>* PrepareAsyncFreeSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::EstimateNetworkFeeResponse>* AsyncEstimateNetworkFeeRaw(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::EstimateNetworkFeeResponse>* PrepareAsyncEstimateNetworkFeeRaw(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>* AsyncLockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>* PrepareAsyncLockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>* AsyncUnlockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::Empty>* PrepareAsyncUnlockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>* AsyncGetSpendingDetailsRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lightwalletrpc::GetRawTransactionResponse>* PrepareAsyncGetSpendingDetailsRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::lightwalletrpc::GetChainInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetChainInfoResponse>> AsyncGetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetChainInfoResponse>>(AsyncGetChainInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetChainInfoResponse>> PrepareAsyncGetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetChainInfoResponse>>(PrepareAsyncGetChainInfoRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::lightwalletrpc::BlockHash* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHash>> AsyncGetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHash>>(AsyncGetBlockHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHash>> PrepareAsyncGetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHash>>(PrepareAsyncGetBlockHashRaw(context, request, cq));
    }
    ::grpc::Status GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::GetBlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetBlockResponse>> AsyncGetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetBlockResponse>>(AsyncGetBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetBlockResponse>> PrepareAsyncGetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetBlockResponse>>(PrepareAsyncGetBlockRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::HexEncoded* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>> AsyncGetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>>(AsyncGetBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>> PrepareAsyncGetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>>(PrepareAsyncGetBlockHeaderRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::BlockHeader* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHeader>> AsyncGetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHeader>>(AsyncGetBlockHeaderVerboseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHeader>> PrepareAsyncGetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHeader>>(PrepareAsyncGetBlockHeaderVerboseRaw(context, request, cq));
    }
    ::grpc::Status GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::FilterBlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::FilterBlockResponse>> AsyncGetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::FilterBlockResponse>>(AsyncGetFilterBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::FilterBlockResponse>> PrepareAsyncGetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::FilterBlockResponse>>(PrepareAsyncGetFilterBlockRaw(context, request, cq));
    }
    ::grpc::Status GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::lightwalletrpc::BlockFilter* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockFilter>> AsyncGetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockFilter>>(AsyncGetBlockFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockFilter>> PrepareAsyncGetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockFilter>>(PrepareAsyncGetBlockFilterRaw(context, request, cq));
    }
    ::grpc::Status GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::TxOut* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxOut>> AsyncGetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxOut>>(AsyncGetTxOutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxOut>> PrepareAsyncGetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxOut>>(PrepareAsyncGetTxOutRaw(context, request, cq));
    }
    ::grpc::Status GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::lightwalletrpc::GetRawTransactionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>> AsyncGetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>>(AsyncGetRawTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>> PrepareAsyncGetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>>(PrepareAsyncGetRawTransactionRaw(context, request, cq));
    }
    ::grpc::Status GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::lightwalletrpc::GetRawTxByIndexResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTxByIndexResponse>> AsyncGetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTxByIndexResponse>>(AsyncGetRawTxByIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTxByIndexResponse>> PrepareAsyncGetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTxByIndexResponse>>(PrepareAsyncGetRawTxByIndexRaw(context, request, cq));
    }
    ::grpc::Status GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::lightwalletrpc::GetLastAddressResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetLastAddressResponse>> AsyncGetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetLastAddressResponse>>(AsyncGetLastAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetLastAddressResponse>> PrepareAsyncGetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetLastAddressResponse>>(PrepareAsyncGetLastAddressRaw(context, request, cq));
    }
    ::grpc::Status ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::lightwalletrpc::ListUtxoResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::ListUtxoResult>> AsyncListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::ListUtxoResult>>(AsyncListUtxosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::ListUtxoResult>> PrepareAsyncListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::ListUtxoResult>>(PrepareAsyncListUtxosRaw(context, request, cq));
    }
    ::grpc::Status DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::lightwalletrpc::HexEncoded* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>> AsyncDumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>>(AsyncDumpPrivKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>> PrepareAsyncDumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>>(PrepareAsyncDumpPrivKeyRaw(context, request, cq));
    }
    ::grpc::Status SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::lightwalletrpc::TxID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxID>> AsyncSendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxID>>(AsyncSendRawTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxID>> PrepareAsyncSendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxID>>(PrepareAsyncSendRawTransactionRaw(context, request, cq));
    }
    ::grpc::Status GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::lightwalletrpc::GetConfirmedBalanceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetConfirmedBalanceResponse>> AsyncGetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetConfirmedBalanceResponse>>(AsyncGetConfirmedBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetConfirmedBalanceResponse>> PrepareAsyncGetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetConfirmedBalanceResponse>>(PrepareAsyncGetConfirmedBalanceRaw(context, request, cq));
    }
    ::grpc::Status Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::lightwalletrpc::GenerateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GenerateResponse>> AsyncGenerate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GenerateResponse>>(AsyncGenerateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GenerateResponse>> PrepareAsyncGenerate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GenerateResponse>>(PrepareAsyncGenerateRaw(context, request, cq));
    }
    ::grpc::Status LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::lightwalletrpc::LoadCacheResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::LoadCacheResponse>> AsyncLoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::LoadCacheResponse>>(AsyncLoadSecondLayerCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::LoadCacheResponse>> PrepareAsyncLoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::LoadCacheResponse>>(PrepareAsyncLoadSecondLayerCacheRaw(context, request, cq));
    }
    ::grpc::Status FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::lightwalletrpc::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>> AsyncFreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>>(AsyncFreeSecondLayerCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>> PrepareAsyncFreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>>(PrepareAsyncFreeSecondLayerCacheRaw(context, request, cq));
    }
    ::grpc::Status EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::lightwalletrpc::EstimateNetworkFeeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::EstimateNetworkFeeResponse>> AsyncEstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::EstimateNetworkFeeResponse>>(AsyncEstimateNetworkFeeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::EstimateNetworkFeeResponse>> PrepareAsyncEstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::EstimateNetworkFeeResponse>>(PrepareAsyncEstimateNetworkFeeRaw(context, request, cq));
    }
    ::grpc::Status LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>> AsyncLockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>>(AsyncLockOutpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>> PrepareAsyncLockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>>(PrepareAsyncLockOutpointRaw(context, request, cq));
    }
    ::grpc::Status UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>> AsyncUnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>>(AsyncUnlockOutpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>> PrepareAsyncUnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>>(PrepareAsyncUnlockOutpointRaw(context, request, cq));
    }
    ::grpc::Status GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::lightwalletrpc::GetRawTransactionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>> AsyncGetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>>(AsyncGetSpendingDetailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>> PrepareAsyncGetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>>(PrepareAsyncGetSpendingDetailsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetChainInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetChainInfoResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetChainInfo(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChainInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetChainInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetChainInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHash(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHash* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHash(::grpc::ClientContext* context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHash(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHash* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHash(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHash* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetBlockResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHeader(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHeader* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHeader* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHeaderVerbose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockHeader* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response, std::function<void(::grpc::Status)>) override;
      void GetFilterBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::FilterBlockResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetFilterBlock(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetFilterBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetFilterBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::FilterBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response, std::function<void(::grpc::Status)>) override;
      void GetBlockFilter(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockFilter* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockFilter(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockFilter(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockFilter* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockFilter(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::BlockFilter* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response, std::function<void(::grpc::Status)>) override;
      void GetTxOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxOut* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTxOut(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTxOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxOut* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTxOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxOut* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRawTxByIndex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRawTxByIndex(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRawTxByIndex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRawTxByIndex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTxByIndexResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLastAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetLastAddressResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLastAddress(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLastAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLastAddress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetLastAddressResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response, std::function<void(::grpc::Status)>) override;
      void ListUtxos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::ListUtxoResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListUtxos(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListUtxos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListUtxos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::ListUtxoResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) override;
      void DumpPrivKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DumpPrivKey(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DumpPrivKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DumpPrivKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::HexEncoded* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response, std::function<void(::grpc::Status)>) override;
      void SendRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendRawTransaction(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendRawTransaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::TxID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConfirmedBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConfirmedBalance(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConfirmedBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConfirmedBalance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response, std::function<void(::grpc::Status)>) override;
      void Generate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GenerateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Generate(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Generate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Generate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GenerateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response, std::function<void(::grpc::Status)>) override;
      void LoadSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::LoadCacheResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LoadSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LoadSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LoadSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::LoadCacheResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) override;
      void FreeSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FreeSecondLayerCache(::grpc::ClientContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FreeSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FreeSecondLayerCache(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, std::function<void(::grpc::Status)>) override;
      void EstimateNetworkFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EstimateNetworkFee(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EstimateNetworkFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EstimateNetworkFee(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) override;
      void LockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) override;
      void UnlockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlockOutpoint(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlockOutpoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSpendingDetails(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSpendingDetails(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSpendingDetails(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSpendingDetails(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightwalletrpc::GetRawTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetChainInfoResponse>* AsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetChainInfoResponse>* PrepareAsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHash>* AsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHash>* PrepareAsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Height& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetBlockResponse>* AsyncGetBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetBlockResponse>* PrepareAsyncGetBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>* AsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>* PrepareAsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHeader>* AsyncGetBlockHeaderVerboseRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockHeader>* PrepareAsyncGetBlockHeaderVerboseRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::FilterBlockResponse>* AsyncGetFilterBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::FilterBlockResponse>* PrepareAsyncGetFilterBlockRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockFilter>* AsyncGetBlockFilterRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::BlockFilter>* PrepareAsyncGetBlockFilterRaw(::grpc::ClientContext* context, const ::lightwalletrpc::BlockHash& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxOut>* AsyncGetTxOutRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxOut>* PrepareAsyncGetTxOutRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>* AsyncGetRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>* PrepareAsyncGetRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::TxID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTxByIndexResponse>* AsyncGetRawTxByIndexRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTxByIndexResponse>* PrepareAsyncGetRawTxByIndexRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetLastAddressResponse>* AsyncGetLastAddressRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetLastAddressResponse>* PrepareAsyncGetLastAddressRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetLastAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::ListUtxoResult>* AsyncListUtxosRaw(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::ListUtxoResult>* PrepareAsyncListUtxosRaw(::grpc::ClientContext* context, const ::lightwalletrpc::ListUtxosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>* AsyncDumpPrivKeyRaw(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::HexEncoded>* PrepareAsyncDumpPrivKeyRaw(::grpc::ClientContext* context, const ::lightwalletrpc::DumpPrivKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxID>* AsyncSendRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::TxID>* PrepareAsyncSendRawTransactionRaw(::grpc::ClientContext* context, const ::lightwalletrpc::HexEncoded& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetConfirmedBalanceResponse>* AsyncGetConfirmedBalanceRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetConfirmedBalanceResponse>* PrepareAsyncGetConfirmedBalanceRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GenerateResponse>* AsyncGenerateRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GenerateResponse>* PrepareAsyncGenerateRaw(::grpc::ClientContext* context, const ::lightwalletrpc::GenerateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::LoadCacheResponse>* AsyncLoadSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::LoadCacheResponse>* PrepareAsyncLoadSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::LoadCacheRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>* AsyncFreeSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>* PrepareAsyncFreeSecondLayerCacheRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::EstimateNetworkFeeResponse>* AsyncEstimateNetworkFeeRaw(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::EstimateNetworkFeeResponse>* PrepareAsyncEstimateNetworkFeeRaw(::grpc::ClientContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>* AsyncLockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>* PrepareAsyncLockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>* AsyncUnlockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::Empty>* PrepareAsyncUnlockOutpointRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>* AsyncGetSpendingDetailsRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lightwalletrpc::GetRawTransactionResponse>* PrepareAsyncGetSpendingDetailsRaw(::grpc::ClientContext* context, const ::lightwalletrpc::Outpoint& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetChainInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHash_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeader_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeaderVerbose_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFilterBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockFilter_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTxOut_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRawTransaction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRawTxByIndex_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLastAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_ListUtxos_;
    const ::grpc::internal::RpcMethod rpcmethod_DumpPrivKey_;
    const ::grpc::internal::RpcMethod rpcmethod_SendRawTransaction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConfirmedBalance_;
    const ::grpc::internal::RpcMethod rpcmethod_Generate_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadSecondLayerCache_;
    const ::grpc::internal::RpcMethod rpcmethod_FreeSecondLayerCache_;
    const ::grpc::internal::RpcMethod rpcmethod_EstimateNetworkFee_;
    const ::grpc::internal::RpcMethod rpcmethod_LockOutpoint_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlockOutpoint_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSpendingDetails_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // *
    // GetBestBlock returns the highest block known to lightwallet.
    virtual ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response);
    virtual ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response);
    virtual ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response);
    virtual ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response);
    virtual ::grpc::Status GetBlockHeaderVerbose(::grpc::ServerContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response);
    virtual ::grpc::Status GetFilterBlock(::grpc::ServerContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response);
    virtual ::grpc::Status GetBlockFilter(::grpc::ServerContext* context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response);
    virtual ::grpc::Status GetTxOut(::grpc::ServerContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response);
    virtual ::grpc::Status GetRawTransaction(::grpc::ServerContext* context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response);
    virtual ::grpc::Status GetRawTxByIndex(::grpc::ServerContext* context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response);
    virtual ::grpc::Status GetLastAddress(::grpc::ServerContext* context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response);
    virtual ::grpc::Status ListUtxos(::grpc::ServerContext* context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response);
    virtual ::grpc::Status DumpPrivKey(::grpc::ServerContext* context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response);
    virtual ::grpc::Status SendRawTransaction(::grpc::ServerContext* context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response);
    virtual ::grpc::Status GetConfirmedBalance(::grpc::ServerContext* context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response);
    virtual ::grpc::Status Generate(::grpc::ServerContext* context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response);
    virtual ::grpc::Status LoadSecondLayerCache(::grpc::ServerContext* context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response);
    virtual ::grpc::Status FreeSecondLayerCache(::grpc::ServerContext* context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response);
    virtual ::grpc::Status EstimateNetworkFee(::grpc::ServerContext* context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response);
    virtual ::grpc::Status LockOutpoint(::grpc::ServerContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response);
    virtual ::grpc::Status UnlockOutpoint(::grpc::ServerContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response);
    virtual ::grpc::Status GetSpendingDetails(::grpc::ServerContext* context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChainInfo(::grpc::ServerContext* context, ::lightwalletrpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GetChainInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHash(::grpc::ServerContext* context, ::lightwalletrpc::Height* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::BlockHash>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlock() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlock(::grpc::ServerContext* context, ::lightwalletrpc::BlockHash* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GetBlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeader(::grpc::ServerContext* context, ::lightwalletrpc::BlockHash* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::HexEncoded>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeaderVerbose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeaderVerbose() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetBlockHeaderVerbose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderVerbose(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderVerbose(::grpc::ServerContext* context, ::lightwalletrpc::BlockHash* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::BlockHeader>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFilterBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFilterBlock() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetFilterBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFilterBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFilterBlock(::grpc::ServerContext* context, ::lightwalletrpc::BlockHash* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::FilterBlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockFilter() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetBlockFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockFilter(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockFilter(::grpc::ServerContext* context, ::lightwalletrpc::BlockHash* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::BlockFilter>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTxOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTxOut() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetTxOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxOut(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTxOut(::grpc::ServerContext* context, ::lightwalletrpc::Outpoint* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::TxOut>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRawTransaction() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRawTransaction(::grpc::ServerContext* context, ::lightwalletrpc::TxID* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GetRawTransactionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRawTxByIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRawTxByIndex() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetRawTxByIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTxByIndex(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRawTxByIndex(::grpc::ServerContext* context, ::lightwalletrpc::GetRawTxByIndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GetRawTxByIndexResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLastAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLastAddress() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetLastAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastAddress(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLastAddress(::grpc::ServerContext* context, ::lightwalletrpc::GetLastAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GetLastAddressResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListUtxos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListUtxos() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ListUtxos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUtxos(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUtxos(::grpc::ServerContext* context, ::lightwalletrpc::ListUtxosRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::ListUtxoResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DumpPrivKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DumpPrivKey() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_DumpPrivKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpPrivKey(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDumpPrivKey(::grpc::ServerContext* context, ::lightwalletrpc::DumpPrivKeyRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::HexEncoded>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendRawTransaction() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_SendRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendRawTransaction(::grpc::ServerContext* context, ::lightwalletrpc::HexEncoded* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::TxID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConfirmedBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConfirmedBalance() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetConfirmedBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConfirmedBalance(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConfirmedBalance(::grpc::ServerContext* context, ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GetConfirmedBalanceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Generate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Generate() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Generate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Generate(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerate(::grpc::ServerContext* context, ::lightwalletrpc::GenerateRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GenerateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadSecondLayerCache() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_LoadSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadSecondLayerCache(::grpc::ServerContext* context, ::lightwalletrpc::LoadCacheRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::LoadCacheResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FreeSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FreeSecondLayerCache() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_FreeSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FreeSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFreeSecondLayerCache(::grpc::ServerContext* context, ::lightwalletrpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EstimateNetworkFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EstimateNetworkFee() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_EstimateNetworkFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateNetworkFee(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateNetworkFee(::grpc::ServerContext* context, ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::EstimateNetworkFeeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LockOutpoint() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_LockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLockOutpoint(::grpc::ServerContext* context, ::lightwalletrpc::Outpoint* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlockOutpoint() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_UnlockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlockOutpoint(::grpc::ServerContext* context, ::lightwalletrpc::Outpoint* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSpendingDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSpendingDetails() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetSpendingDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpendingDetails(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpendingDetails(::grpc::ServerContext* context, ::lightwalletrpc::Outpoint* request, ::grpc::ServerAsyncResponseWriter< ::lightwalletrpc::GetRawTransactionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetChainInfo<WithAsyncMethod_GetBlockHash<WithAsyncMethod_GetBlock<WithAsyncMethod_GetBlockHeader<WithAsyncMethod_GetBlockHeaderVerbose<WithAsyncMethod_GetFilterBlock<WithAsyncMethod_GetBlockFilter<WithAsyncMethod_GetTxOut<WithAsyncMethod_GetRawTransaction<WithAsyncMethod_GetRawTxByIndex<WithAsyncMethod_GetLastAddress<WithAsyncMethod_ListUtxos<WithAsyncMethod_DumpPrivKey<WithAsyncMethod_SendRawTransaction<WithAsyncMethod_GetConfirmedBalance<WithAsyncMethod_Generate<WithAsyncMethod_LoadSecondLayerCache<WithAsyncMethod_FreeSecondLayerCache<WithAsyncMethod_EstimateNetworkFee<WithAsyncMethod_LockOutpoint<WithAsyncMethod_UnlockOutpoint<WithAsyncMethod_GetSpendingDetails<Service > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetChainInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Empty, ::lightwalletrpc::GetChainInfoResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::GetChainInfoResponse* response) { return this->GetChainInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetChainInfo(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::Empty, ::lightwalletrpc::GetChainInfoResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Empty, ::lightwalletrpc::GetChainInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChainInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChainInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockHash() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Height, ::lightwalletrpc::BlockHash>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::Height* request, ::lightwalletrpc::BlockHash* response) { return this->GetBlockHash(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHash(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::Height, ::lightwalletrpc::BlockHash>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Height, ::lightwalletrpc::BlockHash>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHash(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHash(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::GetBlockResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::GetBlockResponse* response) { return this->GetBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlock(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::BlockHash, ::lightwalletrpc::GetBlockResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::GetBlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockHeader() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::HexEncoded>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::HexEncoded* response) { return this->GetBlockHeader(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeader(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::BlockHash, ::lightwalletrpc::HexEncoded>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::HexEncoded>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeader(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockHeaderVerbose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockHeaderVerbose() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockHeader>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockHeader* response) { return this->GetBlockHeaderVerbose(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeaderVerbose(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockHeader>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockHeader>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockHeaderVerbose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderVerbose(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderVerbose(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeaderVerbose(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetFilterBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetFilterBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::FilterBlockResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::FilterBlockResponse* response) { return this->GetFilterBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetFilterBlock(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::BlockHash, ::lightwalletrpc::FilterBlockResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::FilterBlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetFilterBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFilterBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetFilterBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetFilterBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockFilter>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::BlockHash* request, ::lightwalletrpc::BlockFilter* response) { return this->GetBlockFilter(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockFilter(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockFilter>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockFilter>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockFilter(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTxOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTxOut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::TxOut>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::TxOut* response) { return this->GetTxOut(context, request, response); }));}
    void SetMessageAllocatorFor_GetTxOut(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::Outpoint, ::lightwalletrpc::TxOut>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::TxOut>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTxOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxOut(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTxOut(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTxOut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRawTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::TxID, ::lightwalletrpc::GetRawTransactionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::TxID* request, ::lightwalletrpc::GetRawTransactionResponse* response) { return this->GetRawTransaction(context, request, response); }));}
    void SetMessageAllocatorFor_GetRawTransaction(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::TxID, ::lightwalletrpc::GetRawTransactionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::TxID, ::lightwalletrpc::GetRawTransactionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRawTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRawTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRawTxByIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRawTxByIndex() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GetRawTxByIndexRequest, ::lightwalletrpc::GetRawTxByIndexResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::GetRawTxByIndexRequest* request, ::lightwalletrpc::GetRawTxByIndexResponse* response) { return this->GetRawTxByIndex(context, request, response); }));}
    void SetMessageAllocatorFor_GetRawTxByIndex(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::GetRawTxByIndexRequest, ::lightwalletrpc::GetRawTxByIndexResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GetRawTxByIndexRequest, ::lightwalletrpc::GetRawTxByIndexResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRawTxByIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTxByIndex(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRawTxByIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRawTxByIndex(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLastAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLastAddress() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GetLastAddressRequest, ::lightwalletrpc::GetLastAddressResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::GetLastAddressRequest* request, ::lightwalletrpc::GetLastAddressResponse* response) { return this->GetLastAddress(context, request, response); }));}
    void SetMessageAllocatorFor_GetLastAddress(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::GetLastAddressRequest, ::lightwalletrpc::GetLastAddressResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GetLastAddressRequest, ::lightwalletrpc::GetLastAddressResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLastAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastAddress(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLastAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLastAddress(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListUtxos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListUtxos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::ListUtxosRequest, ::lightwalletrpc::ListUtxoResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::ListUtxosRequest* request, ::lightwalletrpc::ListUtxoResult* response) { return this->ListUtxos(context, request, response); }));}
    void SetMessageAllocatorFor_ListUtxos(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::ListUtxosRequest, ::lightwalletrpc::ListUtxoResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::ListUtxosRequest, ::lightwalletrpc::ListUtxoResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListUtxos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUtxos(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListUtxos(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListUtxos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DumpPrivKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DumpPrivKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::DumpPrivKeyRequest, ::lightwalletrpc::HexEncoded>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::DumpPrivKeyRequest* request, ::lightwalletrpc::HexEncoded* response) { return this->DumpPrivKey(context, request, response); }));}
    void SetMessageAllocatorFor_DumpPrivKey(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::DumpPrivKeyRequest, ::lightwalletrpc::HexEncoded>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::DumpPrivKeyRequest, ::lightwalletrpc::HexEncoded>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DumpPrivKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpPrivKey(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DumpPrivKey(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DumpPrivKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendRawTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::HexEncoded, ::lightwalletrpc::TxID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::HexEncoded* request, ::lightwalletrpc::TxID* response) { return this->SendRawTransaction(context, request, response); }));}
    void SetMessageAllocatorFor_SendRawTransaction(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::HexEncoded, ::lightwalletrpc::TxID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::HexEncoded, ::lightwalletrpc::TxID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendRawTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendRawTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetConfirmedBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetConfirmedBalance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GetConfirmedBalanceRequest, ::lightwalletrpc::GetConfirmedBalanceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::GetConfirmedBalanceRequest* request, ::lightwalletrpc::GetConfirmedBalanceResponse* response) { return this->GetConfirmedBalance(context, request, response); }));}
    void SetMessageAllocatorFor_GetConfirmedBalance(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::GetConfirmedBalanceRequest, ::lightwalletrpc::GetConfirmedBalanceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GetConfirmedBalanceRequest, ::lightwalletrpc::GetConfirmedBalanceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetConfirmedBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConfirmedBalance(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConfirmedBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConfirmedBalance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Generate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Generate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GenerateRequest, ::lightwalletrpc::GenerateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::GenerateRequest* request, ::lightwalletrpc::GenerateResponse* response) { return this->Generate(context, request, response); }));}
    void SetMessageAllocatorFor_Generate(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::GenerateRequest, ::lightwalletrpc::GenerateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::GenerateRequest, ::lightwalletrpc::GenerateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Generate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Generate(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Generate(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Generate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LoadSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LoadSecondLayerCache() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::LoadCacheRequest, ::lightwalletrpc::LoadCacheResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::LoadCacheRequest* request, ::lightwalletrpc::LoadCacheResponse* response) { return this->LoadSecondLayerCache(context, request, response); }));}
    void SetMessageAllocatorFor_LoadSecondLayerCache(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::LoadCacheRequest, ::lightwalletrpc::LoadCacheResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::LoadCacheRequest, ::lightwalletrpc::LoadCacheResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LoadSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LoadSecondLayerCache(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LoadSecondLayerCache(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FreeSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FreeSecondLayerCache() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Empty, ::lightwalletrpc::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::Empty* request, ::lightwalletrpc::Empty* response) { return this->FreeSecondLayerCache(context, request, response); }));}
    void SetMessageAllocatorFor_FreeSecondLayerCache(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::Empty, ::lightwalletrpc::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Empty, ::lightwalletrpc::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FreeSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FreeSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FreeSecondLayerCache(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FreeSecondLayerCache(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EstimateNetworkFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EstimateNetworkFee() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::EstimateNetworkFeeRequest, ::lightwalletrpc::EstimateNetworkFeeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::EstimateNetworkFeeRequest* request, ::lightwalletrpc::EstimateNetworkFeeResponse* response) { return this->EstimateNetworkFee(context, request, response); }));}
    void SetMessageAllocatorFor_EstimateNetworkFee(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::EstimateNetworkFeeRequest, ::lightwalletrpc::EstimateNetworkFeeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::EstimateNetworkFeeRequest, ::lightwalletrpc::EstimateNetworkFeeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EstimateNetworkFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateNetworkFee(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateNetworkFee(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateNetworkFee(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LockOutpoint() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response) { return this->LockOutpoint(context, request, response); }));}
    void SetMessageAllocatorFor_LockOutpoint(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LockOutpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LockOutpoint(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlockOutpoint() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::Empty* response) { return this->UnlockOutpoint(context, request, response); }));}
    void SetMessageAllocatorFor_UnlockOutpoint(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlockOutpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlockOutpoint(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSpendingDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSpendingDetails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::GetRawTransactionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lightwalletrpc::Outpoint* request, ::lightwalletrpc::GetRawTransactionResponse* response) { return this->GetSpendingDetails(context, request, response); }));}
    void SetMessageAllocatorFor_GetSpendingDetails(
        ::grpc::experimental::MessageAllocator< ::lightwalletrpc::Outpoint, ::lightwalletrpc::GetRawTransactionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::GetRawTransactionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSpendingDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpendingDetails(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSpendingDetails(
      ::grpc::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSpendingDetails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetChainInfo<ExperimentalWithCallbackMethod_GetBlockHash<ExperimentalWithCallbackMethod_GetBlock<ExperimentalWithCallbackMethod_GetBlockHeader<ExperimentalWithCallbackMethod_GetBlockHeaderVerbose<ExperimentalWithCallbackMethod_GetFilterBlock<ExperimentalWithCallbackMethod_GetBlockFilter<ExperimentalWithCallbackMethod_GetTxOut<ExperimentalWithCallbackMethod_GetRawTransaction<ExperimentalWithCallbackMethod_GetRawTxByIndex<ExperimentalWithCallbackMethod_GetLastAddress<ExperimentalWithCallbackMethod_ListUtxos<ExperimentalWithCallbackMethod_DumpPrivKey<ExperimentalWithCallbackMethod_SendRawTransaction<ExperimentalWithCallbackMethod_GetConfirmedBalance<ExperimentalWithCallbackMethod_Generate<ExperimentalWithCallbackMethod_LoadSecondLayerCache<ExperimentalWithCallbackMethod_FreeSecondLayerCache<ExperimentalWithCallbackMethod_EstimateNetworkFee<ExperimentalWithCallbackMethod_LockOutpoint<ExperimentalWithCallbackMethod_UnlockOutpoint<ExperimentalWithCallbackMethod_GetSpendingDetails<Service > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetChainInfo<ExperimentalWithCallbackMethod_GetBlockHash<ExperimentalWithCallbackMethod_GetBlock<ExperimentalWithCallbackMethod_GetBlockHeader<ExperimentalWithCallbackMethod_GetBlockHeaderVerbose<ExperimentalWithCallbackMethod_GetFilterBlock<ExperimentalWithCallbackMethod_GetBlockFilter<ExperimentalWithCallbackMethod_GetTxOut<ExperimentalWithCallbackMethod_GetRawTransaction<ExperimentalWithCallbackMethod_GetRawTxByIndex<ExperimentalWithCallbackMethod_GetLastAddress<ExperimentalWithCallbackMethod_ListUtxos<ExperimentalWithCallbackMethod_DumpPrivKey<ExperimentalWithCallbackMethod_SendRawTransaction<ExperimentalWithCallbackMethod_GetConfirmedBalance<ExperimentalWithCallbackMethod_Generate<ExperimentalWithCallbackMethod_LoadSecondLayerCache<ExperimentalWithCallbackMethod_FreeSecondLayerCache<ExperimentalWithCallbackMethod_EstimateNetworkFee<ExperimentalWithCallbackMethod_LockOutpoint<ExperimentalWithCallbackMethod_UnlockOutpoint<ExperimentalWithCallbackMethod_GetSpendingDetails<Service > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlock() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeaderVerbose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeaderVerbose() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetBlockHeaderVerbose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderVerbose(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFilterBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFilterBlock() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetFilterBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFilterBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockFilter() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetBlockFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockFilter(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTxOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTxOut() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetTxOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxOut(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRawTransaction() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRawTxByIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRawTxByIndex() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetRawTxByIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTxByIndex(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLastAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLastAddress() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetLastAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastAddress(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListUtxos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListUtxos() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ListUtxos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUtxos(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DumpPrivKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DumpPrivKey() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_DumpPrivKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpPrivKey(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendRawTransaction() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_SendRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConfirmedBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConfirmedBalance() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetConfirmedBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConfirmedBalance(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Generate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Generate() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Generate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Generate(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadSecondLayerCache() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_LoadSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FreeSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FreeSecondLayerCache() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_FreeSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FreeSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EstimateNetworkFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EstimateNetworkFee() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_EstimateNetworkFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateNetworkFee(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LockOutpoint() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_LockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlockOutpoint() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_UnlockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSpendingDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSpendingDetails() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetSpendingDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpendingDetails(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChainInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHash(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlock() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeaderVerbose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeaderVerbose() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetBlockHeaderVerbose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderVerbose(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderVerbose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFilterBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFilterBlock() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetFilterBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFilterBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFilterBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockFilter() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetBlockFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockFilter(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockFilter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTxOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTxOut() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetTxOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxOut(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTxOut(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRawTransaction() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRawTransaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRawTxByIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRawTxByIndex() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetRawTxByIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTxByIndex(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRawTxByIndex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLastAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLastAddress() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetLastAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastAddress(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLastAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListUtxos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListUtxos() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ListUtxos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUtxos(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUtxos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DumpPrivKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DumpPrivKey() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_DumpPrivKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpPrivKey(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDumpPrivKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendRawTransaction() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_SendRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendRawTransaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConfirmedBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConfirmedBalance() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetConfirmedBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConfirmedBalance(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConfirmedBalance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Generate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Generate() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_Generate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Generate(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadSecondLayerCache() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_LoadSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadSecondLayerCache(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FreeSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FreeSecondLayerCache() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_FreeSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FreeSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFreeSecondLayerCache(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EstimateNetworkFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EstimateNetworkFee() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_EstimateNetworkFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateNetworkFee(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateNetworkFee(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LockOutpoint() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_LockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLockOutpoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlockOutpoint() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_UnlockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlockOutpoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSpendingDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSpendingDetails() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetSpendingDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpendingDetails(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpendingDetails(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetChainInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetChainInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChainInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChainInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockHash() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHash(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHash(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHash(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockHeader() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeader(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeader(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockHeaderVerbose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockHeaderVerbose() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeaderVerbose(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockHeaderVerbose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderVerbose(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderVerbose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeaderVerbose(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetFilterBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetFilterBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFilterBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetFilterBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFilterBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetFilterBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetFilterBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockFilter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockFilter(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTxOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTxOut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTxOut(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTxOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxOut(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTxOut(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTxOut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRawTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRawTransaction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRawTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRawTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRawTxByIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRawTxByIndex() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRawTxByIndex(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRawTxByIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRawTxByIndex(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRawTxByIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRawTxByIndex(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLastAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLastAddress() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLastAddress(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLastAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastAddress(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLastAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLastAddress(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListUtxos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListUtxos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListUtxos(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListUtxos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUtxos(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListUtxos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListUtxos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DumpPrivKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DumpPrivKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DumpPrivKey(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DumpPrivKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpPrivKey(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DumpPrivKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DumpPrivKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendRawTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendRawTransaction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendRawTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendRawTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetConfirmedBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetConfirmedBalance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConfirmedBalance(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetConfirmedBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConfirmedBalance(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConfirmedBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConfirmedBalance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Generate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Generate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Generate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Generate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Generate(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Generate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Generate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LoadSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LoadSecondLayerCache() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadSecondLayerCache(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LoadSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LoadSecondLayerCache(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LoadSecondLayerCache(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FreeSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FreeSecondLayerCache() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FreeSecondLayerCache(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FreeSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FreeSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FreeSecondLayerCache(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FreeSecondLayerCache(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EstimateNetworkFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EstimateNetworkFee() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EstimateNetworkFee(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EstimateNetworkFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateNetworkFee(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateNetworkFee(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateNetworkFee(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LockOutpoint() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LockOutpoint(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LockOutpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LockOutpoint(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlockOutpoint() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlockOutpoint(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlockOutpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlockOutpoint(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSpendingDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSpendingDetails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSpendingDetails(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSpendingDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpendingDetails(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSpendingDetails(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSpendingDetails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::Empty, ::lightwalletrpc::GetChainInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetChainInfo<BaseClass>::StreamedGetChainInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::GetChainInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetChainInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::Empty,::lightwalletrpc::GetChainInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::Height, ::lightwalletrpc::BlockHash>(std::bind(&WithStreamedUnaryMethod_GetBlockHash<BaseClass>::StreamedGetBlockHash, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Height* /*request*/, ::lightwalletrpc::BlockHash* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHash(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::Height,::lightwalletrpc::BlockHash>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlock() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::GetBlockResponse>(std::bind(&WithStreamedUnaryMethod_GetBlock<BaseClass>::StreamedGetBlock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::GetBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::BlockHash,::lightwalletrpc::GetBlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::HexEncoded>(std::bind(&WithStreamedUnaryMethod_GetBlockHeader<BaseClass>::StreamedGetBlockHeader, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeader(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::BlockHash,::lightwalletrpc::HexEncoded>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeaderVerbose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeaderVerbose() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockHeader>(std::bind(&WithStreamedUnaryMethod_GetBlockHeaderVerbose<BaseClass>::StreamedGetBlockHeaderVerbose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlockHeaderVerbose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeaderVerbose(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockHeader* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeaderVerbose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::BlockHash,::lightwalletrpc::BlockHeader>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFilterBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFilterBlock() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::FilterBlockResponse>(std::bind(&WithStreamedUnaryMethod_GetFilterBlock<BaseClass>::StreamedGetFilterBlock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetFilterBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFilterBlock(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::FilterBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFilterBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::BlockHash,::lightwalletrpc::FilterBlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockFilter() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::BlockHash, ::lightwalletrpc::BlockFilter>(std::bind(&WithStreamedUnaryMethod_GetBlockFilter<BaseClass>::StreamedGetBlockFilter, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlockFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockFilter(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::BlockHash* /*request*/, ::lightwalletrpc::BlockFilter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockFilter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::BlockHash,::lightwalletrpc::BlockFilter>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTxOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTxOut() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::TxOut>(std::bind(&WithStreamedUnaryMethod_GetTxOut<BaseClass>::StreamedGetTxOut, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTxOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTxOut(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::TxOut* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTxOut(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::Outpoint,::lightwalletrpc::TxOut>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRawTransaction() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::TxID, ::lightwalletrpc::GetRawTransactionResponse>(std::bind(&WithStreamedUnaryMethod_GetRawTransaction<BaseClass>::StreamedGetRawTransaction, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::TxID* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRawTransaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::TxID,::lightwalletrpc::GetRawTransactionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRawTxByIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRawTxByIndex() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::GetRawTxByIndexRequest, ::lightwalletrpc::GetRawTxByIndexResponse>(std::bind(&WithStreamedUnaryMethod_GetRawTxByIndex<BaseClass>::StreamedGetRawTxByIndex, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRawTxByIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRawTxByIndex(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetRawTxByIndexRequest* /*request*/, ::lightwalletrpc::GetRawTxByIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRawTxByIndex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::GetRawTxByIndexRequest,::lightwalletrpc::GetRawTxByIndexResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLastAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLastAddress() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::GetLastAddressRequest, ::lightwalletrpc::GetLastAddressResponse>(std::bind(&WithStreamedUnaryMethod_GetLastAddress<BaseClass>::StreamedGetLastAddress, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetLastAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLastAddress(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetLastAddressRequest* /*request*/, ::lightwalletrpc::GetLastAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLastAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::GetLastAddressRequest,::lightwalletrpc::GetLastAddressResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListUtxos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListUtxos() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::ListUtxosRequest, ::lightwalletrpc::ListUtxoResult>(std::bind(&WithStreamedUnaryMethod_ListUtxos<BaseClass>::StreamedListUtxos, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListUtxos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListUtxos(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::ListUtxosRequest* /*request*/, ::lightwalletrpc::ListUtxoResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListUtxos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::ListUtxosRequest,::lightwalletrpc::ListUtxoResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DumpPrivKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DumpPrivKey() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::DumpPrivKeyRequest, ::lightwalletrpc::HexEncoded>(std::bind(&WithStreamedUnaryMethod_DumpPrivKey<BaseClass>::StreamedDumpPrivKey, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DumpPrivKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DumpPrivKey(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::DumpPrivKeyRequest* /*request*/, ::lightwalletrpc::HexEncoded* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDumpPrivKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::DumpPrivKeyRequest,::lightwalletrpc::HexEncoded>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendRawTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendRawTransaction() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::HexEncoded, ::lightwalletrpc::TxID>(std::bind(&WithStreamedUnaryMethod_SendRawTransaction<BaseClass>::StreamedSendRawTransaction, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SendRawTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendRawTransaction(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::HexEncoded* /*request*/, ::lightwalletrpc::TxID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendRawTransaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::HexEncoded,::lightwalletrpc::TxID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConfirmedBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConfirmedBalance() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::GetConfirmedBalanceRequest, ::lightwalletrpc::GetConfirmedBalanceResponse>(std::bind(&WithStreamedUnaryMethod_GetConfirmedBalance<BaseClass>::StreamedGetConfirmedBalance, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetConfirmedBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConfirmedBalance(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GetConfirmedBalanceRequest* /*request*/, ::lightwalletrpc::GetConfirmedBalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConfirmedBalance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::GetConfirmedBalanceRequest,::lightwalletrpc::GetConfirmedBalanceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Generate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Generate() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::GenerateRequest, ::lightwalletrpc::GenerateResponse>(std::bind(&WithStreamedUnaryMethod_Generate<BaseClass>::StreamedGenerate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Generate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Generate(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::GenerateRequest* /*request*/, ::lightwalletrpc::GenerateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGenerate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::GenerateRequest,::lightwalletrpc::GenerateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadSecondLayerCache() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::LoadCacheRequest, ::lightwalletrpc::LoadCacheResponse>(std::bind(&WithStreamedUnaryMethod_LoadSecondLayerCache<BaseClass>::StreamedLoadSecondLayerCache, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_LoadSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::LoadCacheRequest* /*request*/, ::lightwalletrpc::LoadCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadSecondLayerCache(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::LoadCacheRequest,::lightwalletrpc::LoadCacheResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FreeSecondLayerCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FreeSecondLayerCache() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::Empty, ::lightwalletrpc::Empty>(std::bind(&WithStreamedUnaryMethod_FreeSecondLayerCache<BaseClass>::StreamedFreeSecondLayerCache, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FreeSecondLayerCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FreeSecondLayerCache(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Empty* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFreeSecondLayerCache(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::Empty,::lightwalletrpc::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EstimateNetworkFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EstimateNetworkFee() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::EstimateNetworkFeeRequest, ::lightwalletrpc::EstimateNetworkFeeResponse>(std::bind(&WithStreamedUnaryMethod_EstimateNetworkFee<BaseClass>::StreamedEstimateNetworkFee, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_EstimateNetworkFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EstimateNetworkFee(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::EstimateNetworkFeeRequest* /*request*/, ::lightwalletrpc::EstimateNetworkFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEstimateNetworkFee(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::EstimateNetworkFeeRequest,::lightwalletrpc::EstimateNetworkFeeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LockOutpoint() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>(std::bind(&WithStreamedUnaryMethod_LockOutpoint<BaseClass>::StreamedLockOutpoint, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_LockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLockOutpoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::Outpoint,::lightwalletrpc::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlockOutpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlockOutpoint() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::Empty>(std::bind(&WithStreamedUnaryMethod_UnlockOutpoint<BaseClass>::StreamedUnlockOutpoint, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UnlockOutpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlockOutpoint(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlockOutpoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::Outpoint,::lightwalletrpc::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSpendingDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSpendingDetails() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::lightwalletrpc::Outpoint, ::lightwalletrpc::GetRawTransactionResponse>(std::bind(&WithStreamedUnaryMethod_GetSpendingDetails<BaseClass>::StreamedGetSpendingDetails, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSpendingDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSpendingDetails(::grpc::ServerContext* /*context*/, const ::lightwalletrpc::Outpoint* /*request*/, ::lightwalletrpc::GetRawTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSpendingDetails(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lightwalletrpc::Outpoint,::lightwalletrpc::GetRawTransactionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetChainInfo<WithStreamedUnaryMethod_GetBlockHash<WithStreamedUnaryMethod_GetBlock<WithStreamedUnaryMethod_GetBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderVerbose<WithStreamedUnaryMethod_GetFilterBlock<WithStreamedUnaryMethod_GetBlockFilter<WithStreamedUnaryMethod_GetTxOut<WithStreamedUnaryMethod_GetRawTransaction<WithStreamedUnaryMethod_GetRawTxByIndex<WithStreamedUnaryMethod_GetLastAddress<WithStreamedUnaryMethod_ListUtxos<WithStreamedUnaryMethod_DumpPrivKey<WithStreamedUnaryMethod_SendRawTransaction<WithStreamedUnaryMethod_GetConfirmedBalance<WithStreamedUnaryMethod_Generate<WithStreamedUnaryMethod_LoadSecondLayerCache<WithStreamedUnaryMethod_FreeSecondLayerCache<WithStreamedUnaryMethod_EstimateNetworkFee<WithStreamedUnaryMethod_LockOutpoint<WithStreamedUnaryMethod_UnlockOutpoint<WithStreamedUnaryMethod_GetSpendingDetails<Service > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetChainInfo<WithStreamedUnaryMethod_GetBlockHash<WithStreamedUnaryMethod_GetBlock<WithStreamedUnaryMethod_GetBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderVerbose<WithStreamedUnaryMethod_GetFilterBlock<WithStreamedUnaryMethod_GetBlockFilter<WithStreamedUnaryMethod_GetTxOut<WithStreamedUnaryMethod_GetRawTransaction<WithStreamedUnaryMethod_GetRawTxByIndex<WithStreamedUnaryMethod_GetLastAddress<WithStreamedUnaryMethod_ListUtxos<WithStreamedUnaryMethod_DumpPrivKey<WithStreamedUnaryMethod_SendRawTransaction<WithStreamedUnaryMethod_GetConfirmedBalance<WithStreamedUnaryMethod_Generate<WithStreamedUnaryMethod_LoadSecondLayerCache<WithStreamedUnaryMethod_FreeSecondLayerCache<WithStreamedUnaryMethod_EstimateNetworkFee<WithStreamedUnaryMethod_LockOutpoint<WithStreamedUnaryMethod_UnlockOutpoint<WithStreamedUnaryMethod_GetSpendingDetails<Service > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace lightwalletrpc


#endif  // GRPC_LightWalletService_2eproto__INCLUDED
