// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: lssdrpc.proto
#ifndef GRPC_lssdrpc_2eproto__INCLUDED
#define GRPC_lssdrpc_2eproto__INCLUDED

#include "lssdrpc.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace lssdrpc {

// currencies
class currencies final {
 public:
  static constexpr char const* service_full_name() {
    return "lssdrpc.currencies";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // before being able to enable a trading pair, you need to add the two involved currencies
    // for example, for activating XSN_LTC, you will add the XSN currency, and the LTC currency.
    //
    // For now, only currencies supported by lnd (lightning network) work.
    virtual ::grpc::Status AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::lssdrpc::AddCurrencyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::AddCurrencyResponse>> AsyncAddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::AddCurrencyResponse>>(AsyncAddCurrencyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::AddCurrencyResponse>> PrepareAsyncAddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::AddCurrencyResponse>>(PrepareAsyncAddCurrencyRaw(context, request, cq));
    }
    // Return added currencies, like LTC, before calling this method, you must
    // have already added some currency
    virtual ::grpc::Status GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::lssdrpc::GetAddedCurrenciesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetAddedCurrenciesResponse>> AsyncGetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetAddedCurrenciesResponse>>(AsyncGetAddedCurrenciesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetAddedCurrenciesResponse>> PrepareAsyncGetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetAddedCurrenciesResponse>>(PrepareAsyncGetAddedCurrenciesRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // before being able to enable a trading pair, you need to add the two involved currencies
      // for example, for activating XSN_LTC, you will add the XSN currency, and the LTC currency.
      //
      // For now, only currencies supported by lnd (lightning network) work.
      virtual void AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddCurrency(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::AddCurrencyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddCurrency(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddCurrency(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Return added currencies, like LTC, before calling this method, you must
      // have already added some currency
      virtual void GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAddedCurrencies(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetAddedCurrenciesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAddedCurrencies(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAddedCurrencies(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::AddCurrencyResponse>* AsyncAddCurrencyRaw(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::AddCurrencyResponse>* PrepareAsyncAddCurrencyRaw(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetAddedCurrenciesResponse>* AsyncGetAddedCurrenciesRaw(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetAddedCurrenciesResponse>* PrepareAsyncGetAddedCurrenciesRaw(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::lssdrpc::AddCurrencyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::AddCurrencyResponse>> AsyncAddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::AddCurrencyResponse>>(AsyncAddCurrencyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::AddCurrencyResponse>> PrepareAsyncAddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::AddCurrencyResponse>>(PrepareAsyncAddCurrencyRaw(context, request, cq));
    }
    ::grpc::Status GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::lssdrpc::GetAddedCurrenciesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetAddedCurrenciesResponse>> AsyncGetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetAddedCurrenciesResponse>>(AsyncGetAddedCurrenciesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetAddedCurrenciesResponse>> PrepareAsyncGetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetAddedCurrenciesResponse>>(PrepareAsyncGetAddedCurrenciesRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response, std::function<void(::grpc::Status)>) override;
      void AddCurrency(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::AddCurrencyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddCurrency(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddCurrency(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddCurrency(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::AddCurrencyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAddedCurrencies(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetAddedCurrenciesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAddedCurrencies(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAddedCurrencies(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAddedCurrencies(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetAddedCurrenciesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::AddCurrencyResponse>* AsyncAddCurrencyRaw(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::AddCurrencyResponse>* PrepareAsyncAddCurrencyRaw(::grpc::ClientContext* context, const ::lssdrpc::AddCurrencyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetAddedCurrenciesResponse>* AsyncGetAddedCurrenciesRaw(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetAddedCurrenciesResponse>* PrepareAsyncGetAddedCurrenciesRaw(::grpc::ClientContext* context, const ::lssdrpc::GetAddedCurrenciesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AddCurrency_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAddedCurrencies_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // before being able to enable a trading pair, you need to add the two involved currencies
    // for example, for activating XSN_LTC, you will add the XSN currency, and the LTC currency.
    //
    // For now, only currencies supported by lnd (lightning network) work.
    virtual ::grpc::Status AddCurrency(::grpc::ServerContext* context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response);
    // Return added currencies, like LTC, before calling this method, you must
    // have already added some currency
    virtual ::grpc::Status GetAddedCurrencies(::grpc::ServerContext* context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_AddCurrency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddCurrency() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_AddCurrency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddCurrency(::grpc::ServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddCurrency(::grpc::ServerContext* context, ::lssdrpc::AddCurrencyRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::AddCurrencyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAddedCurrencies : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAddedCurrencies() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetAddedCurrencies() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAddedCurrencies(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAddedCurrencies(::grpc::ServerContext* context, ::lssdrpc::GetAddedCurrenciesRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::GetAddedCurrenciesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AddCurrency<WithAsyncMethod_GetAddedCurrencies<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddCurrency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddCurrency() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::AddCurrencyRequest, ::lssdrpc::AddCurrencyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::AddCurrencyRequest* request, ::lssdrpc::AddCurrencyResponse* response) { return this->AddCurrency(context, request, response); }));}
    void SetMessageAllocatorFor_AddCurrency(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::AddCurrencyRequest, ::lssdrpc::AddCurrencyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::AddCurrencyRequest, ::lssdrpc::AddCurrencyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddCurrency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddCurrency(::grpc::ServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddCurrency(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddCurrency(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAddedCurrencies : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAddedCurrencies() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetAddedCurrenciesRequest, ::lssdrpc::GetAddedCurrenciesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::GetAddedCurrenciesRequest* request, ::lssdrpc::GetAddedCurrenciesResponse* response) { return this->GetAddedCurrencies(context, request, response); }));}
    void SetMessageAllocatorFor_GetAddedCurrencies(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::GetAddedCurrenciesRequest, ::lssdrpc::GetAddedCurrenciesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetAddedCurrenciesRequest, ::lssdrpc::GetAddedCurrenciesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAddedCurrencies() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAddedCurrencies(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAddedCurrencies(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAddedCurrencies(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_AddCurrency<ExperimentalWithCallbackMethod_GetAddedCurrencies<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_AddCurrency<ExperimentalWithCallbackMethod_GetAddedCurrencies<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AddCurrency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddCurrency() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AddCurrency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddCurrency(::grpc::ServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAddedCurrencies : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAddedCurrencies() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetAddedCurrencies() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAddedCurrencies(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddCurrency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddCurrency() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_AddCurrency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddCurrency(::grpc::ServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddCurrency(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAddedCurrencies : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAddedCurrencies() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetAddedCurrencies() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAddedCurrencies(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAddedCurrencies(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddCurrency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddCurrency() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddCurrency(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddCurrency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddCurrency(::grpc::ServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddCurrency(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddCurrency(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAddedCurrencies : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAddedCurrencies() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAddedCurrencies(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAddedCurrencies() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAddedCurrencies(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAddedCurrencies(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAddedCurrencies(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddCurrency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddCurrency() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::AddCurrencyRequest, ::lssdrpc::AddCurrencyResponse>(std::bind(&WithStreamedUnaryMethod_AddCurrency<BaseClass>::StreamedAddCurrency, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AddCurrency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddCurrency(::grpc::ServerContext* /*context*/, const ::lssdrpc::AddCurrencyRequest* /*request*/, ::lssdrpc::AddCurrencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddCurrency(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::AddCurrencyRequest,::lssdrpc::AddCurrencyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAddedCurrencies : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAddedCurrencies() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::GetAddedCurrenciesRequest, ::lssdrpc::GetAddedCurrenciesResponse>(std::bind(&WithStreamedUnaryMethod_GetAddedCurrencies<BaseClass>::StreamedGetAddedCurrencies, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAddedCurrencies() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAddedCurrencies(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetAddedCurrenciesRequest* /*request*/, ::lssdrpc::GetAddedCurrenciesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAddedCurrencies(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::GetAddedCurrenciesRequest,::lssdrpc::GetAddedCurrenciesResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AddCurrency<WithStreamedUnaryMethod_GetAddedCurrencies<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_AddCurrency<WithStreamedUnaryMethod_GetAddedCurrencies<Service > > StreamedService;
};

// trading pairs
class tradingPairs final {
 public:
  static constexpr char const* service_full_name() {
    return "lssdrpc.tradingPairs";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Enables the given trading pair, like XSN_LTC, before calling this method, you must
    // have already added the involved currencies.
    //
    // After enabling a trading pair, lssd will download the existing orders form the orderbook,
    // try waiting some seconds (5 should be enough) before performing any other operation, so
    // that lssd has the time to sync because this is done in the background.
    virtual ::grpc::Status EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::lssdrpc::EnableTradingPairResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::EnableTradingPairResponse>> AsyncEnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::EnableTradingPairResponse>>(AsyncEnableTradingPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::EnableTradingPairResponse>> PrepareAsyncEnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::EnableTradingPairResponse>>(PrepareAsyncEnableTradingPairRaw(context, request, cq));
    }
    // Return current active trading pair, like XSN_LTC, before calling this method, you must
    // have already added and activated some trading pair
    virtual ::grpc::Status GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::lssdrpc::GetActiveTradingPairResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetActiveTradingPairResponse>> AsyncGetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetActiveTradingPairResponse>>(AsyncGetActiveTradingPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetActiveTradingPairResponse>> PrepareAsyncGetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetActiveTradingPairResponse>>(PrepareAsyncGetActiveTradingPairRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Enables the given trading pair, like XSN_LTC, before calling this method, you must
      // have already added the involved currencies.
      //
      // After enabling a trading pair, lssd will download the existing orders form the orderbook,
      // try waiting some seconds (5 should be enough) before performing any other operation, so
      // that lssd has the time to sync because this is done in the background.
      virtual void EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::EnableTradingPairResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EnableTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EnableTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Return current active trading pair, like XSN_LTC, before calling this method, you must
      // have already added and activated some trading pair
      virtual void GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActiveTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetActiveTradingPairResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetActiveTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetActiveTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::EnableTradingPairResponse>* AsyncEnableTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::EnableTradingPairResponse>* PrepareAsyncEnableTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetActiveTradingPairResponse>* AsyncGetActiveTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetActiveTradingPairResponse>* PrepareAsyncGetActiveTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::lssdrpc::EnableTradingPairResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::EnableTradingPairResponse>> AsyncEnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::EnableTradingPairResponse>>(AsyncEnableTradingPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::EnableTradingPairResponse>> PrepareAsyncEnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::EnableTradingPairResponse>>(PrepareAsyncEnableTradingPairRaw(context, request, cq));
    }
    ::grpc::Status GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::lssdrpc::GetActiveTradingPairResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetActiveTradingPairResponse>> AsyncGetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetActiveTradingPairResponse>>(AsyncGetActiveTradingPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetActiveTradingPairResponse>> PrepareAsyncGetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetActiveTradingPairResponse>>(PrepareAsyncGetActiveTradingPairRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::EnableTradingPairResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EnableTradingPair(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EnableTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EnableTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::EnableTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response, std::function<void(::grpc::Status)>) override;
      void GetActiveTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetActiveTradingPairResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetActiveTradingPair(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetActiveTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetActiveTradingPair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetActiveTradingPairResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::EnableTradingPairResponse>* AsyncEnableTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::EnableTradingPairResponse>* PrepareAsyncEnableTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::EnableTradingPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetActiveTradingPairResponse>* AsyncGetActiveTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetActiveTradingPairResponse>* PrepareAsyncGetActiveTradingPairRaw(::grpc::ClientContext* context, const ::lssdrpc::GetActiveTradingPairRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_EnableTradingPair_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActiveTradingPair_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Enables the given trading pair, like XSN_LTC, before calling this method, you must
    // have already added the involved currencies.
    //
    // After enabling a trading pair, lssd will download the existing orders form the orderbook,
    // try waiting some seconds (5 should be enough) before performing any other operation, so
    // that lssd has the time to sync because this is done in the background.
    virtual ::grpc::Status EnableTradingPair(::grpc::ServerContext* context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response);
    // Return current active trading pair, like XSN_LTC, before calling this method, you must
    // have already added and activated some trading pair
    virtual ::grpc::Status GetActiveTradingPair(::grpc::ServerContext* context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableTradingPair() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_EnableTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableTradingPair(::grpc::ServerContext* context, ::lssdrpc::EnableTradingPairRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::EnableTradingPairResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActiveTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetActiveTradingPair() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetActiveTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveTradingPair(::grpc::ServerContext* context, ::lssdrpc::GetActiveTradingPairRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::GetActiveTradingPairResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_EnableTradingPair<WithAsyncMethod_GetActiveTradingPair<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EnableTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EnableTradingPair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::EnableTradingPairRequest, ::lssdrpc::EnableTradingPairResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::EnableTradingPairRequest* request, ::lssdrpc::EnableTradingPairResponse* response) { return this->EnableTradingPair(context, request, response); }));}
    void SetMessageAllocatorFor_EnableTradingPair(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::EnableTradingPairRequest, ::lssdrpc::EnableTradingPairResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::EnableTradingPairRequest, ::lssdrpc::EnableTradingPairResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EnableTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EnableTradingPair(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EnableTradingPair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetActiveTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetActiveTradingPair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetActiveTradingPairRequest, ::lssdrpc::GetActiveTradingPairResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::GetActiveTradingPairRequest* request, ::lssdrpc::GetActiveTradingPairResponse* response) { return this->GetActiveTradingPair(context, request, response); }));}
    void SetMessageAllocatorFor_GetActiveTradingPair(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::GetActiveTradingPairRequest, ::lssdrpc::GetActiveTradingPairResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetActiveTradingPairRequest, ::lssdrpc::GetActiveTradingPairResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetActiveTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetActiveTradingPair(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetActiveTradingPair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_EnableTradingPair<ExperimentalWithCallbackMethod_GetActiveTradingPair<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_EnableTradingPair<ExperimentalWithCallbackMethod_GetActiveTradingPair<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_EnableTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableTradingPair() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_EnableTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActiveTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetActiveTradingPair() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetActiveTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableTradingPair() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_EnableTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableTradingPair(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActiveTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetActiveTradingPair() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetActiveTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveTradingPair(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EnableTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EnableTradingPair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableTradingPair(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EnableTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EnableTradingPair(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EnableTradingPair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetActiveTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetActiveTradingPair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetActiveTradingPair(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetActiveTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetActiveTradingPair(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetActiveTradingPair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableTradingPair() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::EnableTradingPairRequest, ::lssdrpc::EnableTradingPairResponse>(std::bind(&WithStreamedUnaryMethod_EnableTradingPair<BaseClass>::StreamedEnableTradingPair, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_EnableTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::EnableTradingPairRequest* /*request*/, ::lssdrpc::EnableTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableTradingPair(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::EnableTradingPairRequest,::lssdrpc::EnableTradingPairResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActiveTradingPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetActiveTradingPair() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::GetActiveTradingPairRequest, ::lssdrpc::GetActiveTradingPairResponse>(std::bind(&WithStreamedUnaryMethod_GetActiveTradingPair<BaseClass>::StreamedGetActiveTradingPair, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetActiveTradingPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActiveTradingPair(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetActiveTradingPairRequest* /*request*/, ::lssdrpc::GetActiveTradingPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActiveTradingPair(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::GetActiveTradingPairRequest,::lssdrpc::GetActiveTradingPairResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_EnableTradingPair<WithStreamedUnaryMethod_GetActiveTradingPair<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_EnableTradingPair<WithStreamedUnaryMethod_GetActiveTradingPair<Service > > StreamedService;
};

// orders
class orders final {
 public:
  static constexpr char const* service_full_name() {
    return "lssdrpc.orders";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Places an order to the orderbook, you must have already enabled the involved trading pair.
    //
    // NOTE: After the order is matched, lssd will perform the swap automatically, so, your lnd
    // needs to have a channel with enough coins to our hub.
    virtual ::grpc::Status PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::lssdrpc::PlaceOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::PlaceOrderResponse>> AsyncPlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::PlaceOrderResponse>>(AsyncPlaceOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::PlaceOrderResponse>> PrepareAsyncPlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::PlaceOrderResponse>>(PrepareAsyncPlaceOrderRaw(context, request, cq));
    }
    // Cancels an existing order.
    virtual ::grpc::Status CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::lssdrpc::CancelOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::CancelOrderResponse>> AsyncCancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::CancelOrderResponse>>(AsyncCancelOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::CancelOrderResponse>> PrepareAsyncCancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::CancelOrderResponse>>(PrepareAsyncCancelOrderRaw(context, request, cq));
    }
    // Subscribe to events related to the orders in the orderbook.
    // Order added, removed will be delivered via this stream.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::OrderUpdate>> SubscribeOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::OrderUpdate>>(SubscribeOrdersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderUpdate>> AsyncSubscribeOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderUpdate>>(AsyncSubscribeOrdersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderUpdate>> PrepareAsyncSubscribeOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderUpdate>>(PrepareAsyncSubscribeOrdersRaw(context, request, cq));
    }
    // Subscribe to events related to the own oroders in the orderbook.
    // Order added, changed, removed will be delivered via this stream.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::OwnOrderUpdate>> SubscribeOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::OwnOrderUpdate>>(SubscribeOwnOrdersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OwnOrderUpdate>> AsyncSubscribeOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OwnOrderUpdate>>(AsyncSubscribeOwnOrdersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OwnOrderUpdate>> PrepareAsyncSubscribeOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OwnOrderUpdate>>(PrepareAsyncSubscribeOwnOrdersRaw(context, request, cq));
    }
    // List the available order on the orderbook.
    virtual ::grpc::Status ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::lssdrpc::ListOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOrdersResponse>> AsyncListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOrdersResponse>>(AsyncListOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOrdersResponse>> PrepareAsyncListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOrdersResponse>>(PrepareAsyncListOrdersRaw(context, request, cq));
    }
    virtual ::grpc::Status ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::lssdrpc::ListOwnOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOwnOrdersResponse>> AsyncListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOwnOrdersResponse>>(AsyncListOwnOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOwnOrdersResponse>> PrepareAsyncListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOwnOrdersResponse>>(PrepareAsyncListOwnOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::OrderbookState>> SubscribeOrderbookState(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::OrderbookState>>(SubscribeOrderbookStateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderbookState>> AsyncSubscribeOrderbookState(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderbookState>>(AsyncSubscribeOrderbookStateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderbookState>> PrepareAsyncSubscribeOrderbookState(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderbookState>>(PrepareAsyncSubscribeOrderbookStateRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Places an order to the orderbook, you must have already enabled the involved trading pair.
      //
      // NOTE: After the order is matched, lssd will perform the swap automatically, so, your lnd
      // needs to have a channel with enough coins to our hub.
      virtual void PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlaceOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::PlaceOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PlaceOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PlaceOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Cancels an existing order.
      virtual void CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::CancelOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CancelOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CancelOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Subscribe to events related to the orders in the orderbook.
      // Order added, removed will be delivered via this stream.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::OrderUpdate>* reactor) = 0;
      #else
      virtual void SubscribeOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::OrderUpdate>* reactor) = 0;
      #endif
      // Subscribe to events related to the own oroders in the orderbook.
      // Order added, changed, removed will be delivered via this stream.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeOwnOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::OwnOrderUpdate>* reactor) = 0;
      #else
      virtual void SubscribeOwnOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::OwnOrderUpdate>* reactor) = 0;
      #endif
      // List the available order on the orderbook.
      virtual void ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListOwnOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOwnOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListOwnOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListOwnOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeOrderbookState(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrderbookStateRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::OrderbookState>* reactor) = 0;
      #else
      virtual void SubscribeOrderbookState(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrderbookStateRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::OrderbookState>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::PlaceOrderResponse>* AsyncPlaceOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::PlaceOrderResponse>* PrepareAsyncPlaceOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::CancelOrderResponse>* AsyncCancelOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::CancelOrderResponse>* PrepareAsyncCancelOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lssdrpc::OrderUpdate>* SubscribeOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderUpdate>* AsyncSubscribeOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderUpdate>* PrepareAsyncSubscribeOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lssdrpc::OwnOrderUpdate>* SubscribeOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OwnOrderUpdate>* AsyncSubscribeOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OwnOrderUpdate>* PrepareAsyncSubscribeOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOrdersResponse>* AsyncListOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOrdersResponse>* PrepareAsyncListOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOwnOrdersResponse>* AsyncListOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::ListOwnOrdersResponse>* PrepareAsyncListOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::lssdrpc::OrderbookState>* SubscribeOrderbookStateRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderbookState>* AsyncSubscribeOrderbookStateRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::OrderbookState>* PrepareAsyncSubscribeOrderbookStateRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::lssdrpc::PlaceOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::PlaceOrderResponse>> AsyncPlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::PlaceOrderResponse>>(AsyncPlaceOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::PlaceOrderResponse>> PrepareAsyncPlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::PlaceOrderResponse>>(PrepareAsyncPlaceOrderRaw(context, request, cq));
    }
    ::grpc::Status CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::lssdrpc::CancelOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::CancelOrderResponse>> AsyncCancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::CancelOrderResponse>>(AsyncCancelOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::CancelOrderResponse>> PrepareAsyncCancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::CancelOrderResponse>>(PrepareAsyncCancelOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::OrderUpdate>> SubscribeOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::OrderUpdate>>(SubscribeOrdersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderUpdate>> AsyncSubscribeOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderUpdate>>(AsyncSubscribeOrdersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderUpdate>> PrepareAsyncSubscribeOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderUpdate>>(PrepareAsyncSubscribeOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::OwnOrderUpdate>> SubscribeOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::OwnOrderUpdate>>(SubscribeOwnOrdersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OwnOrderUpdate>> AsyncSubscribeOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OwnOrderUpdate>>(AsyncSubscribeOwnOrdersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OwnOrderUpdate>> PrepareAsyncSubscribeOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OwnOrderUpdate>>(PrepareAsyncSubscribeOwnOrdersRaw(context, request, cq));
    }
    ::grpc::Status ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::lssdrpc::ListOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOrdersResponse>> AsyncListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOrdersResponse>>(AsyncListOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOrdersResponse>> PrepareAsyncListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOrdersResponse>>(PrepareAsyncListOrdersRaw(context, request, cq));
    }
    ::grpc::Status ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::lssdrpc::ListOwnOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOwnOrdersResponse>> AsyncListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOwnOrdersResponse>>(AsyncListOwnOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOwnOrdersResponse>> PrepareAsyncListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOwnOrdersResponse>>(PrepareAsyncListOwnOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::OrderbookState>> SubscribeOrderbookState(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::OrderbookState>>(SubscribeOrderbookStateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderbookState>> AsyncSubscribeOrderbookState(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderbookState>>(AsyncSubscribeOrderbookStateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderbookState>> PrepareAsyncSubscribeOrderbookState(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::OrderbookState>>(PrepareAsyncSubscribeOrderbookStateRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void PlaceOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::PlaceOrderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PlaceOrder(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PlaceOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PlaceOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::PlaceOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::CancelOrderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CancelOrder(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CancelOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CancelOrder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::CancelOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::OrderUpdate>* reactor) override;
      #else
      void SubscribeOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::OrderUpdate>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeOwnOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::OwnOrderUpdate>* reactor) override;
      #else
      void SubscribeOwnOrders(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::OwnOrderUpdate>* reactor) override;
      #endif
      void ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void ListOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void ListOwnOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOwnOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListOwnOrders(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListOwnOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListOwnOrders(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::ListOwnOrdersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeOrderbookState(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrderbookStateRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::OrderbookState>* reactor) override;
      #else
      void SubscribeOrderbookState(::grpc::ClientContext* context, ::lssdrpc::SubscribeOrderbookStateRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::OrderbookState>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::PlaceOrderResponse>* AsyncPlaceOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::PlaceOrderResponse>* PrepareAsyncPlaceOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::PlaceOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::CancelOrderResponse>* AsyncCancelOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::CancelOrderResponse>* PrepareAsyncCancelOrderRaw(::grpc::ClientContext* context, const ::lssdrpc::CancelOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lssdrpc::OrderUpdate>* SubscribeOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::OrderUpdate>* AsyncSubscribeOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::OrderUpdate>* PrepareAsyncSubscribeOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lssdrpc::OwnOrderUpdate>* SubscribeOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::OwnOrderUpdate>* AsyncSubscribeOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::OwnOrderUpdate>* PrepareAsyncSubscribeOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOrdersResponse>* AsyncListOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOrdersResponse>* PrepareAsyncListOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOwnOrdersResponse>* AsyncListOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::ListOwnOrdersResponse>* PrepareAsyncListOwnOrdersRaw(::grpc::ClientContext* context, const ::lssdrpc::ListOwnOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::lssdrpc::OrderbookState>* SubscribeOrderbookStateRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::OrderbookState>* AsyncSubscribeOrderbookStateRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::OrderbookState>* PrepareAsyncSubscribeOrderbookStateRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PlaceOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeOwnOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_ListOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_ListOwnOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeOrderbookState_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Places an order to the orderbook, you must have already enabled the involved trading pair.
    //
    // NOTE: After the order is matched, lssd will perform the swap automatically, so, your lnd
    // needs to have a channel with enough coins to our hub.
    virtual ::grpc::Status PlaceOrder(::grpc::ServerContext* context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response);
    // Cancels an existing order.
    virtual ::grpc::Status CancelOrder(::grpc::ServerContext* context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response);
    // Subscribe to events related to the orders in the orderbook.
    // Order added, removed will be delivered via this stream.
    virtual ::grpc::Status SubscribeOrders(::grpc::ServerContext* context, const ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ServerWriter< ::lssdrpc::OrderUpdate>* writer);
    // Subscribe to events related to the own oroders in the orderbook.
    // Order added, changed, removed will be delivered via this stream.
    virtual ::grpc::Status SubscribeOwnOrders(::grpc::ServerContext* context, const ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ServerWriter< ::lssdrpc::OwnOrderUpdate>* writer);
    // List the available order on the orderbook.
    virtual ::grpc::Status ListOrders(::grpc::ServerContext* context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response);
    virtual ::grpc::Status ListOwnOrders(::grpc::ServerContext* context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response);
    virtual ::grpc::Status SubscribeOrderbookState(::grpc::ServerContext* context, const ::lssdrpc::SubscribeOrderbookStateRequest* request, ::grpc::ServerWriter< ::lssdrpc::OrderbookState>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_PlaceOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlaceOrder() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PlaceOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaceOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlaceOrder(::grpc::ServerContext* context, ::lssdrpc::PlaceOrderRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::PlaceOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelOrder() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelOrder(::grpc::ServerContext* context, ::lssdrpc::CancelOrderRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::CancelOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeOrders() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SubscribeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeOrders(::grpc::ServerContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ServerAsyncWriter< ::lssdrpc::OrderUpdate>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeOwnOrders() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SubscribeOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OwnOrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeOwnOrders(::grpc::ServerContext* context, ::lssdrpc::SubscribeOrdersRequest* request, ::grpc::ServerAsyncWriter< ::lssdrpc::OwnOrderUpdate>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListOrders() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ListOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListOrders(::grpc::ServerContext* context, ::lssdrpc::ListOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::ListOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListOwnOrders() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListOwnOrders(::grpc::ServerContext* context, ::lssdrpc::ListOwnOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::ListOwnOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeOrderbookState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeOrderbookState() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SubscribeOrderbookState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrderbookState(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderbookState>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeOrderbookState(::grpc::ServerContext* context, ::lssdrpc::SubscribeOrderbookStateRequest* request, ::grpc::ServerAsyncWriter< ::lssdrpc::OrderbookState>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PlaceOrder<WithAsyncMethod_CancelOrder<WithAsyncMethod_SubscribeOrders<WithAsyncMethod_SubscribeOwnOrders<WithAsyncMethod_ListOrders<WithAsyncMethod_ListOwnOrders<WithAsyncMethod_SubscribeOrderbookState<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PlaceOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PlaceOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::PlaceOrderRequest, ::lssdrpc::PlaceOrderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::PlaceOrderRequest* request, ::lssdrpc::PlaceOrderResponse* response) { return this->PlaceOrder(context, request, response); }));}
    void SetMessageAllocatorFor_PlaceOrder(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::PlaceOrderRequest, ::lssdrpc::PlaceOrderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::PlaceOrderRequest, ::lssdrpc::PlaceOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PlaceOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaceOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PlaceOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PlaceOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CancelOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::CancelOrderRequest, ::lssdrpc::CancelOrderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::CancelOrderRequest* request, ::lssdrpc::CancelOrderResponse* response) { return this->CancelOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CancelOrder(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::CancelOrderRequest, ::lssdrpc::CancelOrderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::CancelOrderRequest, ::lssdrpc::CancelOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lssdrpc::SubscribeOrdersRequest, ::lssdrpc::OrderUpdate>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::SubscribeOrdersRequest* request) { return this->SubscribeOrders(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lssdrpc::OrderUpdate>* SubscribeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lssdrpc::OrderUpdate>* SubscribeOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeOwnOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lssdrpc::SubscribeOrdersRequest, ::lssdrpc::OwnOrderUpdate>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::SubscribeOrdersRequest* request) { return this->SubscribeOwnOrders(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OwnOrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lssdrpc::OwnOrderUpdate>* SubscribeOwnOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lssdrpc::OwnOrderUpdate>* SubscribeOwnOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::ListOrdersRequest, ::lssdrpc::ListOrdersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::ListOrdersRequest* request, ::lssdrpc::ListOrdersResponse* response) { return this->ListOrders(context, request, response); }));}
    void SetMessageAllocatorFor_ListOrders(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::ListOrdersRequest, ::lssdrpc::ListOrdersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::ListOrdersRequest, ::lssdrpc::ListOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListOwnOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::ListOwnOrdersRequest, ::lssdrpc::ListOwnOrdersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::ListOwnOrdersRequest* request, ::lssdrpc::ListOwnOrdersResponse* response) { return this->ListOwnOrders(context, request, response); }));}
    void SetMessageAllocatorFor_ListOwnOrders(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::ListOwnOrdersRequest, ::lssdrpc::ListOwnOrdersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::ListOwnOrdersRequest, ::lssdrpc::ListOwnOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListOwnOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListOwnOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeOrderbookState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeOrderbookState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lssdrpc::SubscribeOrderbookStateRequest, ::lssdrpc::OrderbookState>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::SubscribeOrderbookStateRequest* request) { return this->SubscribeOrderbookState(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeOrderbookState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrderbookState(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderbookState>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lssdrpc::OrderbookState>* SubscribeOrderbookState(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lssdrpc::OrderbookState>* SubscribeOrderbookState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_PlaceOrder<ExperimentalWithCallbackMethod_CancelOrder<ExperimentalWithCallbackMethod_SubscribeOrders<ExperimentalWithCallbackMethod_SubscribeOwnOrders<ExperimentalWithCallbackMethod_ListOrders<ExperimentalWithCallbackMethod_ListOwnOrders<ExperimentalWithCallbackMethod_SubscribeOrderbookState<Service > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_PlaceOrder<ExperimentalWithCallbackMethod_CancelOrder<ExperimentalWithCallbackMethod_SubscribeOrders<ExperimentalWithCallbackMethod_SubscribeOwnOrders<ExperimentalWithCallbackMethod_ListOrders<ExperimentalWithCallbackMethod_ListOwnOrders<ExperimentalWithCallbackMethod_SubscribeOrderbookState<Service > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PlaceOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlaceOrder() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PlaceOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaceOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelOrder() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeOrders() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SubscribeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeOwnOrders() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SubscribeOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OwnOrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListOrders() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ListOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListOwnOrders() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeOrderbookState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeOrderbookState() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SubscribeOrderbookState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrderbookState(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderbookState>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlaceOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlaceOrder() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PlaceOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaceOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlaceOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelOrder() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeOrders() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SubscribeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeOwnOrders() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SubscribeOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OwnOrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeOwnOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListOrders() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ListOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListOwnOrders() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ListOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListOwnOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeOrderbookState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeOrderbookState() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SubscribeOrderbookState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrderbookState(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderbookState>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeOrderbookState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PlaceOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PlaceOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlaceOrder(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PlaceOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaceOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PlaceOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PlaceOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CancelOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelOrder(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeOrders(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeOwnOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeOwnOrders(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OwnOrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeOwnOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeOwnOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListOrders(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListOwnOrders() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListOwnOrders(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListOwnOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListOwnOrders(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeOrderbookState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeOrderbookState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeOrderbookState(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeOrderbookState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeOrderbookState(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderbookState>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeOrderbookState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeOrderbookState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlaceOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlaceOrder() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::PlaceOrderRequest, ::lssdrpc::PlaceOrderResponse>(std::bind(&WithStreamedUnaryMethod_PlaceOrder<BaseClass>::StreamedPlaceOrder, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PlaceOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlaceOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::PlaceOrderRequest* /*request*/, ::lssdrpc::PlaceOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlaceOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::PlaceOrderRequest,::lssdrpc::PlaceOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelOrder() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::CancelOrderRequest, ::lssdrpc::CancelOrderResponse>(std::bind(&WithStreamedUnaryMethod_CancelOrder<BaseClass>::StreamedCancelOrder, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelOrder(::grpc::ServerContext* /*context*/, const ::lssdrpc::CancelOrderRequest* /*request*/, ::lssdrpc::CancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::CancelOrderRequest,::lssdrpc::CancelOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListOrders() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::ListOrdersRequest, ::lssdrpc::ListOrdersResponse>(std::bind(&WithStreamedUnaryMethod_ListOrders<BaseClass>::StreamedListOrders, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOrdersRequest* /*request*/, ::lssdrpc::ListOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::ListOrdersRequest,::lssdrpc::ListOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListOwnOrders() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::ListOwnOrdersRequest, ::lssdrpc::ListOwnOrdersResponse>(std::bind(&WithStreamedUnaryMethod_ListOwnOrders<BaseClass>::StreamedListOwnOrders, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::ListOwnOrdersRequest* /*request*/, ::lssdrpc::ListOwnOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListOwnOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::ListOwnOrdersRequest,::lssdrpc::ListOwnOrdersResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PlaceOrder<WithStreamedUnaryMethod_CancelOrder<WithStreamedUnaryMethod_ListOrders<WithStreamedUnaryMethod_ListOwnOrders<Service > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeOrders() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler< ::lssdrpc::SubscribeOrdersRequest, ::lssdrpc::OrderUpdate>(std::bind(&WithSplitStreamingMethod_SubscribeOrders<BaseClass>::StreamedSubscribeOrders, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeOrders(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lssdrpc::SubscribeOrdersRequest,::lssdrpc::OrderUpdate>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeOwnOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeOwnOrders() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler< ::lssdrpc::SubscribeOrdersRequest, ::lssdrpc::OwnOrderUpdate>(std::bind(&WithSplitStreamingMethod_SubscribeOwnOrders<BaseClass>::StreamedSubscribeOwnOrders, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeOwnOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeOwnOrders(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrdersRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OwnOrderUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeOwnOrders(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lssdrpc::SubscribeOrdersRequest,::lssdrpc::OwnOrderUpdate>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeOrderbookState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeOrderbookState() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler< ::lssdrpc::SubscribeOrderbookStateRequest, ::lssdrpc::OrderbookState>(std::bind(&WithSplitStreamingMethod_SubscribeOrderbookState<BaseClass>::StreamedSubscribeOrderbookState, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeOrderbookState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeOrderbookState(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeOrderbookStateRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::OrderbookState>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeOrderbookState(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lssdrpc::SubscribeOrderbookStateRequest,::lssdrpc::OrderbookState>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeOrders<WithSplitStreamingMethod_SubscribeOwnOrders<WithSplitStreamingMethod_SubscribeOrderbookState<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_PlaceOrder<WithStreamedUnaryMethod_CancelOrder<WithSplitStreamingMethod_SubscribeOrders<WithSplitStreamingMethod_SubscribeOwnOrders<WithStreamedUnaryMethod_ListOrders<WithStreamedUnaryMethod_ListOwnOrders<WithSplitStreamingMethod_SubscribeOrderbookState<Service > > > > > > > StreamedService;
};

// swaps
class swaps final {
 public:
  static constexpr char const* service_full_name() {
    return "lssdrpc.swaps";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::SwapResult>> SubscribeSwaps(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::lssdrpc::SwapResult>>(SubscribeSwapsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::SwapResult>> AsyncSubscribeSwaps(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::SwapResult>>(AsyncSubscribeSwapsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::SwapResult>> PrepareAsyncSubscribeSwaps(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::lssdrpc::SwapResult>>(PrepareAsyncSubscribeSwapsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeSwaps(::grpc::ClientContext* context, ::lssdrpc::SubscribeSwapsRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::SwapResult>* reactor) = 0;
      #else
      virtual void SubscribeSwaps(::grpc::ClientContext* context, ::lssdrpc::SubscribeSwapsRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::SwapResult>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::lssdrpc::SwapResult>* SubscribeSwapsRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::SwapResult>* AsyncSubscribeSwapsRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::lssdrpc::SwapResult>* PrepareAsyncSubscribeSwapsRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::SwapResult>> SubscribeSwaps(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::lssdrpc::SwapResult>>(SubscribeSwapsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::SwapResult>> AsyncSubscribeSwaps(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::SwapResult>>(AsyncSubscribeSwapsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::SwapResult>> PrepareAsyncSubscribeSwaps(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::lssdrpc::SwapResult>>(PrepareAsyncSubscribeSwapsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeSwaps(::grpc::ClientContext* context, ::lssdrpc::SubscribeSwapsRequest* request, ::grpc::ClientReadReactor< ::lssdrpc::SwapResult>* reactor) override;
      #else
      void SubscribeSwaps(::grpc::ClientContext* context, ::lssdrpc::SubscribeSwapsRequest* request, ::grpc::experimental::ClientReadReactor< ::lssdrpc::SwapResult>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::lssdrpc::SwapResult>* SubscribeSwapsRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::SwapResult>* AsyncSubscribeSwapsRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::lssdrpc::SwapResult>* PrepareAsyncSubscribeSwapsRaw(::grpc::ClientContext* context, const ::lssdrpc::SubscribeSwapsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeSwaps_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SubscribeSwaps(::grpc::ServerContext* context, const ::lssdrpc::SubscribeSwapsRequest* request, ::grpc::ServerWriter< ::lssdrpc::SwapResult>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeSwaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeSwaps() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SubscribeSwaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSwaps(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::SwapResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeSwaps(::grpc::ServerContext* context, ::lssdrpc::SubscribeSwapsRequest* request, ::grpc::ServerAsyncWriter< ::lssdrpc::SwapResult>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SubscribeSwaps<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeSwaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeSwaps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::lssdrpc::SubscribeSwapsRequest, ::lssdrpc::SwapResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::SubscribeSwapsRequest* request) { return this->SubscribeSwaps(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeSwaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSwaps(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::SwapResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::lssdrpc::SwapResult>* SubscribeSwaps(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::lssdrpc::SwapResult>* SubscribeSwaps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SubscribeSwaps<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SubscribeSwaps<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SubscribeSwaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeSwaps() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SubscribeSwaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSwaps(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::SwapResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeSwaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeSwaps() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SubscribeSwaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSwaps(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::SwapResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeSwaps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeSwaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeSwaps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeSwaps(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeSwaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSwaps(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::SwapResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeSwaps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeSwaps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  typedef Service StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeSwaps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeSwaps() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::lssdrpc::SubscribeSwapsRequest, ::lssdrpc::SwapResult>(std::bind(&WithSplitStreamingMethod_SubscribeSwaps<BaseClass>::StreamedSubscribeSwaps, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SubscribeSwaps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeSwaps(::grpc::ServerContext* /*context*/, const ::lssdrpc::SubscribeSwapsRequest* /*request*/, ::grpc::ServerWriter< ::lssdrpc::SwapResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeSwaps(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::lssdrpc::SubscribeSwapsRequest,::lssdrpc::SwapResult>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeSwaps<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_SubscribeSwaps<Service > StreamedService;
};

// renting
class renting final {
 public:
  static constexpr char const* service_full_name() {
    return "lssdrpc.renting";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GenerateInvoiceToRentChannelResponse>> AsyncGenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GenerateInvoiceToRentChannelResponse>>(AsyncGenerateRentChannelInvoiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GenerateInvoiceToRentChannelResponse>> PrepareAsyncGenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GenerateInvoiceToRentChannelResponse>>(PrepareAsyncGenerateRentChannelInvoiceRaw(context, request, cq));
    }
    virtual ::grpc::Status RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::lssdrpc::RentChannelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::RentChannelResponse>> AsyncRentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::RentChannelResponse>>(AsyncRentChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::RentChannelResponse>> PrepareAsyncRentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::RentChannelResponse>>(PrepareAsyncRentChannelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::lssdrpc::GetChannelStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetChannelStatusResponse>> AsyncGetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetChannelStatusResponse>>(AsyncGetChannelStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetChannelStatusResponse>> PrepareAsyncGetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetChannelStatusResponse>>(PrepareAsyncGetChannelStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::lssdrpc::GetFeeToRentChannelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetFeeToRentChannelResponse>> AsyncGetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetFeeToRentChannelResponse>>(AsyncGetFeeToRentChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetFeeToRentChannelResponse>> PrepareAsyncGetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetFeeToRentChannelResponse>>(PrepareAsyncGetFeeToRentChannelRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::RentChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::RentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::RentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetChannelStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetChannelStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChannelStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetChannelStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFeeToRentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetFeeToRentChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetFeeToRentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetFeeToRentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GenerateInvoiceToRentChannelResponse>* AsyncGenerateRentChannelInvoiceRaw(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GenerateInvoiceToRentChannelResponse>* PrepareAsyncGenerateRentChannelInvoiceRaw(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::RentChannelResponse>* AsyncRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::RentChannelResponse>* PrepareAsyncRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetChannelStatusResponse>* AsyncGetChannelStatusRaw(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetChannelStatusResponse>* PrepareAsyncGetChannelStatusRaw(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetFeeToRentChannelResponse>* AsyncGetFeeToRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lssdrpc::GetFeeToRentChannelResponse>* PrepareAsyncGetFeeToRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GenerateInvoiceToRentChannelResponse>> AsyncGenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GenerateInvoiceToRentChannelResponse>>(AsyncGenerateRentChannelInvoiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GenerateInvoiceToRentChannelResponse>> PrepareAsyncGenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GenerateInvoiceToRentChannelResponse>>(PrepareAsyncGenerateRentChannelInvoiceRaw(context, request, cq));
    }
    ::grpc::Status RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::lssdrpc::RentChannelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::RentChannelResponse>> AsyncRentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::RentChannelResponse>>(AsyncRentChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::RentChannelResponse>> PrepareAsyncRentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::RentChannelResponse>>(PrepareAsyncRentChannelRaw(context, request, cq));
    }
    ::grpc::Status GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::lssdrpc::GetChannelStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetChannelStatusResponse>> AsyncGetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetChannelStatusResponse>>(AsyncGetChannelStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetChannelStatusResponse>> PrepareAsyncGetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetChannelStatusResponse>>(PrepareAsyncGetChannelStatusRaw(context, request, cq));
    }
    ::grpc::Status GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::lssdrpc::GetFeeToRentChannelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetFeeToRentChannelResponse>> AsyncGetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetFeeToRentChannelResponse>>(AsyncGetFeeToRentChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetFeeToRentChannelResponse>> PrepareAsyncGetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetFeeToRentChannelResponse>>(PrepareAsyncGetFeeToRentChannelRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, std::function<void(::grpc::Status)>) override;
      void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GenerateRentChannelInvoice(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response, std::function<void(::grpc::Status)>) override;
      void RentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::RentChannelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RentChannel(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::RentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::RentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetChannelStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetChannelStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetChannelStatus(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChannelStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetChannelStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetChannelStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response, std::function<void(::grpc::Status)>) override;
      void GetFeeToRentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetFeeToRentChannelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetFeeToRentChannel(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetFeeToRentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetFeeToRentChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lssdrpc::GetFeeToRentChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GenerateInvoiceToRentChannelResponse>* AsyncGenerateRentChannelInvoiceRaw(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GenerateInvoiceToRentChannelResponse>* PrepareAsyncGenerateRentChannelInvoiceRaw(::grpc::ClientContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::RentChannelResponse>* AsyncRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::RentChannelResponse>* PrepareAsyncRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::RentChannelCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetChannelStatusResponse>* AsyncGetChannelStatusRaw(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetChannelStatusResponse>* PrepareAsyncGetChannelStatusRaw(::grpc::ClientContext* context, const ::lssdrpc::GetChannelStatusCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetFeeToRentChannelResponse>* AsyncGetFeeToRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lssdrpc::GetFeeToRentChannelResponse>* PrepareAsyncGetFeeToRentChannelRaw(::grpc::ClientContext* context, const ::lssdrpc::GetFeeToRentChannelCommand& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GenerateRentChannelInvoice_;
    const ::grpc::internal::RpcMethod rpcmethod_RentChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetChannelStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFeeToRentChannel_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GenerateRentChannelInvoice(::grpc::ServerContext* context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response);
    virtual ::grpc::Status RentChannel(::grpc::ServerContext* context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response);
    virtual ::grpc::Status GetChannelStatus(::grpc::ServerContext* context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response);
    virtual ::grpc::Status GetFeeToRentChannel(::grpc::ServerContext* context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GenerateRentChannelInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GenerateRentChannelInvoice() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GenerateRentChannelInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRentChannelInvoice(::grpc::ServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateRentChannelInvoice(::grpc::ServerContext* context, ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::GenerateInvoiceToRentChannelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RentChannel() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRentChannel(::grpc::ServerContext* context, ::lssdrpc::RentChannelCommand* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::RentChannelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetChannelStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetChannelStatus() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetChannelStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChannelStatus(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChannelStatus(::grpc::ServerContext* context, ::lssdrpc::GetChannelStatusCommand* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::GetChannelStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFeeToRentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFeeToRentChannel() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetFeeToRentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFeeToRentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFeeToRentChannel(::grpc::ServerContext* context, ::lssdrpc::GetFeeToRentChannelCommand* request, ::grpc::ServerAsyncResponseWriter< ::lssdrpc::GetFeeToRentChannelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GenerateRentChannelInvoice<WithAsyncMethod_RentChannel<WithAsyncMethod_GetChannelStatus<WithAsyncMethod_GetFeeToRentChannel<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GenerateRentChannelInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GenerateRentChannelInvoice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GenerateInvoiceToRentChannelCommand, ::lssdrpc::GenerateInvoiceToRentChannelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* request, ::lssdrpc::GenerateInvoiceToRentChannelResponse* response) { return this->GenerateRentChannelInvoice(context, request, response); }));}
    void SetMessageAllocatorFor_GenerateRentChannelInvoice(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::GenerateInvoiceToRentChannelCommand, ::lssdrpc::GenerateInvoiceToRentChannelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GenerateInvoiceToRentChannelCommand, ::lssdrpc::GenerateInvoiceToRentChannelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GenerateRentChannelInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRentChannelInvoice(::grpc::ServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GenerateRentChannelInvoice(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GenerateRentChannelInvoice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RentChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::RentChannelCommand, ::lssdrpc::RentChannelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::RentChannelCommand* request, ::lssdrpc::RentChannelResponse* response) { return this->RentChannel(context, request, response); }));}
    void SetMessageAllocatorFor_RentChannel(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::RentChannelCommand, ::lssdrpc::RentChannelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::RentChannelCommand, ::lssdrpc::RentChannelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RentChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RentChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetChannelStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetChannelStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetChannelStatusCommand, ::lssdrpc::GetChannelStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::GetChannelStatusCommand* request, ::lssdrpc::GetChannelStatusResponse* response) { return this->GetChannelStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetChannelStatus(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::GetChannelStatusCommand, ::lssdrpc::GetChannelStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetChannelStatusCommand, ::lssdrpc::GetChannelStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetChannelStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChannelStatus(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChannelStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChannelStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetFeeToRentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetFeeToRentChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetFeeToRentChannelCommand, ::lssdrpc::GetFeeToRentChannelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::lssdrpc::GetFeeToRentChannelCommand* request, ::lssdrpc::GetFeeToRentChannelResponse* response) { return this->GetFeeToRentChannel(context, request, response); }));}
    void SetMessageAllocatorFor_GetFeeToRentChannel(
        ::grpc::experimental::MessageAllocator< ::lssdrpc::GetFeeToRentChannelCommand, ::lssdrpc::GetFeeToRentChannelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::lssdrpc::GetFeeToRentChannelCommand, ::lssdrpc::GetFeeToRentChannelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetFeeToRentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFeeToRentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetFeeToRentChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetFeeToRentChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GenerateRentChannelInvoice<ExperimentalWithCallbackMethod_RentChannel<ExperimentalWithCallbackMethod_GetChannelStatus<ExperimentalWithCallbackMethod_GetFeeToRentChannel<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GenerateRentChannelInvoice<ExperimentalWithCallbackMethod_RentChannel<ExperimentalWithCallbackMethod_GetChannelStatus<ExperimentalWithCallbackMethod_GetFeeToRentChannel<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GenerateRentChannelInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GenerateRentChannelInvoice() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GenerateRentChannelInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRentChannelInvoice(::grpc::ServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RentChannel() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetChannelStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetChannelStatus() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetChannelStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChannelStatus(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFeeToRentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFeeToRentChannel() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetFeeToRentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFeeToRentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GenerateRentChannelInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GenerateRentChannelInvoice() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GenerateRentChannelInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRentChannelInvoice(::grpc::ServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateRentChannelInvoice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RentChannel() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_RentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRentChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetChannelStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetChannelStatus() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetChannelStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChannelStatus(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChannelStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFeeToRentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFeeToRentChannel() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetFeeToRentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFeeToRentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFeeToRentChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GenerateRentChannelInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GenerateRentChannelInvoice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GenerateRentChannelInvoice(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GenerateRentChannelInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRentChannelInvoice(::grpc::ServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GenerateRentChannelInvoice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GenerateRentChannelInvoice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RentChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RentChannel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RentChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RentChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetChannelStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetChannelStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetChannelStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetChannelStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChannelStatus(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChannelStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChannelStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetFeeToRentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetFeeToRentChannel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFeeToRentChannel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetFeeToRentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFeeToRentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetFeeToRentChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetFeeToRentChannel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GenerateRentChannelInvoice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GenerateRentChannelInvoice() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::GenerateInvoiceToRentChannelCommand, ::lssdrpc::GenerateInvoiceToRentChannelResponse>(std::bind(&WithStreamedUnaryMethod_GenerateRentChannelInvoice<BaseClass>::StreamedGenerateRentChannelInvoice, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GenerateRentChannelInvoice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GenerateRentChannelInvoice(::grpc::ServerContext* /*context*/, const ::lssdrpc::GenerateInvoiceToRentChannelCommand* /*request*/, ::lssdrpc::GenerateInvoiceToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGenerateRentChannelInvoice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::GenerateInvoiceToRentChannelCommand,::lssdrpc::GenerateInvoiceToRentChannelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RentChannel() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::RentChannelCommand, ::lssdrpc::RentChannelResponse>(std::bind(&WithStreamedUnaryMethod_RentChannel<BaseClass>::StreamedRentChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::RentChannelCommand* /*request*/, ::lssdrpc::RentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRentChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::RentChannelCommand,::lssdrpc::RentChannelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetChannelStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetChannelStatus() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::GetChannelStatusCommand, ::lssdrpc::GetChannelStatusResponse>(std::bind(&WithStreamedUnaryMethod_GetChannelStatus<BaseClass>::StreamedGetChannelStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetChannelStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetChannelStatus(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetChannelStatusCommand* /*request*/, ::lssdrpc::GetChannelStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetChannelStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::GetChannelStatusCommand,::lssdrpc::GetChannelStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFeeToRentChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFeeToRentChannel() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::lssdrpc::GetFeeToRentChannelCommand, ::lssdrpc::GetFeeToRentChannelResponse>(std::bind(&WithStreamedUnaryMethod_GetFeeToRentChannel<BaseClass>::StreamedGetFeeToRentChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetFeeToRentChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFeeToRentChannel(::grpc::ServerContext* /*context*/, const ::lssdrpc::GetFeeToRentChannelCommand* /*request*/, ::lssdrpc::GetFeeToRentChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFeeToRentChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lssdrpc::GetFeeToRentChannelCommand,::lssdrpc::GetFeeToRentChannelResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GenerateRentChannelInvoice<WithStreamedUnaryMethod_RentChannel<WithStreamedUnaryMethod_GetChannelStatus<WithStreamedUnaryMethod_GetFeeToRentChannel<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GenerateRentChannelInvoice<WithStreamedUnaryMethod_RentChannel<WithStreamedUnaryMethod_GetChannelStatus<WithStreamedUnaryMethod_GetFeeToRentChannel<Service > > > > StreamedService;
};

}  // namespace lssdrpc


#endif  // GRPC_lssdrpc_2eproto__INCLUDED
