// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stakenet/orderbook/events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_stakenet_2forderbook_2fevents_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_stakenet_2forderbook_2fevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "models.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_stakenet_2forderbook_2fevents_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_stakenet_2forderbook_2fevents_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_stakenet_2forderbook_2fevents_2eproto;
namespace io {
namespace stakenet {
namespace orderbook {
namespace protos {
class MaintenanceCompleted;
class MaintenanceCompletedDefaultTypeInternal;
extern MaintenanceCompletedDefaultTypeInternal _MaintenanceCompleted_default_instance_;
class MaintenanceInProgress;
class MaintenanceInProgressDefaultTypeInternal;
extern MaintenanceInProgressDefaultTypeInternal _MaintenanceInProgress_default_instance_;
class MyMatchedOrderCanceled;
class MyMatchedOrderCanceledDefaultTypeInternal;
extern MyMatchedOrderCanceledDefaultTypeInternal _MyMatchedOrderCanceled_default_instance_;
class MyOrderMatched;
class MyOrderMatchedDefaultTypeInternal;
extern MyOrderMatchedDefaultTypeInternal _MyOrderMatched_default_instance_;
class NewOrderMessage;
class NewOrderMessageDefaultTypeInternal;
extern NewOrderMessageDefaultTypeInternal _NewOrderMessage_default_instance_;
class OrderCanceled;
class OrderCanceledDefaultTypeInternal;
extern OrderCanceledDefaultTypeInternal _OrderCanceled_default_instance_;
class OrderPlaced;
class OrderPlacedDefaultTypeInternal;
extern OrderPlacedDefaultTypeInternal _OrderPlaced_default_instance_;
class OrdersMatched;
class OrdersMatchedDefaultTypeInternal;
extern OrdersMatchedDefaultTypeInternal _OrdersMatched_default_instance_;
class RentedChannelEvent;
class RentedChannelEventDefaultTypeInternal;
extern RentedChannelEventDefaultTypeInternal _RentedChannelEvent_default_instance_;
class RentedChannelEvent_ChannelClosed;
class RentedChannelEvent_ChannelClosedDefaultTypeInternal;
extern RentedChannelEvent_ChannelClosedDefaultTypeInternal _RentedChannelEvent_ChannelClosed_default_instance_;
class RentedChannelEvent_ChannelExpiringSoon;
class RentedChannelEvent_ChannelExpiringSoonDefaultTypeInternal;
extern RentedChannelEvent_ChannelExpiringSoonDefaultTypeInternal _RentedChannelEvent_ChannelExpiringSoon_default_instance_;
class RentedChannelEvent_ChannelOpened;
class RentedChannelEvent_ChannelOpenedDefaultTypeInternal;
extern RentedChannelEvent_ChannelOpenedDefaultTypeInternal _RentedChannelEvent_ChannelOpened_default_instance_;
class SwapFailure;
class SwapFailureDefaultTypeInternal;
extern SwapFailureDefaultTypeInternal _SwapFailure_default_instance_;
class SwapSuccess;
class SwapSuccessDefaultTypeInternal;
extern SwapSuccessDefaultTypeInternal _SwapSuccess_default_instance_;
}  // namespace protos
}  // namespace orderbook
}  // namespace stakenet
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::stakenet::orderbook::protos::MaintenanceCompleted* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::MaintenanceCompleted>(Arena*);
template<> ::io::stakenet::orderbook::protos::MaintenanceInProgress* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::MaintenanceInProgress>(Arena*);
template<> ::io::stakenet::orderbook::protos::MyMatchedOrderCanceled* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::MyMatchedOrderCanceled>(Arena*);
template<> ::io::stakenet::orderbook::protos::MyOrderMatched* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::MyOrderMatched>(Arena*);
template<> ::io::stakenet::orderbook::protos::NewOrderMessage* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::NewOrderMessage>(Arena*);
template<> ::io::stakenet::orderbook::protos::OrderCanceled* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::OrderCanceled>(Arena*);
template<> ::io::stakenet::orderbook::protos::OrderPlaced* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::OrderPlaced>(Arena*);
template<> ::io::stakenet::orderbook::protos::OrdersMatched* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::OrdersMatched>(Arena*);
template<> ::io::stakenet::orderbook::protos::RentedChannelEvent* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::RentedChannelEvent>(Arena*);
template<> ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed>(Arena*);
template<> ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon>(Arena*);
template<> ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened>(Arena*);
template<> ::io::stakenet::orderbook::protos::SwapFailure* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::SwapFailure>(Arena*);
template<> ::io::stakenet::orderbook::protos::SwapSuccess* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::SwapSuccess>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace stakenet {
namespace orderbook {
namespace protos {

// ===================================================================

class MyOrderMatched :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.MyOrderMatched) */ {
 public:
  MyOrderMatched();
  virtual ~MyOrderMatched();

  MyOrderMatched(const MyOrderMatched& from);
  MyOrderMatched(MyOrderMatched&& from) noexcept
    : MyOrderMatched() {
    *this = ::std::move(from);
  }

  inline MyOrderMatched& operator=(const MyOrderMatched& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyOrderMatched& operator=(MyOrderMatched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MyOrderMatched& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyOrderMatched* internal_default_instance() {
    return reinterpret_cast<const MyOrderMatched*>(
               &_MyOrderMatched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MyOrderMatched& a, MyOrderMatched& b) {
    a.Swap(&b);
  }
  inline void Swap(MyOrderMatched* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MyOrderMatched* New() const final {
    return CreateMaybeMessage<MyOrderMatched>(nullptr);
  }

  MyOrderMatched* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MyOrderMatched>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MyOrderMatched& from);
  void MergeFrom(const MyOrderMatched& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyOrderMatched* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.MyOrderMatched";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradeFieldNumber = 1,
    kOrderMatchedWithFieldNumber = 2,
  };
  // .io.stakenet.orderbook.protos.Trade trade = 1;
  bool has_trade() const;
  private:
  bool _internal_has_trade() const;
  public:
  void clear_trade();
  const ::io::stakenet::orderbook::protos::Trade& trade() const;
  ::io::stakenet::orderbook::protos::Trade* release_trade();
  ::io::stakenet::orderbook::protos::Trade* mutable_trade();
  void set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade);
  private:
  const ::io::stakenet::orderbook::protos::Trade& _internal_trade() const;
  ::io::stakenet::orderbook::protos::Trade* _internal_mutable_trade();
  public:

  // .io.stakenet.orderbook.protos.Order orderMatchedWith = 2;
  bool has_ordermatchedwith() const;
  private:
  bool _internal_has_ordermatchedwith() const;
  public:
  void clear_ordermatchedwith();
  const ::io::stakenet::orderbook::protos::Order& ordermatchedwith() const;
  ::io::stakenet::orderbook::protos::Order* release_ordermatchedwith();
  ::io::stakenet::orderbook::protos::Order* mutable_ordermatchedwith();
  void set_allocated_ordermatchedwith(::io::stakenet::orderbook::protos::Order* ordermatchedwith);
  private:
  const ::io::stakenet::orderbook::protos::Order& _internal_ordermatchedwith() const;
  ::io::stakenet::orderbook::protos::Order* _internal_mutable_ordermatchedwith();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.MyOrderMatched)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::io::stakenet::orderbook::protos::Trade* trade_;
  ::io::stakenet::orderbook::protos::Order* ordermatchedwith_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class MyMatchedOrderCanceled :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.MyMatchedOrderCanceled) */ {
 public:
  MyMatchedOrderCanceled();
  virtual ~MyMatchedOrderCanceled();

  MyMatchedOrderCanceled(const MyMatchedOrderCanceled& from);
  MyMatchedOrderCanceled(MyMatchedOrderCanceled&& from) noexcept
    : MyMatchedOrderCanceled() {
    *this = ::std::move(from);
  }

  inline MyMatchedOrderCanceled& operator=(const MyMatchedOrderCanceled& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyMatchedOrderCanceled& operator=(MyMatchedOrderCanceled&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MyMatchedOrderCanceled& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyMatchedOrderCanceled* internal_default_instance() {
    return reinterpret_cast<const MyMatchedOrderCanceled*>(
               &_MyMatchedOrderCanceled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MyMatchedOrderCanceled& a, MyMatchedOrderCanceled& b) {
    a.Swap(&b);
  }
  inline void Swap(MyMatchedOrderCanceled* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MyMatchedOrderCanceled* New() const final {
    return CreateMaybeMessage<MyMatchedOrderCanceled>(nullptr);
  }

  MyMatchedOrderCanceled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MyMatchedOrderCanceled>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MyMatchedOrderCanceled& from);
  void MergeFrom(const MyMatchedOrderCanceled& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyMatchedOrderCanceled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.MyMatchedOrderCanceled";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradeFieldNumber = 1,
  };
  // .io.stakenet.orderbook.protos.Trade trade = 1;
  bool has_trade() const;
  private:
  bool _internal_has_trade() const;
  public:
  void clear_trade();
  const ::io::stakenet::orderbook::protos::Trade& trade() const;
  ::io::stakenet::orderbook::protos::Trade* release_trade();
  ::io::stakenet::orderbook::protos::Trade* mutable_trade();
  void set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade);
  private:
  const ::io::stakenet::orderbook::protos::Trade& _internal_trade() const;
  ::io::stakenet::orderbook::protos::Trade* _internal_mutable_trade();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.MyMatchedOrderCanceled)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::io::stakenet::orderbook::protos::Trade* trade_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class OrderPlaced :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.OrderPlaced) */ {
 public:
  OrderPlaced();
  virtual ~OrderPlaced();

  OrderPlaced(const OrderPlaced& from);
  OrderPlaced(OrderPlaced&& from) noexcept
    : OrderPlaced() {
    *this = ::std::move(from);
  }

  inline OrderPlaced& operator=(const OrderPlaced& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderPlaced& operator=(OrderPlaced&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderPlaced& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderPlaced* internal_default_instance() {
    return reinterpret_cast<const OrderPlaced*>(
               &_OrderPlaced_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrderPlaced& a, OrderPlaced& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderPlaced* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderPlaced* New() const final {
    return CreateMaybeMessage<OrderPlaced>(nullptr);
  }

  OrderPlaced* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderPlaced>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderPlaced& from);
  void MergeFrom(const OrderPlaced& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderPlaced* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.OrderPlaced";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradingPairFieldNumber = 2,
    kOrderFieldNumber = 1,
  };
  // string tradingPair = 2;
  void clear_tradingpair();
  const std::string& tradingpair() const;
  void set_tradingpair(const std::string& value);
  void set_tradingpair(std::string&& value);
  void set_tradingpair(const char* value);
  void set_tradingpair(const char* value, size_t size);
  std::string* mutable_tradingpair();
  std::string* release_tradingpair();
  void set_allocated_tradingpair(std::string* tradingpair);
  private:
  const std::string& _internal_tradingpair() const;
  void _internal_set_tradingpair(const std::string& value);
  std::string* _internal_mutable_tradingpair();
  public:

  // .io.stakenet.orderbook.protos.Order order = 1;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::io::stakenet::orderbook::protos::Order& order() const;
  ::io::stakenet::orderbook::protos::Order* release_order();
  ::io::stakenet::orderbook::protos::Order* mutable_order();
  void set_allocated_order(::io::stakenet::orderbook::protos::Order* order);
  private:
  const ::io::stakenet::orderbook::protos::Order& _internal_order() const;
  ::io::stakenet::orderbook::protos::Order* _internal_mutable_order();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.OrderPlaced)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingpair_;
  ::io::stakenet::orderbook::protos::Order* order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class OrderCanceled :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.OrderCanceled) */ {
 public:
  OrderCanceled();
  virtual ~OrderCanceled();

  OrderCanceled(const OrderCanceled& from);
  OrderCanceled(OrderCanceled&& from) noexcept
    : OrderCanceled() {
    *this = ::std::move(from);
  }

  inline OrderCanceled& operator=(const OrderCanceled& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderCanceled& operator=(OrderCanceled&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderCanceled& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderCanceled* internal_default_instance() {
    return reinterpret_cast<const OrderCanceled*>(
               &_OrderCanceled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OrderCanceled& a, OrderCanceled& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderCanceled* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderCanceled* New() const final {
    return CreateMaybeMessage<OrderCanceled>(nullptr);
  }

  OrderCanceled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderCanceled>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderCanceled& from);
  void MergeFrom(const OrderCanceled& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderCanceled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.OrderCanceled";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kTradingPairFieldNumber = 2,
    kOrderFieldNumber = 3,
  };
  // string orderId = 1;
  void clear_orderid();
  const std::string& orderid() const;
  void set_orderid(const std::string& value);
  void set_orderid(std::string&& value);
  void set_orderid(const char* value);
  void set_orderid(const char* value, size_t size);
  std::string* mutable_orderid();
  std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // string tradingPair = 2;
  void clear_tradingpair();
  const std::string& tradingpair() const;
  void set_tradingpair(const std::string& value);
  void set_tradingpair(std::string&& value);
  void set_tradingpair(const char* value);
  void set_tradingpair(const char* value, size_t size);
  std::string* mutable_tradingpair();
  std::string* release_tradingpair();
  void set_allocated_tradingpair(std::string* tradingpair);
  private:
  const std::string& _internal_tradingpair() const;
  void _internal_set_tradingpair(const std::string& value);
  std::string* _internal_mutable_tradingpair();
  public:

  // .io.stakenet.orderbook.protos.Order order = 3;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::io::stakenet::orderbook::protos::Order& order() const;
  ::io::stakenet::orderbook::protos::Order* release_order();
  ::io::stakenet::orderbook::protos::Order* mutable_order();
  void set_allocated_order(::io::stakenet::orderbook::protos::Order* order);
  private:
  const ::io::stakenet::orderbook::protos::Order& _internal_order() const;
  ::io::stakenet::orderbook::protos::Order* _internal_mutable_order();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.OrderCanceled)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingpair_;
  ::io::stakenet::orderbook::protos::Order* order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class OrdersMatched :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.OrdersMatched) */ {
 public:
  OrdersMatched();
  virtual ~OrdersMatched();

  OrdersMatched(const OrdersMatched& from);
  OrdersMatched(OrdersMatched&& from) noexcept
    : OrdersMatched() {
    *this = ::std::move(from);
  }

  inline OrdersMatched& operator=(const OrdersMatched& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersMatched& operator=(OrdersMatched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrdersMatched& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrdersMatched* internal_default_instance() {
    return reinterpret_cast<const OrdersMatched*>(
               &_OrdersMatched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OrdersMatched& a, OrdersMatched& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersMatched* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrdersMatched* New() const final {
    return CreateMaybeMessage<OrdersMatched>(nullptr);
  }

  OrdersMatched* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrdersMatched>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrdersMatched& from);
  void MergeFrom(const OrdersMatched& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersMatched* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.OrdersMatched";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradingPairFieldNumber = 2,
    kTradeFieldNumber = 1,
  };
  // string tradingPair = 2;
  void clear_tradingpair();
  const std::string& tradingpair() const;
  void set_tradingpair(const std::string& value);
  void set_tradingpair(std::string&& value);
  void set_tradingpair(const char* value);
  void set_tradingpair(const char* value, size_t size);
  std::string* mutable_tradingpair();
  std::string* release_tradingpair();
  void set_allocated_tradingpair(std::string* tradingpair);
  private:
  const std::string& _internal_tradingpair() const;
  void _internal_set_tradingpair(const std::string& value);
  std::string* _internal_mutable_tradingpair();
  public:

  // .io.stakenet.orderbook.protos.Trade trade = 1;
  bool has_trade() const;
  private:
  bool _internal_has_trade() const;
  public:
  void clear_trade();
  const ::io::stakenet::orderbook::protos::Trade& trade() const;
  ::io::stakenet::orderbook::protos::Trade* release_trade();
  ::io::stakenet::orderbook::protos::Trade* mutable_trade();
  void set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade);
  private:
  const ::io::stakenet::orderbook::protos::Trade& _internal_trade() const;
  ::io::stakenet::orderbook::protos::Trade* _internal_mutable_trade();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.OrdersMatched)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingpair_;
  ::io::stakenet::orderbook::protos::Trade* trade_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class NewOrderMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.NewOrderMessage) */ {
 public:
  NewOrderMessage();
  virtual ~NewOrderMessage();

  NewOrderMessage(const NewOrderMessage& from);
  NewOrderMessage(NewOrderMessage&& from) noexcept
    : NewOrderMessage() {
    *this = ::std::move(from);
  }

  inline NewOrderMessage& operator=(const NewOrderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewOrderMessage& operator=(NewOrderMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewOrderMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewOrderMessage* internal_default_instance() {
    return reinterpret_cast<const NewOrderMessage*>(
               &_NewOrderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NewOrderMessage& a, NewOrderMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NewOrderMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewOrderMessage* New() const final {
    return CreateMaybeMessage<NewOrderMessage>(nullptr);
  }

  NewOrderMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewOrderMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewOrderMessage& from);
  void MergeFrom(const NewOrderMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrderMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.NewOrderMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string orderId = 1;
  void clear_orderid();
  const std::string& orderid() const;
  void set_orderid(const std::string& value);
  void set_orderid(std::string&& value);
  void set_orderid(const char* value);
  void set_orderid(const char* value, size_t size);
  std::string* mutable_orderid();
  std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // bytes message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.NewOrderMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class SwapSuccess :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.SwapSuccess) */ {
 public:
  SwapSuccess();
  virtual ~SwapSuccess();

  SwapSuccess(const SwapSuccess& from);
  SwapSuccess(SwapSuccess&& from) noexcept
    : SwapSuccess() {
    *this = ::std::move(from);
  }

  inline SwapSuccess& operator=(const SwapSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapSuccess& operator=(SwapSuccess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwapSuccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapSuccess* internal_default_instance() {
    return reinterpret_cast<const SwapSuccess*>(
               &_SwapSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SwapSuccess& a, SwapSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapSuccess* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapSuccess* New() const final {
    return CreateMaybeMessage<SwapSuccess>(nullptr);
  }

  SwapSuccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapSuccess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwapSuccess& from);
  void MergeFrom(const SwapSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapSuccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.SwapSuccess";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradingPairFieldNumber = 2,
    kTradeFieldNumber = 1,
  };
  // string tradingPair = 2;
  void clear_tradingpair();
  const std::string& tradingpair() const;
  void set_tradingpair(const std::string& value);
  void set_tradingpair(std::string&& value);
  void set_tradingpair(const char* value);
  void set_tradingpair(const char* value, size_t size);
  std::string* mutable_tradingpair();
  std::string* release_tradingpair();
  void set_allocated_tradingpair(std::string* tradingpair);
  private:
  const std::string& _internal_tradingpair() const;
  void _internal_set_tradingpair(const std::string& value);
  std::string* _internal_mutable_tradingpair();
  public:

  // .io.stakenet.orderbook.protos.Trade trade = 1;
  bool has_trade() const;
  private:
  bool _internal_has_trade() const;
  public:
  void clear_trade();
  const ::io::stakenet::orderbook::protos::Trade& trade() const;
  ::io::stakenet::orderbook::protos::Trade* release_trade();
  ::io::stakenet::orderbook::protos::Trade* mutable_trade();
  void set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade);
  private:
  const ::io::stakenet::orderbook::protos::Trade& _internal_trade() const;
  ::io::stakenet::orderbook::protos::Trade* _internal_mutable_trade();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.SwapSuccess)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingpair_;
  ::io::stakenet::orderbook::protos::Trade* trade_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class SwapFailure :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.SwapFailure) */ {
 public:
  SwapFailure();
  virtual ~SwapFailure();

  SwapFailure(const SwapFailure& from);
  SwapFailure(SwapFailure&& from) noexcept
    : SwapFailure() {
    *this = ::std::move(from);
  }

  inline SwapFailure& operator=(const SwapFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapFailure& operator=(SwapFailure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwapFailure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapFailure* internal_default_instance() {
    return reinterpret_cast<const SwapFailure*>(
               &_SwapFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SwapFailure& a, SwapFailure& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapFailure* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapFailure* New() const final {
    return CreateMaybeMessage<SwapFailure>(nullptr);
  }

  SwapFailure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapFailure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwapFailure& from);
  void MergeFrom(const SwapFailure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapFailure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.SwapFailure";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradingPairFieldNumber = 2,
    kTradeFieldNumber = 1,
  };
  // string tradingPair = 2;
  void clear_tradingpair();
  const std::string& tradingpair() const;
  void set_tradingpair(const std::string& value);
  void set_tradingpair(std::string&& value);
  void set_tradingpair(const char* value);
  void set_tradingpair(const char* value, size_t size);
  std::string* mutable_tradingpair();
  std::string* release_tradingpair();
  void set_allocated_tradingpair(std::string* tradingpair);
  private:
  const std::string& _internal_tradingpair() const;
  void _internal_set_tradingpair(const std::string& value);
  std::string* _internal_mutable_tradingpair();
  public:

  // .io.stakenet.orderbook.protos.Trade trade = 1;
  bool has_trade() const;
  private:
  bool _internal_has_trade() const;
  public:
  void clear_trade();
  const ::io::stakenet::orderbook::protos::Trade& trade() const;
  ::io::stakenet::orderbook::protos::Trade* release_trade();
  ::io::stakenet::orderbook::protos::Trade* mutable_trade();
  void set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade);
  private:
  const ::io::stakenet::orderbook::protos::Trade& _internal_trade() const;
  ::io::stakenet::orderbook::protos::Trade* _internal_mutable_trade();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.SwapFailure)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingpair_;
  ::io::stakenet::orderbook::protos::Trade* trade_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class RentedChannelEvent_ChannelOpened :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened) */ {
 public:
  RentedChannelEvent_ChannelOpened();
  virtual ~RentedChannelEvent_ChannelOpened();

  RentedChannelEvent_ChannelOpened(const RentedChannelEvent_ChannelOpened& from);
  RentedChannelEvent_ChannelOpened(RentedChannelEvent_ChannelOpened&& from) noexcept
    : RentedChannelEvent_ChannelOpened() {
    *this = ::std::move(from);
  }

  inline RentedChannelEvent_ChannelOpened& operator=(const RentedChannelEvent_ChannelOpened& from) {
    CopyFrom(from);
    return *this;
  }
  inline RentedChannelEvent_ChannelOpened& operator=(RentedChannelEvent_ChannelOpened&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RentedChannelEvent_ChannelOpened& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RentedChannelEvent_ChannelOpened* internal_default_instance() {
    return reinterpret_cast<const RentedChannelEvent_ChannelOpened*>(
               &_RentedChannelEvent_ChannelOpened_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RentedChannelEvent_ChannelOpened& a, RentedChannelEvent_ChannelOpened& b) {
    a.Swap(&b);
  }
  inline void Swap(RentedChannelEvent_ChannelOpened* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RentedChannelEvent_ChannelOpened* New() const final {
    return CreateMaybeMessage<RentedChannelEvent_ChannelOpened>(nullptr);
  }

  RentedChannelEvent_ChannelOpened* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RentedChannelEvent_ChannelOpened>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RentedChannelEvent_ChannelOpened& from);
  void MergeFrom(const RentedChannelEvent_ChannelOpened& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RentedChannelEvent_ChannelOpened* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kExpiresOnFieldNumber = 2,
    kOpenedOnFieldNumber = 3,
  };
  // string channelId = 1;
  void clear_channelid();
  const std::string& channelid() const;
  void set_channelid(const std::string& value);
  void set_channelid(std::string&& value);
  void set_channelid(const char* value);
  void set_channelid(const char* value, size_t size);
  std::string* mutable_channelid();
  std::string* release_channelid();
  void set_allocated_channelid(std::string* channelid);
  private:
  const std::string& _internal_channelid() const;
  void _internal_set_channelid(const std::string& value);
  std::string* _internal_mutable_channelid();
  public:

  // int64 expiresOn = 2;
  void clear_expireson();
  ::PROTOBUF_NAMESPACE_ID::int64 expireson() const;
  void set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_expireson() const;
  void _internal_set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 openedOn = 3;
  void clear_openedon();
  ::PROTOBUF_NAMESPACE_ID::int64 openedon() const;
  void set_openedon(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_openedon() const;
  void _internal_set_openedon(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channelid_;
  ::PROTOBUF_NAMESPACE_ID::int64 expireson_;
  ::PROTOBUF_NAMESPACE_ID::int64 openedon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class RentedChannelEvent_ChannelExpiringSoon :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon) */ {
 public:
  RentedChannelEvent_ChannelExpiringSoon();
  virtual ~RentedChannelEvent_ChannelExpiringSoon();

  RentedChannelEvent_ChannelExpiringSoon(const RentedChannelEvent_ChannelExpiringSoon& from);
  RentedChannelEvent_ChannelExpiringSoon(RentedChannelEvent_ChannelExpiringSoon&& from) noexcept
    : RentedChannelEvent_ChannelExpiringSoon() {
    *this = ::std::move(from);
  }

  inline RentedChannelEvent_ChannelExpiringSoon& operator=(const RentedChannelEvent_ChannelExpiringSoon& from) {
    CopyFrom(from);
    return *this;
  }
  inline RentedChannelEvent_ChannelExpiringSoon& operator=(RentedChannelEvent_ChannelExpiringSoon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RentedChannelEvent_ChannelExpiringSoon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RentedChannelEvent_ChannelExpiringSoon* internal_default_instance() {
    return reinterpret_cast<const RentedChannelEvent_ChannelExpiringSoon*>(
               &_RentedChannelEvent_ChannelExpiringSoon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RentedChannelEvent_ChannelExpiringSoon& a, RentedChannelEvent_ChannelExpiringSoon& b) {
    a.Swap(&b);
  }
  inline void Swap(RentedChannelEvent_ChannelExpiringSoon* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RentedChannelEvent_ChannelExpiringSoon* New() const final {
    return CreateMaybeMessage<RentedChannelEvent_ChannelExpiringSoon>(nullptr);
  }

  RentedChannelEvent_ChannelExpiringSoon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RentedChannelEvent_ChannelExpiringSoon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RentedChannelEvent_ChannelExpiringSoon& from);
  void MergeFrom(const RentedChannelEvent_ChannelExpiringSoon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RentedChannelEvent_ChannelExpiringSoon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kExpiresOnFieldNumber = 2,
  };
  // string channelId = 1;
  void clear_channelid();
  const std::string& channelid() const;
  void set_channelid(const std::string& value);
  void set_channelid(std::string&& value);
  void set_channelid(const char* value);
  void set_channelid(const char* value, size_t size);
  std::string* mutable_channelid();
  std::string* release_channelid();
  void set_allocated_channelid(std::string* channelid);
  private:
  const std::string& _internal_channelid() const;
  void _internal_set_channelid(const std::string& value);
  std::string* _internal_mutable_channelid();
  public:

  // int64 expiresOn = 2;
  void clear_expireson();
  ::PROTOBUF_NAMESPACE_ID::int64 expireson() const;
  void set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_expireson() const;
  void _internal_set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channelid_;
  ::PROTOBUF_NAMESPACE_ID::int64 expireson_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class RentedChannelEvent_ChannelClosed :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed) */ {
 public:
  RentedChannelEvent_ChannelClosed();
  virtual ~RentedChannelEvent_ChannelClosed();

  RentedChannelEvent_ChannelClosed(const RentedChannelEvent_ChannelClosed& from);
  RentedChannelEvent_ChannelClosed(RentedChannelEvent_ChannelClosed&& from) noexcept
    : RentedChannelEvent_ChannelClosed() {
    *this = ::std::move(from);
  }

  inline RentedChannelEvent_ChannelClosed& operator=(const RentedChannelEvent_ChannelClosed& from) {
    CopyFrom(from);
    return *this;
  }
  inline RentedChannelEvent_ChannelClosed& operator=(RentedChannelEvent_ChannelClosed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RentedChannelEvent_ChannelClosed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RentedChannelEvent_ChannelClosed* internal_default_instance() {
    return reinterpret_cast<const RentedChannelEvent_ChannelClosed*>(
               &_RentedChannelEvent_ChannelClosed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RentedChannelEvent_ChannelClosed& a, RentedChannelEvent_ChannelClosed& b) {
    a.Swap(&b);
  }
  inline void Swap(RentedChannelEvent_ChannelClosed* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RentedChannelEvent_ChannelClosed* New() const final {
    return CreateMaybeMessage<RentedChannelEvent_ChannelClosed>(nullptr);
  }

  RentedChannelEvent_ChannelClosed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RentedChannelEvent_ChannelClosed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RentedChannelEvent_ChannelClosed& from);
  void MergeFrom(const RentedChannelEvent_ChannelClosed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RentedChannelEvent_ChannelClosed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
  };
  // string channelId = 1;
  void clear_channelid();
  const std::string& channelid() const;
  void set_channelid(const std::string& value);
  void set_channelid(std::string&& value);
  void set_channelid(const char* value);
  void set_channelid(const char* value, size_t size);
  std::string* mutable_channelid();
  std::string* release_channelid();
  void set_allocated_channelid(std::string* channelid);
  private:
  const std::string& _internal_channelid() const;
  void _internal_set_channelid(const std::string& value);
  std::string* _internal_mutable_channelid();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channelid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class RentedChannelEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.RentedChannelEvent) */ {
 public:
  RentedChannelEvent();
  virtual ~RentedChannelEvent();

  RentedChannelEvent(const RentedChannelEvent& from);
  RentedChannelEvent(RentedChannelEvent&& from) noexcept
    : RentedChannelEvent() {
    *this = ::std::move(from);
  }

  inline RentedChannelEvent& operator=(const RentedChannelEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RentedChannelEvent& operator=(RentedChannelEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RentedChannelEvent& default_instance();

  enum ValueCase {
    kChannelOpened = 1,
    kChannelExpiringSoon = 2,
    kChannelClosed = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RentedChannelEvent* internal_default_instance() {
    return reinterpret_cast<const RentedChannelEvent*>(
               &_RentedChannelEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RentedChannelEvent& a, RentedChannelEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RentedChannelEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RentedChannelEvent* New() const final {
    return CreateMaybeMessage<RentedChannelEvent>(nullptr);
  }

  RentedChannelEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RentedChannelEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RentedChannelEvent& from);
  void MergeFrom(const RentedChannelEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RentedChannelEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.RentedChannelEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RentedChannelEvent_ChannelOpened ChannelOpened;
  typedef RentedChannelEvent_ChannelExpiringSoon ChannelExpiringSoon;
  typedef RentedChannelEvent_ChannelClosed ChannelClosed;

  // accessors -------------------------------------------------------

  enum : int {
    kChannelOpenedFieldNumber = 1,
    kChannelExpiringSoonFieldNumber = 2,
    kChannelClosedFieldNumber = 3,
  };
  // .io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened channelOpened = 1;
  bool has_channelopened() const;
  private:
  bool _internal_has_channelopened() const;
  public:
  void clear_channelopened();
  const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened& channelopened() const;
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* release_channelopened();
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* mutable_channelopened();
  void set_allocated_channelopened(::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* channelopened);
  private:
  const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened& _internal_channelopened() const;
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* _internal_mutable_channelopened();
  public:

  // .io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon channelExpiringSoon = 2;
  bool has_channelexpiringsoon() const;
  private:
  bool _internal_has_channelexpiringsoon() const;
  public:
  void clear_channelexpiringsoon();
  const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon& channelexpiringsoon() const;
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* release_channelexpiringsoon();
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* mutable_channelexpiringsoon();
  void set_allocated_channelexpiringsoon(::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* channelexpiringsoon);
  private:
  const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon& _internal_channelexpiringsoon() const;
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* _internal_mutable_channelexpiringsoon();
  public:

  // .io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed channelClosed = 3;
  bool has_channelclosed() const;
  private:
  bool _internal_has_channelclosed() const;
  public:
  void clear_channelclosed();
  const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed& channelclosed() const;
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* release_channelclosed();
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* mutable_channelclosed();
  void set_allocated_channelclosed(::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* channelclosed);
  private:
  const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed& _internal_channelclosed() const;
  ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* _internal_mutable_channelclosed();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.RentedChannelEvent)
 private:
  class _Internal;
  void set_has_channelopened();
  void set_has_channelexpiringsoon();
  void set_has_channelclosed();

  inline bool has_value() const;
  inline void clear_has_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* channelopened_;
    ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* channelexpiringsoon_;
    ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* channelclosed_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class MaintenanceInProgress :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.MaintenanceInProgress) */ {
 public:
  MaintenanceInProgress();
  virtual ~MaintenanceInProgress();

  MaintenanceInProgress(const MaintenanceInProgress& from);
  MaintenanceInProgress(MaintenanceInProgress&& from) noexcept
    : MaintenanceInProgress() {
    *this = ::std::move(from);
  }

  inline MaintenanceInProgress& operator=(const MaintenanceInProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaintenanceInProgress& operator=(MaintenanceInProgress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MaintenanceInProgress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MaintenanceInProgress* internal_default_instance() {
    return reinterpret_cast<const MaintenanceInProgress*>(
               &_MaintenanceInProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MaintenanceInProgress& a, MaintenanceInProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(MaintenanceInProgress* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaintenanceInProgress* New() const final {
    return CreateMaybeMessage<MaintenanceInProgress>(nullptr);
  }

  MaintenanceInProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaintenanceInProgress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaintenanceInProgress& from);
  void MergeFrom(const MaintenanceInProgress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaintenanceInProgress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.MaintenanceInProgress";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.MaintenanceInProgress)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// -------------------------------------------------------------------

class MaintenanceCompleted :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.MaintenanceCompleted) */ {
 public:
  MaintenanceCompleted();
  virtual ~MaintenanceCompleted();

  MaintenanceCompleted(const MaintenanceCompleted& from);
  MaintenanceCompleted(MaintenanceCompleted&& from) noexcept
    : MaintenanceCompleted() {
    *this = ::std::move(from);
  }

  inline MaintenanceCompleted& operator=(const MaintenanceCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaintenanceCompleted& operator=(MaintenanceCompleted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MaintenanceCompleted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MaintenanceCompleted* internal_default_instance() {
    return reinterpret_cast<const MaintenanceCompleted*>(
               &_MaintenanceCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MaintenanceCompleted& a, MaintenanceCompleted& b) {
    a.Swap(&b);
  }
  inline void Swap(MaintenanceCompleted* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaintenanceCompleted* New() const final {
    return CreateMaybeMessage<MaintenanceCompleted>(nullptr);
  }

  MaintenanceCompleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaintenanceCompleted>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaintenanceCompleted& from);
  void MergeFrom(const MaintenanceCompleted& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaintenanceCompleted* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.MaintenanceCompleted";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fevents_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fevents_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.MaintenanceCompleted)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MyOrderMatched

// .io.stakenet.orderbook.protos.Trade trade = 1;
inline bool MyOrderMatched::_internal_has_trade() const {
  return this != internal_default_instance() && trade_ != nullptr;
}
inline bool MyOrderMatched::has_trade() const {
  return _internal_has_trade();
}
inline const ::io::stakenet::orderbook::protos::Trade& MyOrderMatched::_internal_trade() const {
  const ::io::stakenet::orderbook::protos::Trade* p = trade_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Trade*>(
      &::io::stakenet::orderbook::protos::_Trade_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Trade& MyOrderMatched::trade() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.MyOrderMatched.trade)
  return _internal_trade();
}
inline ::io::stakenet::orderbook::protos::Trade* MyOrderMatched::release_trade() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.MyOrderMatched.trade)
  
  ::io::stakenet::orderbook::protos::Trade* temp = trade_;
  trade_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Trade* MyOrderMatched::_internal_mutable_trade() {
  
  if (trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Trade>(GetArenaNoVirtual());
    trade_ = p;
  }
  return trade_;
}
inline ::io::stakenet::orderbook::protos::Trade* MyOrderMatched::mutable_trade() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.MyOrderMatched.trade)
  return _internal_mutable_trade();
}
inline void MyOrderMatched::set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trade_);
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    
  } else {
    
  }
  trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.MyOrderMatched.trade)
}

// .io.stakenet.orderbook.protos.Order orderMatchedWith = 2;
inline bool MyOrderMatched::_internal_has_ordermatchedwith() const {
  return this != internal_default_instance() && ordermatchedwith_ != nullptr;
}
inline bool MyOrderMatched::has_ordermatchedwith() const {
  return _internal_has_ordermatchedwith();
}
inline const ::io::stakenet::orderbook::protos::Order& MyOrderMatched::_internal_ordermatchedwith() const {
  const ::io::stakenet::orderbook::protos::Order* p = ordermatchedwith_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Order*>(
      &::io::stakenet::orderbook::protos::_Order_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Order& MyOrderMatched::ordermatchedwith() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.MyOrderMatched.orderMatchedWith)
  return _internal_ordermatchedwith();
}
inline ::io::stakenet::orderbook::protos::Order* MyOrderMatched::release_ordermatchedwith() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.MyOrderMatched.orderMatchedWith)
  
  ::io::stakenet::orderbook::protos::Order* temp = ordermatchedwith_;
  ordermatchedwith_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Order* MyOrderMatched::_internal_mutable_ordermatchedwith() {
  
  if (ordermatchedwith_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Order>(GetArenaNoVirtual());
    ordermatchedwith_ = p;
  }
  return ordermatchedwith_;
}
inline ::io::stakenet::orderbook::protos::Order* MyOrderMatched::mutable_ordermatchedwith() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.MyOrderMatched.orderMatchedWith)
  return _internal_mutable_ordermatchedwith();
}
inline void MyOrderMatched::set_allocated_ordermatchedwith(::io::stakenet::orderbook::protos::Order* ordermatchedwith) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ordermatchedwith_);
  }
  if (ordermatchedwith) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ordermatchedwith = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ordermatchedwith, submessage_arena);
    }
    
  } else {
    
  }
  ordermatchedwith_ = ordermatchedwith;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.MyOrderMatched.orderMatchedWith)
}

// -------------------------------------------------------------------

// MyMatchedOrderCanceled

// .io.stakenet.orderbook.protos.Trade trade = 1;
inline bool MyMatchedOrderCanceled::_internal_has_trade() const {
  return this != internal_default_instance() && trade_ != nullptr;
}
inline bool MyMatchedOrderCanceled::has_trade() const {
  return _internal_has_trade();
}
inline const ::io::stakenet::orderbook::protos::Trade& MyMatchedOrderCanceled::_internal_trade() const {
  const ::io::stakenet::orderbook::protos::Trade* p = trade_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Trade*>(
      &::io::stakenet::orderbook::protos::_Trade_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Trade& MyMatchedOrderCanceled::trade() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.MyMatchedOrderCanceled.trade)
  return _internal_trade();
}
inline ::io::stakenet::orderbook::protos::Trade* MyMatchedOrderCanceled::release_trade() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.MyMatchedOrderCanceled.trade)
  
  ::io::stakenet::orderbook::protos::Trade* temp = trade_;
  trade_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Trade* MyMatchedOrderCanceled::_internal_mutable_trade() {
  
  if (trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Trade>(GetArenaNoVirtual());
    trade_ = p;
  }
  return trade_;
}
inline ::io::stakenet::orderbook::protos::Trade* MyMatchedOrderCanceled::mutable_trade() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.MyMatchedOrderCanceled.trade)
  return _internal_mutable_trade();
}
inline void MyMatchedOrderCanceled::set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trade_);
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    
  } else {
    
  }
  trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.MyMatchedOrderCanceled.trade)
}

// -------------------------------------------------------------------

// OrderPlaced

// .io.stakenet.orderbook.protos.Order order = 1;
inline bool OrderPlaced::_internal_has_order() const {
  return this != internal_default_instance() && order_ != nullptr;
}
inline bool OrderPlaced::has_order() const {
  return _internal_has_order();
}
inline const ::io::stakenet::orderbook::protos::Order& OrderPlaced::_internal_order() const {
  const ::io::stakenet::orderbook::protos::Order* p = order_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Order*>(
      &::io::stakenet::orderbook::protos::_Order_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Order& OrderPlaced::order() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderPlaced.order)
  return _internal_order();
}
inline ::io::stakenet::orderbook::protos::Order* OrderPlaced::release_order() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderPlaced.order)
  
  ::io::stakenet::orderbook::protos::Order* temp = order_;
  order_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Order* OrderPlaced::_internal_mutable_order() {
  
  if (order_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Order>(GetArenaNoVirtual());
    order_ = p;
  }
  return order_;
}
inline ::io::stakenet::orderbook::protos::Order* OrderPlaced::mutable_order() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderPlaced.order)
  return _internal_mutable_order();
}
inline void OrderPlaced::set_allocated_order(::io::stakenet::orderbook::protos::Order* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    
  } else {
    
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderPlaced.order)
}

// string tradingPair = 2;
inline void OrderPlaced::clear_tradingpair() {
  tradingpair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OrderPlaced::tradingpair() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
  return _internal_tradingpair();
}
inline void OrderPlaced::set_tradingpair(const std::string& value) {
  _internal_set_tradingpair(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
}
inline std::string* OrderPlaced::mutable_tradingpair() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
  return _internal_mutable_tradingpair();
}
inline const std::string& OrderPlaced::_internal_tradingpair() const {
  return tradingpair_.GetNoArena();
}
inline void OrderPlaced::_internal_set_tradingpair(const std::string& value) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OrderPlaced::set_tradingpair(std::string&& value) {
  
  tradingpair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
}
inline void OrderPlaced::set_tradingpair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
}
inline void OrderPlaced::set_tradingpair(const char* value, size_t size) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
}
inline std::string* OrderPlaced::_internal_mutable_tradingpair() {
  
  return tradingpair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OrderPlaced::release_tradingpair() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
  
  return tradingpair_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OrderPlaced::set_allocated_tradingpair(std::string* tradingpair) {
  if (tradingpair != nullptr) {
    
  } else {
    
  }
  tradingpair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tradingpair);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderPlaced.tradingPair)
}

// -------------------------------------------------------------------

// OrderCanceled

// string orderId = 1;
inline void OrderCanceled::clear_orderid() {
  orderid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OrderCanceled::orderid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderCanceled.orderId)
  return _internal_orderid();
}
inline void OrderCanceled::set_orderid(const std::string& value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.OrderCanceled.orderId)
}
inline std::string* OrderCanceled::mutable_orderid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderCanceled.orderId)
  return _internal_mutable_orderid();
}
inline const std::string& OrderCanceled::_internal_orderid() const {
  return orderid_.GetNoArena();
}
inline void OrderCanceled::_internal_set_orderid(const std::string& value) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OrderCanceled::set_orderid(std::string&& value) {
  
  orderid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.OrderCanceled.orderId)
}
inline void OrderCanceled::set_orderid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.OrderCanceled.orderId)
}
inline void OrderCanceled::set_orderid(const char* value, size_t size) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.OrderCanceled.orderId)
}
inline std::string* OrderCanceled::_internal_mutable_orderid() {
  
  return orderid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OrderCanceled::release_orderid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderCanceled.orderId)
  
  return orderid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OrderCanceled::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  orderid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orderid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderCanceled.orderId)
}

// string tradingPair = 2;
inline void OrderCanceled::clear_tradingpair() {
  tradingpair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OrderCanceled::tradingpair() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
  return _internal_tradingpair();
}
inline void OrderCanceled::set_tradingpair(const std::string& value) {
  _internal_set_tradingpair(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
}
inline std::string* OrderCanceled::mutable_tradingpair() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
  return _internal_mutable_tradingpair();
}
inline const std::string& OrderCanceled::_internal_tradingpair() const {
  return tradingpair_.GetNoArena();
}
inline void OrderCanceled::_internal_set_tradingpair(const std::string& value) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OrderCanceled::set_tradingpair(std::string&& value) {
  
  tradingpair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
}
inline void OrderCanceled::set_tradingpair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
}
inline void OrderCanceled::set_tradingpair(const char* value, size_t size) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
}
inline std::string* OrderCanceled::_internal_mutable_tradingpair() {
  
  return tradingpair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OrderCanceled::release_tradingpair() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
  
  return tradingpair_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OrderCanceled::set_allocated_tradingpair(std::string* tradingpair) {
  if (tradingpair != nullptr) {
    
  } else {
    
  }
  tradingpair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tradingpair);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderCanceled.tradingPair)
}

// .io.stakenet.orderbook.protos.Order order = 3;
inline bool OrderCanceled::_internal_has_order() const {
  return this != internal_default_instance() && order_ != nullptr;
}
inline bool OrderCanceled::has_order() const {
  return _internal_has_order();
}
inline const ::io::stakenet::orderbook::protos::Order& OrderCanceled::_internal_order() const {
  const ::io::stakenet::orderbook::protos::Order* p = order_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Order*>(
      &::io::stakenet::orderbook::protos::_Order_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Order& OrderCanceled::order() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderCanceled.order)
  return _internal_order();
}
inline ::io::stakenet::orderbook::protos::Order* OrderCanceled::release_order() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderCanceled.order)
  
  ::io::stakenet::orderbook::protos::Order* temp = order_;
  order_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Order* OrderCanceled::_internal_mutable_order() {
  
  if (order_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Order>(GetArenaNoVirtual());
    order_ = p;
  }
  return order_;
}
inline ::io::stakenet::orderbook::protos::Order* OrderCanceled::mutable_order() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderCanceled.order)
  return _internal_mutable_order();
}
inline void OrderCanceled::set_allocated_order(::io::stakenet::orderbook::protos::Order* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    
  } else {
    
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderCanceled.order)
}

// -------------------------------------------------------------------

// OrdersMatched

// .io.stakenet.orderbook.protos.Trade trade = 1;
inline bool OrdersMatched::_internal_has_trade() const {
  return this != internal_default_instance() && trade_ != nullptr;
}
inline bool OrdersMatched::has_trade() const {
  return _internal_has_trade();
}
inline const ::io::stakenet::orderbook::protos::Trade& OrdersMatched::_internal_trade() const {
  const ::io::stakenet::orderbook::protos::Trade* p = trade_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Trade*>(
      &::io::stakenet::orderbook::protos::_Trade_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Trade& OrdersMatched::trade() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrdersMatched.trade)
  return _internal_trade();
}
inline ::io::stakenet::orderbook::protos::Trade* OrdersMatched::release_trade() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrdersMatched.trade)
  
  ::io::stakenet::orderbook::protos::Trade* temp = trade_;
  trade_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Trade* OrdersMatched::_internal_mutable_trade() {
  
  if (trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Trade>(GetArenaNoVirtual());
    trade_ = p;
  }
  return trade_;
}
inline ::io::stakenet::orderbook::protos::Trade* OrdersMatched::mutable_trade() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrdersMatched.trade)
  return _internal_mutable_trade();
}
inline void OrdersMatched::set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trade_);
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    
  } else {
    
  }
  trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrdersMatched.trade)
}

// string tradingPair = 2;
inline void OrdersMatched::clear_tradingpair() {
  tradingpair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OrdersMatched::tradingpair() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
  return _internal_tradingpair();
}
inline void OrdersMatched::set_tradingpair(const std::string& value) {
  _internal_set_tradingpair(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
}
inline std::string* OrdersMatched::mutable_tradingpair() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
  return _internal_mutable_tradingpair();
}
inline const std::string& OrdersMatched::_internal_tradingpair() const {
  return tradingpair_.GetNoArena();
}
inline void OrdersMatched::_internal_set_tradingpair(const std::string& value) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OrdersMatched::set_tradingpair(std::string&& value) {
  
  tradingpair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
}
inline void OrdersMatched::set_tradingpair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
}
inline void OrdersMatched::set_tradingpair(const char* value, size_t size) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
}
inline std::string* OrdersMatched::_internal_mutable_tradingpair() {
  
  return tradingpair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OrdersMatched::release_tradingpair() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
  
  return tradingpair_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OrdersMatched::set_allocated_tradingpair(std::string* tradingpair) {
  if (tradingpair != nullptr) {
    
  } else {
    
  }
  tradingpair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tradingpair);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrdersMatched.tradingPair)
}

// -------------------------------------------------------------------

// NewOrderMessage

// string orderId = 1;
inline void NewOrderMessage::clear_orderid() {
  orderid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NewOrderMessage::orderid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
  return _internal_orderid();
}
inline void NewOrderMessage::set_orderid(const std::string& value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
}
inline std::string* NewOrderMessage::mutable_orderid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
  return _internal_mutable_orderid();
}
inline const std::string& NewOrderMessage::_internal_orderid() const {
  return orderid_.GetNoArena();
}
inline void NewOrderMessage::_internal_set_orderid(const std::string& value) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NewOrderMessage::set_orderid(std::string&& value) {
  
  orderid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
}
inline void NewOrderMessage::set_orderid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
}
inline void NewOrderMessage::set_orderid(const char* value, size_t size) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
}
inline std::string* NewOrderMessage::_internal_mutable_orderid() {
  
  return orderid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NewOrderMessage::release_orderid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
  
  return orderid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrderMessage::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  orderid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orderid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.NewOrderMessage.orderId)
}

// bytes message = 2;
inline void NewOrderMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NewOrderMessage::message() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.NewOrderMessage.message)
  return _internal_message();
}
inline void NewOrderMessage::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.NewOrderMessage.message)
}
inline std::string* NewOrderMessage::mutable_message() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.NewOrderMessage.message)
  return _internal_mutable_message();
}
inline const std::string& NewOrderMessage::_internal_message() const {
  return message_.GetNoArena();
}
inline void NewOrderMessage::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NewOrderMessage::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.NewOrderMessage.message)
}
inline void NewOrderMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.NewOrderMessage.message)
}
inline void NewOrderMessage::set_message(const void* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.NewOrderMessage.message)
}
inline std::string* NewOrderMessage::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NewOrderMessage::release_message() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.NewOrderMessage.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrderMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.NewOrderMessage.message)
}

// -------------------------------------------------------------------

// SwapSuccess

// .io.stakenet.orderbook.protos.Trade trade = 1;
inline bool SwapSuccess::_internal_has_trade() const {
  return this != internal_default_instance() && trade_ != nullptr;
}
inline bool SwapSuccess::has_trade() const {
  return _internal_has_trade();
}
inline const ::io::stakenet::orderbook::protos::Trade& SwapSuccess::_internal_trade() const {
  const ::io::stakenet::orderbook::protos::Trade* p = trade_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Trade*>(
      &::io::stakenet::orderbook::protos::_Trade_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Trade& SwapSuccess::trade() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.SwapSuccess.trade)
  return _internal_trade();
}
inline ::io::stakenet::orderbook::protos::Trade* SwapSuccess::release_trade() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.SwapSuccess.trade)
  
  ::io::stakenet::orderbook::protos::Trade* temp = trade_;
  trade_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Trade* SwapSuccess::_internal_mutable_trade() {
  
  if (trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Trade>(GetArenaNoVirtual());
    trade_ = p;
  }
  return trade_;
}
inline ::io::stakenet::orderbook::protos::Trade* SwapSuccess::mutable_trade() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.SwapSuccess.trade)
  return _internal_mutable_trade();
}
inline void SwapSuccess::set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trade_);
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    
  } else {
    
  }
  trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.SwapSuccess.trade)
}

// string tradingPair = 2;
inline void SwapSuccess::clear_tradingpair() {
  tradingpair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SwapSuccess::tradingpair() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
  return _internal_tradingpair();
}
inline void SwapSuccess::set_tradingpair(const std::string& value) {
  _internal_set_tradingpair(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
}
inline std::string* SwapSuccess::mutable_tradingpair() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
  return _internal_mutable_tradingpair();
}
inline const std::string& SwapSuccess::_internal_tradingpair() const {
  return tradingpair_.GetNoArena();
}
inline void SwapSuccess::_internal_set_tradingpair(const std::string& value) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SwapSuccess::set_tradingpair(std::string&& value) {
  
  tradingpair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
}
inline void SwapSuccess::set_tradingpair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
}
inline void SwapSuccess::set_tradingpair(const char* value, size_t size) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
}
inline std::string* SwapSuccess::_internal_mutable_tradingpair() {
  
  return tradingpair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SwapSuccess::release_tradingpair() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
  
  return tradingpair_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SwapSuccess::set_allocated_tradingpair(std::string* tradingpair) {
  if (tradingpair != nullptr) {
    
  } else {
    
  }
  tradingpair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tradingpair);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.SwapSuccess.tradingPair)
}

// -------------------------------------------------------------------

// SwapFailure

// .io.stakenet.orderbook.protos.Trade trade = 1;
inline bool SwapFailure::_internal_has_trade() const {
  return this != internal_default_instance() && trade_ != nullptr;
}
inline bool SwapFailure::has_trade() const {
  return _internal_has_trade();
}
inline const ::io::stakenet::orderbook::protos::Trade& SwapFailure::_internal_trade() const {
  const ::io::stakenet::orderbook::protos::Trade* p = trade_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::Trade*>(
      &::io::stakenet::orderbook::protos::_Trade_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::Trade& SwapFailure::trade() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.SwapFailure.trade)
  return _internal_trade();
}
inline ::io::stakenet::orderbook::protos::Trade* SwapFailure::release_trade() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.SwapFailure.trade)
  
  ::io::stakenet::orderbook::protos::Trade* temp = trade_;
  trade_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::Trade* SwapFailure::_internal_mutable_trade() {
  
  if (trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::Trade>(GetArenaNoVirtual());
    trade_ = p;
  }
  return trade_;
}
inline ::io::stakenet::orderbook::protos::Trade* SwapFailure::mutable_trade() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.SwapFailure.trade)
  return _internal_mutable_trade();
}
inline void SwapFailure::set_allocated_trade(::io::stakenet::orderbook::protos::Trade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trade_);
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    
  } else {
    
  }
  trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.SwapFailure.trade)
}

// string tradingPair = 2;
inline void SwapFailure::clear_tradingpair() {
  tradingpair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SwapFailure::tradingpair() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
  return _internal_tradingpair();
}
inline void SwapFailure::set_tradingpair(const std::string& value) {
  _internal_set_tradingpair(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
}
inline std::string* SwapFailure::mutable_tradingpair() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
  return _internal_mutable_tradingpair();
}
inline const std::string& SwapFailure::_internal_tradingpair() const {
  return tradingpair_.GetNoArena();
}
inline void SwapFailure::_internal_set_tradingpair(const std::string& value) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SwapFailure::set_tradingpair(std::string&& value) {
  
  tradingpair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
}
inline void SwapFailure::set_tradingpair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
}
inline void SwapFailure::set_tradingpair(const char* value, size_t size) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
}
inline std::string* SwapFailure::_internal_mutable_tradingpair() {
  
  return tradingpair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SwapFailure::release_tradingpair() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
  
  return tradingpair_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SwapFailure::set_allocated_tradingpair(std::string* tradingpair) {
  if (tradingpair != nullptr) {
    
  } else {
    
  }
  tradingpair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tradingpair);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.SwapFailure.tradingPair)
}

// -------------------------------------------------------------------

// RentedChannelEvent_ChannelOpened

// string channelId = 1;
inline void RentedChannelEvent_ChannelOpened::clear_channelid() {
  channelid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RentedChannelEvent_ChannelOpened::channelid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
  return _internal_channelid();
}
inline void RentedChannelEvent_ChannelOpened::set_channelid(const std::string& value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
}
inline std::string* RentedChannelEvent_ChannelOpened::mutable_channelid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
  return _internal_mutable_channelid();
}
inline const std::string& RentedChannelEvent_ChannelOpened::_internal_channelid() const {
  return channelid_.GetNoArena();
}
inline void RentedChannelEvent_ChannelOpened::_internal_set_channelid(const std::string& value) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RentedChannelEvent_ChannelOpened::set_channelid(std::string&& value) {
  
  channelid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
}
inline void RentedChannelEvent_ChannelOpened::set_channelid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
}
inline void RentedChannelEvent_ChannelOpened::set_channelid(const char* value, size_t size) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
}
inline std::string* RentedChannelEvent_ChannelOpened::_internal_mutable_channelid() {
  
  return channelid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RentedChannelEvent_ChannelOpened::release_channelid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
  
  return channelid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RentedChannelEvent_ChannelOpened::set_allocated_channelid(std::string* channelid) {
  if (channelid != nullptr) {
    
  } else {
    
  }
  channelid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channelid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.channelId)
}

// int64 expiresOn = 2;
inline void RentedChannelEvent_ChannelOpened::clear_expireson() {
  expireson_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RentedChannelEvent_ChannelOpened::_internal_expireson() const {
  return expireson_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RentedChannelEvent_ChannelOpened::expireson() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.expiresOn)
  return _internal_expireson();
}
inline void RentedChannelEvent_ChannelOpened::_internal_set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  expireson_ = value;
}
inline void RentedChannelEvent_ChannelOpened::set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_expireson(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.expiresOn)
}

// int64 openedOn = 3;
inline void RentedChannelEvent_ChannelOpened::clear_openedon() {
  openedon_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RentedChannelEvent_ChannelOpened::_internal_openedon() const {
  return openedon_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RentedChannelEvent_ChannelOpened::openedon() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.openedOn)
  return _internal_openedon();
}
inline void RentedChannelEvent_ChannelOpened::_internal_set_openedon(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  openedon_ = value;
}
inline void RentedChannelEvent_ChannelOpened::set_openedon(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_openedon(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened.openedOn)
}

// -------------------------------------------------------------------

// RentedChannelEvent_ChannelExpiringSoon

// string channelId = 1;
inline void RentedChannelEvent_ChannelExpiringSoon::clear_channelid() {
  channelid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RentedChannelEvent_ChannelExpiringSoon::channelid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
  return _internal_channelid();
}
inline void RentedChannelEvent_ChannelExpiringSoon::set_channelid(const std::string& value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
}
inline std::string* RentedChannelEvent_ChannelExpiringSoon::mutable_channelid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
  return _internal_mutable_channelid();
}
inline const std::string& RentedChannelEvent_ChannelExpiringSoon::_internal_channelid() const {
  return channelid_.GetNoArena();
}
inline void RentedChannelEvent_ChannelExpiringSoon::_internal_set_channelid(const std::string& value) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RentedChannelEvent_ChannelExpiringSoon::set_channelid(std::string&& value) {
  
  channelid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
}
inline void RentedChannelEvent_ChannelExpiringSoon::set_channelid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
}
inline void RentedChannelEvent_ChannelExpiringSoon::set_channelid(const char* value, size_t size) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
}
inline std::string* RentedChannelEvent_ChannelExpiringSoon::_internal_mutable_channelid() {
  
  return channelid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RentedChannelEvent_ChannelExpiringSoon::release_channelid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
  
  return channelid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RentedChannelEvent_ChannelExpiringSoon::set_allocated_channelid(std::string* channelid) {
  if (channelid != nullptr) {
    
  } else {
    
  }
  channelid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channelid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.channelId)
}

// int64 expiresOn = 2;
inline void RentedChannelEvent_ChannelExpiringSoon::clear_expireson() {
  expireson_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RentedChannelEvent_ChannelExpiringSoon::_internal_expireson() const {
  return expireson_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RentedChannelEvent_ChannelExpiringSoon::expireson() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.expiresOn)
  return _internal_expireson();
}
inline void RentedChannelEvent_ChannelExpiringSoon::_internal_set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  expireson_ = value;
}
inline void RentedChannelEvent_ChannelExpiringSoon::set_expireson(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_expireson(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon.expiresOn)
}

// -------------------------------------------------------------------

// RentedChannelEvent_ChannelClosed

// string channelId = 1;
inline void RentedChannelEvent_ChannelClosed::clear_channelid() {
  channelid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RentedChannelEvent_ChannelClosed::channelid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
  return _internal_channelid();
}
inline void RentedChannelEvent_ChannelClosed::set_channelid(const std::string& value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
}
inline std::string* RentedChannelEvent_ChannelClosed::mutable_channelid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
  return _internal_mutable_channelid();
}
inline const std::string& RentedChannelEvent_ChannelClosed::_internal_channelid() const {
  return channelid_.GetNoArena();
}
inline void RentedChannelEvent_ChannelClosed::_internal_set_channelid(const std::string& value) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RentedChannelEvent_ChannelClosed::set_channelid(std::string&& value) {
  
  channelid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
}
inline void RentedChannelEvent_ChannelClosed::set_channelid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
}
inline void RentedChannelEvent_ChannelClosed::set_channelid(const char* value, size_t size) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
}
inline std::string* RentedChannelEvent_ChannelClosed::_internal_mutable_channelid() {
  
  return channelid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RentedChannelEvent_ChannelClosed::release_channelid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
  
  return channelid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RentedChannelEvent_ChannelClosed::set_allocated_channelid(std::string* channelid) {
  if (channelid != nullptr) {
    
  } else {
    
  }
  channelid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channelid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed.channelId)
}

// -------------------------------------------------------------------

// RentedChannelEvent

// .io.stakenet.orderbook.protos.RentedChannelEvent.ChannelOpened channelOpened = 1;
inline bool RentedChannelEvent::_internal_has_channelopened() const {
  return value_case() == kChannelOpened;
}
inline bool RentedChannelEvent::has_channelopened() const {
  return _internal_has_channelopened();
}
inline void RentedChannelEvent::set_has_channelopened() {
  _oneof_case_[0] = kChannelOpened;
}
inline void RentedChannelEvent::clear_channelopened() {
  if (_internal_has_channelopened()) {
    delete value_.channelopened_;
    clear_has_value();
  }
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* RentedChannelEvent::release_channelopened() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannelEvent.channelOpened)
  if (_internal_has_channelopened()) {
    clear_has_value();
      ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* temp = value_.channelopened_;
    value_.channelopened_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened& RentedChannelEvent::_internal_channelopened() const {
  return _internal_has_channelopened()
      ? *value_.channelopened_
      : *reinterpret_cast< ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened*>(&::io::stakenet::orderbook::protos::_RentedChannelEvent_ChannelOpened_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened& RentedChannelEvent::channelopened() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.channelOpened)
  return _internal_channelopened();
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* RentedChannelEvent::_internal_mutable_channelopened() {
  if (!_internal_has_channelopened()) {
    clear_value();
    set_has_channelopened();
    value_.channelopened_ = CreateMaybeMessage< ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened >(
        GetArenaNoVirtual());
  }
  return value_.channelopened_;
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelOpened* RentedChannelEvent::mutable_channelopened() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannelEvent.channelOpened)
  return _internal_mutable_channelopened();
}

// .io.stakenet.orderbook.protos.RentedChannelEvent.ChannelExpiringSoon channelExpiringSoon = 2;
inline bool RentedChannelEvent::_internal_has_channelexpiringsoon() const {
  return value_case() == kChannelExpiringSoon;
}
inline bool RentedChannelEvent::has_channelexpiringsoon() const {
  return _internal_has_channelexpiringsoon();
}
inline void RentedChannelEvent::set_has_channelexpiringsoon() {
  _oneof_case_[0] = kChannelExpiringSoon;
}
inline void RentedChannelEvent::clear_channelexpiringsoon() {
  if (_internal_has_channelexpiringsoon()) {
    delete value_.channelexpiringsoon_;
    clear_has_value();
  }
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* RentedChannelEvent::release_channelexpiringsoon() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannelEvent.channelExpiringSoon)
  if (_internal_has_channelexpiringsoon()) {
    clear_has_value();
      ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* temp = value_.channelexpiringsoon_;
    value_.channelexpiringsoon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon& RentedChannelEvent::_internal_channelexpiringsoon() const {
  return _internal_has_channelexpiringsoon()
      ? *value_.channelexpiringsoon_
      : *reinterpret_cast< ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon*>(&::io::stakenet::orderbook::protos::_RentedChannelEvent_ChannelExpiringSoon_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon& RentedChannelEvent::channelexpiringsoon() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.channelExpiringSoon)
  return _internal_channelexpiringsoon();
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* RentedChannelEvent::_internal_mutable_channelexpiringsoon() {
  if (!_internal_has_channelexpiringsoon()) {
    clear_value();
    set_has_channelexpiringsoon();
    value_.channelexpiringsoon_ = CreateMaybeMessage< ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon >(
        GetArenaNoVirtual());
  }
  return value_.channelexpiringsoon_;
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelExpiringSoon* RentedChannelEvent::mutable_channelexpiringsoon() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannelEvent.channelExpiringSoon)
  return _internal_mutable_channelexpiringsoon();
}

// .io.stakenet.orderbook.protos.RentedChannelEvent.ChannelClosed channelClosed = 3;
inline bool RentedChannelEvent::_internal_has_channelclosed() const {
  return value_case() == kChannelClosed;
}
inline bool RentedChannelEvent::has_channelclosed() const {
  return _internal_has_channelclosed();
}
inline void RentedChannelEvent::set_has_channelclosed() {
  _oneof_case_[0] = kChannelClosed;
}
inline void RentedChannelEvent::clear_channelclosed() {
  if (_internal_has_channelclosed()) {
    delete value_.channelclosed_;
    clear_has_value();
  }
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* RentedChannelEvent::release_channelclosed() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannelEvent.channelClosed)
  if (_internal_has_channelclosed()) {
    clear_has_value();
      ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* temp = value_.channelclosed_;
    value_.channelclosed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed& RentedChannelEvent::_internal_channelclosed() const {
  return _internal_has_channelclosed()
      ? *value_.channelclosed_
      : *reinterpret_cast< ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed*>(&::io::stakenet::orderbook::protos::_RentedChannelEvent_ChannelClosed_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed& RentedChannelEvent::channelclosed() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannelEvent.channelClosed)
  return _internal_channelclosed();
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* RentedChannelEvent::_internal_mutable_channelclosed() {
  if (!_internal_has_channelclosed()) {
    clear_value();
    set_has_channelclosed();
    value_.channelclosed_ = CreateMaybeMessage< ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed >(
        GetArenaNoVirtual());
  }
  return value_.channelclosed_;
}
inline ::io::stakenet::orderbook::protos::RentedChannelEvent_ChannelClosed* RentedChannelEvent::mutable_channelclosed() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannelEvent.channelClosed)
  return _internal_mutable_channelclosed();
}

inline bool RentedChannelEvent::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void RentedChannelEvent::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline RentedChannelEvent::ValueCase RentedChannelEvent::value_case() const {
  return RentedChannelEvent::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MaintenanceInProgress

// -------------------------------------------------------------------

// MaintenanceCompleted

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace orderbook
}  // namespace stakenet
}  // namespace io

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_stakenet_2forderbook_2fevents_2eproto
