// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stakenet/orderbook/models.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_stakenet_2forderbook_2fmodels_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_stakenet_2forderbook_2fmodels_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_stakenet_2forderbook_2fmodels_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_stakenet_2forderbook_2fmodels_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_stakenet_2forderbook_2fmodels_2eproto;
namespace io {
namespace stakenet {
namespace orderbook {
namespace protos {
class BarPrices;
class BarPricesDefaultTypeInternal;
extern BarPricesDefaultTypeInternal _BarPrices_default_instance_;
class BigInclusiveInterval;
class BigInclusiveIntervalDefaultTypeInternal;
extern BigInclusiveIntervalDefaultTypeInternal _BigInclusiveInterval_default_instance_;
class BigInteger;
class BigIntegerDefaultTypeInternal;
extern BigIntegerDefaultTypeInternal _BigInteger_default_instance_;
class ConnextChannel;
class ConnextChannelDefaultTypeInternal;
extern ConnextChannelDefaultTypeInternal _ConnextChannel_default_instance_;
class LndChannel;
class LndChannelDefaultTypeInternal;
extern LndChannelDefaultTypeInternal _LndChannel_default_instance_;
class Order;
class OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class OrderDetails;
class OrderDetailsDefaultTypeInternal;
extern OrderDetailsDefaultTypeInternal _OrderDetails_default_instance_;
class OrderSummary;
class OrderSummaryDefaultTypeInternal;
extern OrderSummaryDefaultTypeInternal _OrderSummary_default_instance_;
class RefundablePayment;
class RefundablePaymentDefaultTypeInternal;
extern RefundablePaymentDefaultTypeInternal _RefundablePayment_default_instance_;
class RentedChannel;
class RentedChannelDefaultTypeInternal;
extern RentedChannelDefaultTypeInternal _RentedChannel_default_instance_;
class ServerInMaintenance;
class ServerInMaintenanceDefaultTypeInternal;
extern ServerInMaintenanceDefaultTypeInternal _ServerInMaintenance_default_instance_;
class Trade;
class TradeDefaultTypeInternal;
extern TradeDefaultTypeInternal _Trade_default_instance_;
class TradingPair;
class TradingPairDefaultTypeInternal;
extern TradingPairDefaultTypeInternal _TradingPair_default_instance_;
}  // namespace protos
}  // namespace orderbook
}  // namespace stakenet
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::stakenet::orderbook::protos::BarPrices* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::BarPrices>(Arena*);
template<> ::io::stakenet::orderbook::protos::BigInclusiveInterval* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInclusiveInterval>(Arena*);
template<> ::io::stakenet::orderbook::protos::BigInteger* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(Arena*);
template<> ::io::stakenet::orderbook::protos::ConnextChannel* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::ConnextChannel>(Arena*);
template<> ::io::stakenet::orderbook::protos::LndChannel* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::LndChannel>(Arena*);
template<> ::io::stakenet::orderbook::protos::Order* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::Order>(Arena*);
template<> ::io::stakenet::orderbook::protos::OrderDetails* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::OrderDetails>(Arena*);
template<> ::io::stakenet::orderbook::protos::OrderSummary* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::OrderSummary>(Arena*);
template<> ::io::stakenet::orderbook::protos::RefundablePayment* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::RefundablePayment>(Arena*);
template<> ::io::stakenet::orderbook::protos::RentedChannel* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::RentedChannel>(Arena*);
template<> ::io::stakenet::orderbook::protos::ServerInMaintenance* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::ServerInMaintenance>(Arena*);
template<> ::io::stakenet::orderbook::protos::Trade* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::Trade>(Arena*);
template<> ::io::stakenet::orderbook::protos::TradingPair* Arena::CreateMaybeMessage<::io::stakenet::orderbook::protos::TradingPair>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace stakenet {
namespace orderbook {
namespace protos {

enum Order_OrderType : int {
  Order_OrderType_limit = 0,
  Order_OrderType_market = 1,
  Order_OrderType_Order_OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Order_OrderType_Order_OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Order_OrderType_IsValid(int value);
constexpr Order_OrderType Order_OrderType_OrderType_MIN = Order_OrderType_limit;
constexpr Order_OrderType Order_OrderType_OrderType_MAX = Order_OrderType_market;
constexpr int Order_OrderType_OrderType_ARRAYSIZE = Order_OrderType_OrderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Order_OrderType_descriptor();
template<typename T>
inline const std::string& Order_OrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Order_OrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Order_OrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Order_OrderType_descriptor(), enum_t_value);
}
inline bool Order_OrderType_Parse(
    const std::string& name, Order_OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Order_OrderType>(
    Order_OrderType_descriptor(), name, value);
}
enum Order_OrderSide : int {
  Order_OrderSide_buy = 0,
  Order_OrderSide_sell = 1,
  Order_OrderSide_Order_OrderSide_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Order_OrderSide_Order_OrderSide_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Order_OrderSide_IsValid(int value);
constexpr Order_OrderSide Order_OrderSide_OrderSide_MIN = Order_OrderSide_buy;
constexpr Order_OrderSide Order_OrderSide_OrderSide_MAX = Order_OrderSide_sell;
constexpr int Order_OrderSide_OrderSide_ARRAYSIZE = Order_OrderSide_OrderSide_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Order_OrderSide_descriptor();
template<typename T>
inline const std::string& Order_OrderSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Order_OrderSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Order_OrderSide_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Order_OrderSide_descriptor(), enum_t_value);
}
inline bool Order_OrderSide_Parse(
    const std::string& name, Order_OrderSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Order_OrderSide>(
    Order_OrderSide_descriptor(), name, value);
}
// ===================================================================

class BigInteger :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.BigInteger) */ {
 public:
  BigInteger();
  virtual ~BigInteger();

  BigInteger(const BigInteger& from);
  BigInteger(BigInteger&& from) noexcept
    : BigInteger() {
    *this = ::std::move(from);
  }

  inline BigInteger& operator=(const BigInteger& from) {
    CopyFrom(from);
    return *this;
  }
  inline BigInteger& operator=(BigInteger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BigInteger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigInteger* internal_default_instance() {
    return reinterpret_cast<const BigInteger*>(
               &_BigInteger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BigInteger& a, BigInteger& b) {
    a.Swap(&b);
  }
  inline void Swap(BigInteger* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BigInteger* New() const final {
    return CreateMaybeMessage<BigInteger>(nullptr);
  }

  BigInteger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BigInteger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BigInteger& from);
  void MergeFrom(const BigInteger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigInteger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.BigInteger";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.BigInteger)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class OrderDetails :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.OrderDetails) */ {
 public:
  OrderDetails();
  virtual ~OrderDetails();

  OrderDetails(const OrderDetails& from);
  OrderDetails(OrderDetails&& from) noexcept
    : OrderDetails() {
    *this = ::std::move(from);
  }

  inline OrderDetails& operator=(const OrderDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderDetails& operator=(OrderDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderDetails* internal_default_instance() {
    return reinterpret_cast<const OrderDetails*>(
               &_OrderDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OrderDetails& a, OrderDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderDetails* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderDetails* New() const final {
    return CreateMaybeMessage<OrderDetails>(nullptr);
  }

  OrderDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderDetails>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderDetails& from);
  void MergeFrom(const OrderDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderDetails* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.OrderDetails";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kFundsFieldNumber = 2,
    kPriceFieldNumber = 3,
  };
  // string orderId = 1;
  void clear_orderid();
  const std::string& orderid() const;
  void set_orderid(const std::string& value);
  void set_orderid(std::string&& value);
  void set_orderid(const char* value);
  void set_orderid(const char* value, size_t size);
  std::string* mutable_orderid();
  std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // .io.stakenet.orderbook.protos.BigInteger funds = 2;
  bool has_funds() const;
  private:
  bool _internal_has_funds() const;
  public:
  void clear_funds();
  const ::io::stakenet::orderbook::protos::BigInteger& funds() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_funds();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_funds();
  void set_allocated_funds(::io::stakenet::orderbook::protos::BigInteger* funds);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_funds() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_funds();
  public:

  // .io.stakenet.orderbook.protos.BigInteger price = 3;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  const ::io::stakenet::orderbook::protos::BigInteger& price() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_price();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_price();
  void set_allocated_price(::io::stakenet::orderbook::protos::BigInteger* price);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_price() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_price();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.OrderDetails)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
  ::io::stakenet::orderbook::protos::BigInteger* funds_;
  ::io::stakenet::orderbook::protos::BigInteger* price_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Order :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.Order) */ {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  inline Order& operator=(Order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Order& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }
  inline void Swap(Order* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Order* New() const final {
    return CreateMaybeMessage<Order>(nullptr);
  }

  Order* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.Order";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Order_OrderType OrderType;
  static constexpr OrderType limit =
    Order_OrderType_limit;
  static constexpr OrderType market =
    Order_OrderType_market;
  static inline bool OrderType_IsValid(int value) {
    return Order_OrderType_IsValid(value);
  }
  static constexpr OrderType OrderType_MIN =
    Order_OrderType_OrderType_MIN;
  static constexpr OrderType OrderType_MAX =
    Order_OrderType_OrderType_MAX;
  static constexpr int OrderType_ARRAYSIZE =
    Order_OrderType_OrderType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OrderType_descriptor() {
    return Order_OrderType_descriptor();
  }
  template<typename T>
  static inline const std::string& OrderType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OrderType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OrderType_Name.");
    return Order_OrderType_Name(enum_t_value);
  }
  static inline bool OrderType_Parse(const std::string& name,
      OrderType* value) {
    return Order_OrderType_Parse(name, value);
  }

  typedef Order_OrderSide OrderSide;
  static constexpr OrderSide buy =
    Order_OrderSide_buy;
  static constexpr OrderSide sell =
    Order_OrderSide_sell;
  static inline bool OrderSide_IsValid(int value) {
    return Order_OrderSide_IsValid(value);
  }
  static constexpr OrderSide OrderSide_MIN =
    Order_OrderSide_OrderSide_MIN;
  static constexpr OrderSide OrderSide_MAX =
    Order_OrderSide_OrderSide_MAX;
  static constexpr int OrderSide_ARRAYSIZE =
    Order_OrderSide_OrderSide_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OrderSide_descriptor() {
    return Order_OrderSide_descriptor();
  }
  template<typename T>
  static inline const std::string& OrderSide_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OrderSide>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OrderSide_Name.");
    return Order_OrderSide_Name(enum_t_value);
  }
  static inline bool OrderSide_Parse(const std::string& name,
      OrderSide* value) {
    return Order_OrderSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTradingPairFieldNumber = 1,
    kDetailsFieldNumber = 4,
    kTypeFieldNumber = 2,
    kSideFieldNumber = 3,
  };
  // string tradingPair = 1;
  void clear_tradingpair();
  const std::string& tradingpair() const;
  void set_tradingpair(const std::string& value);
  void set_tradingpair(std::string&& value);
  void set_tradingpair(const char* value);
  void set_tradingpair(const char* value, size_t size);
  std::string* mutable_tradingpair();
  std::string* release_tradingpair();
  void set_allocated_tradingpair(std::string* tradingpair);
  private:
  const std::string& _internal_tradingpair() const;
  void _internal_set_tradingpair(const std::string& value);
  std::string* _internal_mutable_tradingpair();
  public:

  // .io.stakenet.orderbook.protos.OrderDetails details = 4;
  bool has_details() const;
  private:
  bool _internal_has_details() const;
  public:
  void clear_details();
  const ::io::stakenet::orderbook::protos::OrderDetails& details() const;
  ::io::stakenet::orderbook::protos::OrderDetails* release_details();
  ::io::stakenet::orderbook::protos::OrderDetails* mutable_details();
  void set_allocated_details(::io::stakenet::orderbook::protos::OrderDetails* details);
  private:
  const ::io::stakenet::orderbook::protos::OrderDetails& _internal_details() const;
  ::io::stakenet::orderbook::protos::OrderDetails* _internal_mutable_details();
  public:

  // .io.stakenet.orderbook.protos.Order.OrderType type = 2;
  void clear_type();
  ::io::stakenet::orderbook::protos::Order_OrderType type() const;
  void set_type(::io::stakenet::orderbook::protos::Order_OrderType value);
  private:
  ::io::stakenet::orderbook::protos::Order_OrderType _internal_type() const;
  void _internal_set_type(::io::stakenet::orderbook::protos::Order_OrderType value);
  public:

  // .io.stakenet.orderbook.protos.Order.OrderSide side = 3;
  void clear_side();
  ::io::stakenet::orderbook::protos::Order_OrderSide side() const;
  void set_side(::io::stakenet::orderbook::protos::Order_OrderSide value);
  private:
  ::io::stakenet::orderbook::protos::Order_OrderSide _internal_side() const;
  void _internal_set_side(::io::stakenet::orderbook::protos::Order_OrderSide value);
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.Order)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingpair_;
  ::io::stakenet::orderbook::protos::OrderDetails* details_;
  int type_;
  int side_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Trade :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.Trade) */ {
 public:
  Trade();
  virtual ~Trade();

  Trade(const Trade& from);
  Trade(Trade&& from) noexcept
    : Trade() {
    *this = ::std::move(from);
  }

  inline Trade& operator=(const Trade& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trade& operator=(Trade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trade* internal_default_instance() {
    return reinterpret_cast<const Trade*>(
               &_Trade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Trade& a, Trade& b) {
    a.Swap(&b);
  }
  inline void Swap(Trade* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trade* New() const final {
    return CreateMaybeMessage<Trade>(nullptr);
  }

  Trade* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trade>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trade& from);
  void MergeFrom(const Trade& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trade* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.Trade";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTradingPairFieldNumber = 2,
    kExistingOrderIdFieldNumber = 5,
    kExecutingOrderIdFieldNumber = 6,
    kExecutingOrderSideFieldNumber = 7,
    kPriceFieldNumber = 3,
    kSizeFieldNumber = 4,
    kExistingOrderFundsFieldNumber = 9,
    kExecutedOnFieldNumber = 8,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string tradingPair = 2;
  void clear_tradingpair();
  const std::string& tradingpair() const;
  void set_tradingpair(const std::string& value);
  void set_tradingpair(std::string&& value);
  void set_tradingpair(const char* value);
  void set_tradingpair(const char* value, size_t size);
  std::string* mutable_tradingpair();
  std::string* release_tradingpair();
  void set_allocated_tradingpair(std::string* tradingpair);
  private:
  const std::string& _internal_tradingpair() const;
  void _internal_set_tradingpair(const std::string& value);
  std::string* _internal_mutable_tradingpair();
  public:

  // string existingOrderId = 5;
  void clear_existingorderid();
  const std::string& existingorderid() const;
  void set_existingorderid(const std::string& value);
  void set_existingorderid(std::string&& value);
  void set_existingorderid(const char* value);
  void set_existingorderid(const char* value, size_t size);
  std::string* mutable_existingorderid();
  std::string* release_existingorderid();
  void set_allocated_existingorderid(std::string* existingorderid);
  private:
  const std::string& _internal_existingorderid() const;
  void _internal_set_existingorderid(const std::string& value);
  std::string* _internal_mutable_existingorderid();
  public:

  // string executingOrderId = 6;
  void clear_executingorderid();
  const std::string& executingorderid() const;
  void set_executingorderid(const std::string& value);
  void set_executingorderid(std::string&& value);
  void set_executingorderid(const char* value);
  void set_executingorderid(const char* value, size_t size);
  std::string* mutable_executingorderid();
  std::string* release_executingorderid();
  void set_allocated_executingorderid(std::string* executingorderid);
  private:
  const std::string& _internal_executingorderid() const;
  void _internal_set_executingorderid(const std::string& value);
  std::string* _internal_mutable_executingorderid();
  public:

  // string executingOrderSide = 7;
  void clear_executingorderside();
  const std::string& executingorderside() const;
  void set_executingorderside(const std::string& value);
  void set_executingorderside(std::string&& value);
  void set_executingorderside(const char* value);
  void set_executingorderside(const char* value, size_t size);
  std::string* mutable_executingorderside();
  std::string* release_executingorderside();
  void set_allocated_executingorderside(std::string* executingorderside);
  private:
  const std::string& _internal_executingorderside() const;
  void _internal_set_executingorderside(const std::string& value);
  std::string* _internal_mutable_executingorderside();
  public:

  // .io.stakenet.orderbook.protos.BigInteger price = 3;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  const ::io::stakenet::orderbook::protos::BigInteger& price() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_price();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_price();
  void set_allocated_price(::io::stakenet::orderbook::protos::BigInteger* price);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_price() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_price();
  public:

  // .io.stakenet.orderbook.protos.BigInteger size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::io::stakenet::orderbook::protos::BigInteger& size() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_size();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_size();
  void set_allocated_size(::io::stakenet::orderbook::protos::BigInteger* size);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_size() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_size();
  public:

  // .io.stakenet.orderbook.protos.BigInteger existingOrderFunds = 9;
  bool has_existingorderfunds() const;
  private:
  bool _internal_has_existingorderfunds() const;
  public:
  void clear_existingorderfunds();
  const ::io::stakenet::orderbook::protos::BigInteger& existingorderfunds() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_existingorderfunds();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_existingorderfunds();
  void set_allocated_existingorderfunds(::io::stakenet::orderbook::protos::BigInteger* existingorderfunds);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_existingorderfunds() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_existingorderfunds();
  public:

  // int64 executedOn = 8;
  void clear_executedon();
  ::PROTOBUF_NAMESPACE_ID::int64 executedon() const;
  void set_executedon(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_executedon() const;
  void _internal_set_executedon(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.Trade)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingpair_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr existingorderid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr executingorderid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr executingorderside_;
  ::io::stakenet::orderbook::protos::BigInteger* price_;
  ::io::stakenet::orderbook::protos::BigInteger* size_;
  ::io::stakenet::orderbook::protos::BigInteger* existingorderfunds_;
  ::PROTOBUF_NAMESPACE_ID::int64 executedon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class BarPrices :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.BarPrices) */ {
 public:
  BarPrices();
  virtual ~BarPrices();

  BarPrices(const BarPrices& from);
  BarPrices(BarPrices&& from) noexcept
    : BarPrices() {
    *this = ::std::move(from);
  }

  inline BarPrices& operator=(const BarPrices& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarPrices& operator=(BarPrices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BarPrices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BarPrices* internal_default_instance() {
    return reinterpret_cast<const BarPrices*>(
               &_BarPrices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BarPrices& a, BarPrices& b) {
    a.Swap(&b);
  }
  inline void Swap(BarPrices* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BarPrices* New() const final {
    return CreateMaybeMessage<BarPrices>(nullptr);
  }

  BarPrices* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BarPrices>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BarPrices& from);
  void MergeFrom(const BarPrices& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarPrices* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.BarPrices";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFieldNumber = 2,
    kHighFieldNumber = 3,
    kLowFieldNumber = 4,
    kCloseFieldNumber = 5,
    kTimeFieldNumber = 1,
    kVolumeFieldNumber = 6,
  };
  // .io.stakenet.orderbook.protos.BigInteger open = 2;
  bool has_open() const;
  private:
  bool _internal_has_open() const;
  public:
  void clear_open();
  const ::io::stakenet::orderbook::protos::BigInteger& open() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_open();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_open();
  void set_allocated_open(::io::stakenet::orderbook::protos::BigInteger* open);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_open() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_open();
  public:

  // .io.stakenet.orderbook.protos.BigInteger high = 3;
  bool has_high() const;
  private:
  bool _internal_has_high() const;
  public:
  void clear_high();
  const ::io::stakenet::orderbook::protos::BigInteger& high() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_high();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_high();
  void set_allocated_high(::io::stakenet::orderbook::protos::BigInteger* high);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_high() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_high();
  public:

  // .io.stakenet.orderbook.protos.BigInteger low = 4;
  bool has_low() const;
  private:
  bool _internal_has_low() const;
  public:
  void clear_low();
  const ::io::stakenet::orderbook::protos::BigInteger& low() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_low();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_low();
  void set_allocated_low(::io::stakenet::orderbook::protos::BigInteger* low);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_low() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_low();
  public:

  // .io.stakenet.orderbook.protos.BigInteger close = 5;
  bool has_close() const;
  private:
  bool _internal_has_close() const;
  public:
  void clear_close();
  const ::io::stakenet::orderbook::protos::BigInteger& close() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_close();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_close();
  void set_allocated_close(::io::stakenet::orderbook::protos::BigInteger* close);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_close() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_close();
  public:

  // int64 time = 1;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 volume = 6;
  void clear_volume();
  ::PROTOBUF_NAMESPACE_ID::int64 volume() const;
  void set_volume(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_volume() const;
  void _internal_set_volume(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.BarPrices)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::io::stakenet::orderbook::protos::BigInteger* open_;
  ::io::stakenet::orderbook::protos::BigInteger* high_;
  ::io::stakenet::orderbook::protos::BigInteger* low_;
  ::io::stakenet::orderbook::protos::BigInteger* close_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  ::PROTOBUF_NAMESPACE_ID::int64 volume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class BigInclusiveInterval :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.BigInclusiveInterval) */ {
 public:
  BigInclusiveInterval();
  virtual ~BigInclusiveInterval();

  BigInclusiveInterval(const BigInclusiveInterval& from);
  BigInclusiveInterval(BigInclusiveInterval&& from) noexcept
    : BigInclusiveInterval() {
    *this = ::std::move(from);
  }

  inline BigInclusiveInterval& operator=(const BigInclusiveInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline BigInclusiveInterval& operator=(BigInclusiveInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BigInclusiveInterval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigInclusiveInterval* internal_default_instance() {
    return reinterpret_cast<const BigInclusiveInterval*>(
               &_BigInclusiveInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BigInclusiveInterval& a, BigInclusiveInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(BigInclusiveInterval* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BigInclusiveInterval* New() const final {
    return CreateMaybeMessage<BigInclusiveInterval>(nullptr);
  }

  BigInclusiveInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BigInclusiveInterval>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BigInclusiveInterval& from);
  void MergeFrom(const BigInclusiveInterval& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigInclusiveInterval* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.BigInclusiveInterval";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // .io.stakenet.orderbook.protos.BigInteger from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::io::stakenet::orderbook::protos::BigInteger& from() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_from();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_from();
  void set_allocated_from(::io::stakenet::orderbook::protos::BigInteger* from);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_from() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_from();
  public:

  // .io.stakenet.orderbook.protos.BigInteger to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::io::stakenet::orderbook::protos::BigInteger& to() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_to();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_to();
  void set_allocated_to(::io::stakenet::orderbook::protos::BigInteger* to);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_to() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_to();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.BigInclusiveInterval)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::io::stakenet::orderbook::protos::BigInteger* from_;
  ::io::stakenet::orderbook::protos::BigInteger* to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class TradingPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.TradingPair) */ {
 public:
  TradingPair();
  virtual ~TradingPair();

  TradingPair(const TradingPair& from);
  TradingPair(TradingPair&& from) noexcept
    : TradingPair() {
    *this = ::std::move(from);
  }

  inline TradingPair& operator=(const TradingPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingPair& operator=(TradingPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TradingPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradingPair* internal_default_instance() {
    return reinterpret_cast<const TradingPair*>(
               &_TradingPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TradingPair& a, TradingPair& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TradingPair* New() const final {
    return CreateMaybeMessage<TradingPair>(nullptr);
  }

  TradingPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TradingPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TradingPair& from);
  void MergeFrom(const TradingPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.TradingPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondaryFieldNumber = 1,
    kPrincipalFieldNumber = 2,
    kIdFieldNumber = 3,
    kBuyFeePercentFieldNumber = 8,
    kSellFeePercentFieldNumber = 9,
    kBuyFundsIntervalFieldNumber = 4,
    kBuyPriceIntervalFieldNumber = 5,
    kSellFundsIntervalFieldNumber = 6,
    kSellPriceIntervalFieldNumber = 7,
  };
  // string secondary = 1;
  void clear_secondary();
  const std::string& secondary() const;
  void set_secondary(const std::string& value);
  void set_secondary(std::string&& value);
  void set_secondary(const char* value);
  void set_secondary(const char* value, size_t size);
  std::string* mutable_secondary();
  std::string* release_secondary();
  void set_allocated_secondary(std::string* secondary);
  private:
  const std::string& _internal_secondary() const;
  void _internal_set_secondary(const std::string& value);
  std::string* _internal_mutable_secondary();
  public:

  // string principal = 2;
  void clear_principal();
  const std::string& principal() const;
  void set_principal(const std::string& value);
  void set_principal(std::string&& value);
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  std::string* mutable_principal();
  std::string* release_principal();
  void set_allocated_principal(std::string* principal);
  private:
  const std::string& _internal_principal() const;
  void _internal_set_principal(const std::string& value);
  std::string* _internal_mutable_principal();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string buyFeePercent = 8;
  void clear_buyfeepercent();
  const std::string& buyfeepercent() const;
  void set_buyfeepercent(const std::string& value);
  void set_buyfeepercent(std::string&& value);
  void set_buyfeepercent(const char* value);
  void set_buyfeepercent(const char* value, size_t size);
  std::string* mutable_buyfeepercent();
  std::string* release_buyfeepercent();
  void set_allocated_buyfeepercent(std::string* buyfeepercent);
  private:
  const std::string& _internal_buyfeepercent() const;
  void _internal_set_buyfeepercent(const std::string& value);
  std::string* _internal_mutable_buyfeepercent();
  public:

  // string sellFeePercent = 9;
  void clear_sellfeepercent();
  const std::string& sellfeepercent() const;
  void set_sellfeepercent(const std::string& value);
  void set_sellfeepercent(std::string&& value);
  void set_sellfeepercent(const char* value);
  void set_sellfeepercent(const char* value, size_t size);
  std::string* mutable_sellfeepercent();
  std::string* release_sellfeepercent();
  void set_allocated_sellfeepercent(std::string* sellfeepercent);
  private:
  const std::string& _internal_sellfeepercent() const;
  void _internal_set_sellfeepercent(const std::string& value);
  std::string* _internal_mutable_sellfeepercent();
  public:

  // .io.stakenet.orderbook.protos.BigInclusiveInterval buyFundsInterval = 4;
  bool has_buyfundsinterval() const;
  private:
  bool _internal_has_buyfundsinterval() const;
  public:
  void clear_buyfundsinterval();
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& buyfundsinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* release_buyfundsinterval();
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* mutable_buyfundsinterval();
  void set_allocated_buyfundsinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* buyfundsinterval);
  private:
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& _internal_buyfundsinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* _internal_mutable_buyfundsinterval();
  public:

  // .io.stakenet.orderbook.protos.BigInclusiveInterval buyPriceInterval = 5;
  bool has_buypriceinterval() const;
  private:
  bool _internal_has_buypriceinterval() const;
  public:
  void clear_buypriceinterval();
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& buypriceinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* release_buypriceinterval();
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* mutable_buypriceinterval();
  void set_allocated_buypriceinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* buypriceinterval);
  private:
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& _internal_buypriceinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* _internal_mutable_buypriceinterval();
  public:

  // .io.stakenet.orderbook.protos.BigInclusiveInterval sellFundsInterval = 6;
  bool has_sellfundsinterval() const;
  private:
  bool _internal_has_sellfundsinterval() const;
  public:
  void clear_sellfundsinterval();
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& sellfundsinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* release_sellfundsinterval();
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* mutable_sellfundsinterval();
  void set_allocated_sellfundsinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* sellfundsinterval);
  private:
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& _internal_sellfundsinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* _internal_mutable_sellfundsinterval();
  public:

  // .io.stakenet.orderbook.protos.BigInclusiveInterval sellPriceInterval = 7;
  bool has_sellpriceinterval() const;
  private:
  bool _internal_has_sellpriceinterval() const;
  public:
  void clear_sellpriceinterval();
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& sellpriceinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* release_sellpriceinterval();
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* mutable_sellpriceinterval();
  void set_allocated_sellpriceinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* sellpriceinterval);
  private:
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval& _internal_sellpriceinterval() const;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* _internal_mutable_sellpriceinterval();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.TradingPair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secondary_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr principal_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buyfeepercent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sellfeepercent_;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* buyfundsinterval_;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* buypriceinterval_;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* sellfundsinterval_;
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* sellpriceinterval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class RefundablePayment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.RefundablePayment) */ {
 public:
  RefundablePayment();
  virtual ~RefundablePayment();

  RefundablePayment(const RefundablePayment& from);
  RefundablePayment(RefundablePayment&& from) noexcept
    : RefundablePayment() {
    *this = ::std::move(from);
  }

  inline RefundablePayment& operator=(const RefundablePayment& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefundablePayment& operator=(RefundablePayment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RefundablePayment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefundablePayment* internal_default_instance() {
    return reinterpret_cast<const RefundablePayment*>(
               &_RefundablePayment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RefundablePayment& a, RefundablePayment& b) {
    a.Swap(&b);
  }
  inline void Swap(RefundablePayment* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RefundablePayment* New() const final {
    return CreateMaybeMessage<RefundablePayment>(nullptr);
  }

  RefundablePayment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RefundablePayment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RefundablePayment& from);
  void MergeFrom(const RefundablePayment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefundablePayment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.RefundablePayment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaymentHashFieldNumber = 2,
    kPaidAmountFieldNumber = 1,
  };
  // bytes paymentHash = 2;
  void clear_paymenthash();
  const std::string& paymenthash() const;
  void set_paymenthash(const std::string& value);
  void set_paymenthash(std::string&& value);
  void set_paymenthash(const char* value);
  void set_paymenthash(const void* value, size_t size);
  std::string* mutable_paymenthash();
  std::string* release_paymenthash();
  void set_allocated_paymenthash(std::string* paymenthash);
  private:
  const std::string& _internal_paymenthash() const;
  void _internal_set_paymenthash(const std::string& value);
  std::string* _internal_mutable_paymenthash();
  public:

  // .io.stakenet.orderbook.protos.BigInteger paidAmount = 1;
  bool has_paidamount() const;
  private:
  bool _internal_has_paidamount() const;
  public:
  void clear_paidamount();
  const ::io::stakenet::orderbook::protos::BigInteger& paidamount() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_paidamount();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_paidamount();
  void set_allocated_paidamount(::io::stakenet::orderbook::protos::BigInteger* paidamount);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_paidamount() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_paidamount();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.RefundablePayment)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paymenthash_;
  ::io::stakenet::orderbook::protos::BigInteger* paidamount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class OrderSummary :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.OrderSummary) */ {
 public:
  OrderSummary();
  virtual ~OrderSummary();

  OrderSummary(const OrderSummary& from);
  OrderSummary(OrderSummary&& from) noexcept
    : OrderSummary() {
    *this = ::std::move(from);
  }

  inline OrderSummary& operator=(const OrderSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderSummary& operator=(OrderSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderSummary* internal_default_instance() {
    return reinterpret_cast<const OrderSummary*>(
               &_OrderSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OrderSummary& a, OrderSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderSummary* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderSummary* New() const final {
    return CreateMaybeMessage<OrderSummary>(nullptr);
  }

  OrderSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderSummary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderSummary& from);
  void MergeFrom(const OrderSummary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.OrderSummary";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // .io.stakenet.orderbook.protos.BigInteger price = 1;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  const ::io::stakenet::orderbook::protos::BigInteger& price() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_price();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_price();
  void set_allocated_price(::io::stakenet::orderbook::protos::BigInteger* price);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_price() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_price();
  public:

  // .io.stakenet.orderbook.protos.BigInteger amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::io::stakenet::orderbook::protos::BigInteger& amount() const;
  ::io::stakenet::orderbook::protos::BigInteger* release_amount();
  ::io::stakenet::orderbook::protos::BigInteger* mutable_amount();
  void set_allocated_amount(::io::stakenet::orderbook::protos::BigInteger* amount);
  private:
  const ::io::stakenet::orderbook::protos::BigInteger& _internal_amount() const;
  ::io::stakenet::orderbook::protos::BigInteger* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.OrderSummary)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::io::stakenet::orderbook::protos::BigInteger* price_;
  ::io::stakenet::orderbook::protos::BigInteger* amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class ServerInMaintenance :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.ServerInMaintenance) */ {
 public:
  ServerInMaintenance();
  virtual ~ServerInMaintenance();

  ServerInMaintenance(const ServerInMaintenance& from);
  ServerInMaintenance(ServerInMaintenance&& from) noexcept
    : ServerInMaintenance() {
    *this = ::std::move(from);
  }

  inline ServerInMaintenance& operator=(const ServerInMaintenance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInMaintenance& operator=(ServerInMaintenance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerInMaintenance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerInMaintenance* internal_default_instance() {
    return reinterpret_cast<const ServerInMaintenance*>(
               &_ServerInMaintenance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ServerInMaintenance& a, ServerInMaintenance& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInMaintenance* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerInMaintenance* New() const final {
    return CreateMaybeMessage<ServerInMaintenance>(nullptr);
  }

  ServerInMaintenance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerInMaintenance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerInMaintenance& from);
  void MergeFrom(const ServerInMaintenance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInMaintenance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.ServerInMaintenance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.ServerInMaintenance)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class RentedChannel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.RentedChannel) */ {
 public:
  RentedChannel();
  virtual ~RentedChannel();

  RentedChannel(const RentedChannel& from);
  RentedChannel(RentedChannel&& from) noexcept
    : RentedChannel() {
    *this = ::std::move(from);
  }

  inline RentedChannel& operator=(const RentedChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline RentedChannel& operator=(RentedChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RentedChannel& default_instance();

  enum ValueCase {
    kLndChannel = 1,
    kConnextChannel = 2,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RentedChannel* internal_default_instance() {
    return reinterpret_cast<const RentedChannel*>(
               &_RentedChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RentedChannel& a, RentedChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(RentedChannel* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RentedChannel* New() const final {
    return CreateMaybeMessage<RentedChannel>(nullptr);
  }

  RentedChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RentedChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RentedChannel& from);
  void MergeFrom(const RentedChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RentedChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.RentedChannel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLndChannelFieldNumber = 1,
    kConnextChannelFieldNumber = 2,
  };
  // .io.stakenet.orderbook.protos.LndChannel lndChannel = 1;
  bool has_lndchannel() const;
  private:
  bool _internal_has_lndchannel() const;
  public:
  void clear_lndchannel();
  const ::io::stakenet::orderbook::protos::LndChannel& lndchannel() const;
  ::io::stakenet::orderbook::protos::LndChannel* release_lndchannel();
  ::io::stakenet::orderbook::protos::LndChannel* mutable_lndchannel();
  void set_allocated_lndchannel(::io::stakenet::orderbook::protos::LndChannel* lndchannel);
  private:
  const ::io::stakenet::orderbook::protos::LndChannel& _internal_lndchannel() const;
  ::io::stakenet::orderbook::protos::LndChannel* _internal_mutable_lndchannel();
  public:

  // .io.stakenet.orderbook.protos.ConnextChannel connextChannel = 2;
  bool has_connextchannel() const;
  private:
  bool _internal_has_connextchannel() const;
  public:
  void clear_connextchannel();
  const ::io::stakenet::orderbook::protos::ConnextChannel& connextchannel() const;
  ::io::stakenet::orderbook::protos::ConnextChannel* release_connextchannel();
  ::io::stakenet::orderbook::protos::ConnextChannel* mutable_connextchannel();
  void set_allocated_connextchannel(::io::stakenet::orderbook::protos::ConnextChannel* connextchannel);
  private:
  const ::io::stakenet::orderbook::protos::ConnextChannel& _internal_connextchannel() const;
  ::io::stakenet::orderbook::protos::ConnextChannel* _internal_mutable_connextchannel();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.RentedChannel)
 private:
  class _Internal;
  void set_has_lndchannel();
  void set_has_connextchannel();

  inline bool has_value() const;
  inline void clear_has_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::io::stakenet::orderbook::protos::LndChannel* lndchannel_;
    ::io::stakenet::orderbook::protos::ConnextChannel* connextchannel_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class LndChannel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.LndChannel) */ {
 public:
  LndChannel();
  virtual ~LndChannel();

  LndChannel(const LndChannel& from);
  LndChannel(LndChannel&& from) noexcept
    : LndChannel() {
    *this = ::std::move(from);
  }

  inline LndChannel& operator=(const LndChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline LndChannel& operator=(LndChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LndChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LndChannel* internal_default_instance() {
    return reinterpret_cast<const LndChannel*>(
               &_LndChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LndChannel& a, LndChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(LndChannel* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LndChannel* New() const final {
    return CreateMaybeMessage<LndChannel>(nullptr);
  }

  LndChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LndChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LndChannel& from);
  void MergeFrom(const LndChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LndChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.LndChannel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodePublicKeyFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kFundingTransactionFieldNumber = 3,
    kFundingTxidStrFieldNumber = 5,
    kOutputIndexFieldNumber = 4,
  };
  // bytes nodePublicKey = 1;
  void clear_nodepublickey();
  const std::string& nodepublickey() const;
  void set_nodepublickey(const std::string& value);
  void set_nodepublickey(std::string&& value);
  void set_nodepublickey(const char* value);
  void set_nodepublickey(const void* value, size_t size);
  std::string* mutable_nodepublickey();
  std::string* release_nodepublickey();
  void set_allocated_nodepublickey(std::string* nodepublickey);
  private:
  const std::string& _internal_nodepublickey() const;
  void _internal_set_nodepublickey(const std::string& value);
  std::string* _internal_mutable_nodepublickey();
  public:

  // string channelId = 2;
  void clear_channelid();
  const std::string& channelid() const;
  void set_channelid(const std::string& value);
  void set_channelid(std::string&& value);
  void set_channelid(const char* value);
  void set_channelid(const char* value, size_t size);
  std::string* mutable_channelid();
  std::string* release_channelid();
  void set_allocated_channelid(std::string* channelid);
  private:
  const std::string& _internal_channelid() const;
  void _internal_set_channelid(const std::string& value);
  std::string* _internal_mutable_channelid();
  public:

  // bytes fundingTransaction = 3;
  void clear_fundingtransaction();
  const std::string& fundingtransaction() const;
  void set_fundingtransaction(const std::string& value);
  void set_fundingtransaction(std::string&& value);
  void set_fundingtransaction(const char* value);
  void set_fundingtransaction(const void* value, size_t size);
  std::string* mutable_fundingtransaction();
  std::string* release_fundingtransaction();
  void set_allocated_fundingtransaction(std::string* fundingtransaction);
  private:
  const std::string& _internal_fundingtransaction() const;
  void _internal_set_fundingtransaction(const std::string& value);
  std::string* _internal_mutable_fundingtransaction();
  public:

  // string fundingTxidStr = 5;
  void clear_fundingtxidstr();
  const std::string& fundingtxidstr() const;
  void set_fundingtxidstr(const std::string& value);
  void set_fundingtxidstr(std::string&& value);
  void set_fundingtxidstr(const char* value);
  void set_fundingtxidstr(const char* value, size_t size);
  std::string* mutable_fundingtxidstr();
  std::string* release_fundingtxidstr();
  void set_allocated_fundingtxidstr(std::string* fundingtxidstr);
  private:
  const std::string& _internal_fundingtxidstr() const;
  void _internal_set_fundingtxidstr(const std::string& value);
  std::string* _internal_mutable_fundingtxidstr();
  public:

  // int32 outputIndex = 4;
  void clear_outputindex();
  ::PROTOBUF_NAMESPACE_ID::int32 outputindex() const;
  void set_outputindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_outputindex() const;
  void _internal_set_outputindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.LndChannel)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodepublickey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channelid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundingtransaction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundingtxidstr_;
  ::PROTOBUF_NAMESPACE_ID::int32 outputindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class ConnextChannel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.stakenet.orderbook.protos.ConnextChannel) */ {
 public:
  ConnextChannel();
  virtual ~ConnextChannel();

  ConnextChannel(const ConnextChannel& from);
  ConnextChannel(ConnextChannel&& from) noexcept
    : ConnextChannel() {
    *this = ::std::move(from);
  }

  inline ConnextChannel& operator=(const ConnextChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnextChannel& operator=(ConnextChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnextChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnextChannel* internal_default_instance() {
    return reinterpret_cast<const ConnextChannel*>(
               &_ConnextChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ConnextChannel& a, ConnextChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnextChannel* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnextChannel* New() const final {
    return CreateMaybeMessage<ConnextChannel>(nullptr);
  }

  ConnextChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnextChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnextChannel& from);
  void MergeFrom(const ConnextChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnextChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.stakenet.orderbook.protos.ConnextChannel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_stakenet_2forderbook_2fmodels_2eproto);
    return ::descriptor_table_stakenet_2forderbook_2fmodels_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodePublicIdentifierFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kChannelAddressFieldNumber = 3,
  };
  // string nodePublicIdentifier = 1;
  void clear_nodepublicidentifier();
  const std::string& nodepublicidentifier() const;
  void set_nodepublicidentifier(const std::string& value);
  void set_nodepublicidentifier(std::string&& value);
  void set_nodepublicidentifier(const char* value);
  void set_nodepublicidentifier(const char* value, size_t size);
  std::string* mutable_nodepublicidentifier();
  std::string* release_nodepublicidentifier();
  void set_allocated_nodepublicidentifier(std::string* nodepublicidentifier);
  private:
  const std::string& _internal_nodepublicidentifier() const;
  void _internal_set_nodepublicidentifier(const std::string& value);
  std::string* _internal_mutable_nodepublicidentifier();
  public:

  // string channelId = 2;
  void clear_channelid();
  const std::string& channelid() const;
  void set_channelid(const std::string& value);
  void set_channelid(std::string&& value);
  void set_channelid(const char* value);
  void set_channelid(const char* value, size_t size);
  std::string* mutable_channelid();
  std::string* release_channelid();
  void set_allocated_channelid(std::string* channelid);
  private:
  const std::string& _internal_channelid() const;
  void _internal_set_channelid(const std::string& value);
  std::string* _internal_mutable_channelid();
  public:

  // string channelAddress = 3;
  void clear_channeladdress();
  const std::string& channeladdress() const;
  void set_channeladdress(const std::string& value);
  void set_channeladdress(std::string&& value);
  void set_channeladdress(const char* value);
  void set_channeladdress(const char* value, size_t size);
  std::string* mutable_channeladdress();
  std::string* release_channeladdress();
  void set_allocated_channeladdress(std::string* channeladdress);
  private:
  const std::string& _internal_channeladdress() const;
  void _internal_set_channeladdress(const std::string& value);
  std::string* _internal_mutable_channeladdress();
  public:

  // @@protoc_insertion_point(class_scope:io.stakenet.orderbook.protos.ConnextChannel)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodepublicidentifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channelid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channeladdress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stakenet_2forderbook_2fmodels_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BigInteger

// string value = 1;
inline void BigInteger::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BigInteger::value() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BigInteger.value)
  return _internal_value();
}
inline void BigInteger::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.BigInteger.value)
}
inline std::string* BigInteger::mutable_value() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.BigInteger.value)
  return _internal_mutable_value();
}
inline const std::string& BigInteger::_internal_value() const {
  return value_.GetNoArena();
}
inline void BigInteger::_internal_set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BigInteger::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.BigInteger.value)
}
inline void BigInteger::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.BigInteger.value)
}
inline void BigInteger::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.BigInteger.value)
}
inline std::string* BigInteger::_internal_mutable_value() {
  
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BigInteger::release_value() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.BigInteger.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BigInteger::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.BigInteger.value)
}

// -------------------------------------------------------------------

// OrderDetails

// string orderId = 1;
inline void OrderDetails::clear_orderid() {
  orderid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OrderDetails::orderid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderDetails.orderId)
  return _internal_orderid();
}
inline void OrderDetails::set_orderid(const std::string& value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.OrderDetails.orderId)
}
inline std::string* OrderDetails::mutable_orderid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderDetails.orderId)
  return _internal_mutable_orderid();
}
inline const std::string& OrderDetails::_internal_orderid() const {
  return orderid_.GetNoArena();
}
inline void OrderDetails::_internal_set_orderid(const std::string& value) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OrderDetails::set_orderid(std::string&& value) {
  
  orderid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.OrderDetails.orderId)
}
inline void OrderDetails::set_orderid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.OrderDetails.orderId)
}
inline void OrderDetails::set_orderid(const char* value, size_t size) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.OrderDetails.orderId)
}
inline std::string* OrderDetails::_internal_mutable_orderid() {
  
  return orderid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OrderDetails::release_orderid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderDetails.orderId)
  
  return orderid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OrderDetails::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  orderid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orderid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderDetails.orderId)
}

// .io.stakenet.orderbook.protos.BigInteger funds = 2;
inline bool OrderDetails::_internal_has_funds() const {
  return this != internal_default_instance() && funds_ != nullptr;
}
inline bool OrderDetails::has_funds() const {
  return _internal_has_funds();
}
inline void OrderDetails::clear_funds() {
  if (GetArenaNoVirtual() == nullptr && funds_ != nullptr) {
    delete funds_;
  }
  funds_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderDetails::_internal_funds() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = funds_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderDetails::funds() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderDetails.funds)
  return _internal_funds();
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderDetails::release_funds() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderDetails.funds)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = funds_;
  funds_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderDetails::_internal_mutable_funds() {
  
  if (funds_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    funds_ = p;
  }
  return funds_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderDetails::mutable_funds() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderDetails.funds)
  return _internal_mutable_funds();
}
inline void OrderDetails::set_allocated_funds(::io::stakenet::orderbook::protos::BigInteger* funds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete funds_;
  }
  if (funds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      funds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, funds, submessage_arena);
    }
    
  } else {
    
  }
  funds_ = funds;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderDetails.funds)
}

// .io.stakenet.orderbook.protos.BigInteger price = 3;
inline bool OrderDetails::_internal_has_price() const {
  return this != internal_default_instance() && price_ != nullptr;
}
inline bool OrderDetails::has_price() const {
  return _internal_has_price();
}
inline void OrderDetails::clear_price() {
  if (GetArenaNoVirtual() == nullptr && price_ != nullptr) {
    delete price_;
  }
  price_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderDetails::_internal_price() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = price_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderDetails::price() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderDetails.price)
  return _internal_price();
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderDetails::release_price() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderDetails.price)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = price_;
  price_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderDetails::_internal_mutable_price() {
  
  if (price_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    price_ = p;
  }
  return price_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderDetails::mutable_price() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderDetails.price)
  return _internal_mutable_price();
}
inline void OrderDetails::set_allocated_price(::io::stakenet::orderbook::protos::BigInteger* price) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete price_;
  }
  if (price) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      price = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price, submessage_arena);
    }
    
  } else {
    
  }
  price_ = price;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderDetails.price)
}

// -------------------------------------------------------------------

// Order

// string tradingPair = 1;
inline void Order::clear_tradingpair() {
  tradingpair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Order::tradingpair() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Order.tradingPair)
  return _internal_tradingpair();
}
inline void Order::set_tradingpair(const std::string& value) {
  _internal_set_tradingpair(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Order.tradingPair)
}
inline std::string* Order::mutable_tradingpair() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Order.tradingPair)
  return _internal_mutable_tradingpair();
}
inline const std::string& Order::_internal_tradingpair() const {
  return tradingpair_.GetNoArena();
}
inline void Order::_internal_set_tradingpair(const std::string& value) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Order::set_tradingpair(std::string&& value) {
  
  tradingpair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.Order.tradingPair)
}
inline void Order::set_tradingpair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.Order.tradingPair)
}
inline void Order::set_tradingpair(const char* value, size_t size) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.Order.tradingPair)
}
inline std::string* Order::_internal_mutable_tradingpair() {
  
  return tradingpair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Order::release_tradingpair() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Order.tradingPair)
  
  return tradingpair_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Order::set_allocated_tradingpair(std::string* tradingpair) {
  if (tradingpair != nullptr) {
    
  } else {
    
  }
  tradingpair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tradingpair);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Order.tradingPair)
}

// .io.stakenet.orderbook.protos.Order.OrderType type = 2;
inline void Order::clear_type() {
  type_ = 0;
}
inline ::io::stakenet::orderbook::protos::Order_OrderType Order::_internal_type() const {
  return static_cast< ::io::stakenet::orderbook::protos::Order_OrderType >(type_);
}
inline ::io::stakenet::orderbook::protos::Order_OrderType Order::type() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Order.type)
  return _internal_type();
}
inline void Order::_internal_set_type(::io::stakenet::orderbook::protos::Order_OrderType value) {
  
  type_ = value;
}
inline void Order::set_type(::io::stakenet::orderbook::protos::Order_OrderType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Order.type)
}

// .io.stakenet.orderbook.protos.Order.OrderSide side = 3;
inline void Order::clear_side() {
  side_ = 0;
}
inline ::io::stakenet::orderbook::protos::Order_OrderSide Order::_internal_side() const {
  return static_cast< ::io::stakenet::orderbook::protos::Order_OrderSide >(side_);
}
inline ::io::stakenet::orderbook::protos::Order_OrderSide Order::side() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Order.side)
  return _internal_side();
}
inline void Order::_internal_set_side(::io::stakenet::orderbook::protos::Order_OrderSide value) {
  
  side_ = value;
}
inline void Order::set_side(::io::stakenet::orderbook::protos::Order_OrderSide value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Order.side)
}

// .io.stakenet.orderbook.protos.OrderDetails details = 4;
inline bool Order::_internal_has_details() const {
  return this != internal_default_instance() && details_ != nullptr;
}
inline bool Order::has_details() const {
  return _internal_has_details();
}
inline void Order::clear_details() {
  if (GetArenaNoVirtual() == nullptr && details_ != nullptr) {
    delete details_;
  }
  details_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::OrderDetails& Order::_internal_details() const {
  const ::io::stakenet::orderbook::protos::OrderDetails* p = details_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::OrderDetails*>(
      &::io::stakenet::orderbook::protos::_OrderDetails_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::OrderDetails& Order::details() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Order.details)
  return _internal_details();
}
inline ::io::stakenet::orderbook::protos::OrderDetails* Order::release_details() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Order.details)
  
  ::io::stakenet::orderbook::protos::OrderDetails* temp = details_;
  details_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::OrderDetails* Order::_internal_mutable_details() {
  
  if (details_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::OrderDetails>(GetArenaNoVirtual());
    details_ = p;
  }
  return details_;
}
inline ::io::stakenet::orderbook::protos::OrderDetails* Order::mutable_details() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Order.details)
  return _internal_mutable_details();
}
inline void Order::set_allocated_details(::io::stakenet::orderbook::protos::OrderDetails* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete details_;
  }
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    
  } else {
    
  }
  details_ = details;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Order.details)
}

// -------------------------------------------------------------------

// Trade

// string id = 1;
inline void Trade::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Trade::id() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.id)
  return _internal_id();
}
inline void Trade::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Trade.id)
}
inline std::string* Trade::mutable_id() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.id)
  return _internal_mutable_id();
}
inline const std::string& Trade::_internal_id() const {
  return id_.GetNoArena();
}
inline void Trade::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Trade::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.Trade.id)
}
inline void Trade::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.Trade.id)
}
inline void Trade::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.Trade.id)
}
inline std::string* Trade::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Trade::release_id() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Trade::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.id)
}

// string tradingPair = 2;
inline void Trade::clear_tradingpair() {
  tradingpair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Trade::tradingpair() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.tradingPair)
  return _internal_tradingpair();
}
inline void Trade::set_tradingpair(const std::string& value) {
  _internal_set_tradingpair(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Trade.tradingPair)
}
inline std::string* Trade::mutable_tradingpair() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.tradingPair)
  return _internal_mutable_tradingpair();
}
inline const std::string& Trade::_internal_tradingpair() const {
  return tradingpair_.GetNoArena();
}
inline void Trade::_internal_set_tradingpair(const std::string& value) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Trade::set_tradingpair(std::string&& value) {
  
  tradingpair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.Trade.tradingPair)
}
inline void Trade::set_tradingpair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.Trade.tradingPair)
}
inline void Trade::set_tradingpair(const char* value, size_t size) {
  
  tradingpair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.Trade.tradingPair)
}
inline std::string* Trade::_internal_mutable_tradingpair() {
  
  return tradingpair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Trade::release_tradingpair() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.tradingPair)
  
  return tradingpair_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Trade::set_allocated_tradingpair(std::string* tradingpair) {
  if (tradingpair != nullptr) {
    
  } else {
    
  }
  tradingpair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tradingpair);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.tradingPair)
}

// .io.stakenet.orderbook.protos.BigInteger price = 3;
inline bool Trade::_internal_has_price() const {
  return this != internal_default_instance() && price_ != nullptr;
}
inline bool Trade::has_price() const {
  return _internal_has_price();
}
inline void Trade::clear_price() {
  if (GetArenaNoVirtual() == nullptr && price_ != nullptr) {
    delete price_;
  }
  price_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& Trade::_internal_price() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = price_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& Trade::price() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.price)
  return _internal_price();
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::release_price() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.price)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = price_;
  price_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::_internal_mutable_price() {
  
  if (price_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    price_ = p;
  }
  return price_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::mutable_price() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.price)
  return _internal_mutable_price();
}
inline void Trade::set_allocated_price(::io::stakenet::orderbook::protos::BigInteger* price) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete price_;
  }
  if (price) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      price = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price, submessage_arena);
    }
    
  } else {
    
  }
  price_ = price;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.price)
}

// .io.stakenet.orderbook.protos.BigInteger size = 4;
inline bool Trade::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Trade::has_size() const {
  return _internal_has_size();
}
inline void Trade::clear_size() {
  if (GetArenaNoVirtual() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& Trade::_internal_size() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& Trade::size() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.size)
  return _internal_size();
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::release_size() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.size)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    size_ = p;
  }
  return size_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::mutable_size() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.size)
  return _internal_mutable_size();
}
inline void Trade::set_allocated_size(::io::stakenet::orderbook::protos::BigInteger* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.size)
}

// string existingOrderId = 5;
inline void Trade::clear_existingorderid() {
  existingorderid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Trade::existingorderid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.existingOrderId)
  return _internal_existingorderid();
}
inline void Trade::set_existingorderid(const std::string& value) {
  _internal_set_existingorderid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Trade.existingOrderId)
}
inline std::string* Trade::mutable_existingorderid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.existingOrderId)
  return _internal_mutable_existingorderid();
}
inline const std::string& Trade::_internal_existingorderid() const {
  return existingorderid_.GetNoArena();
}
inline void Trade::_internal_set_existingorderid(const std::string& value) {
  
  existingorderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Trade::set_existingorderid(std::string&& value) {
  
  existingorderid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.Trade.existingOrderId)
}
inline void Trade::set_existingorderid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  existingorderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.Trade.existingOrderId)
}
inline void Trade::set_existingorderid(const char* value, size_t size) {
  
  existingorderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.Trade.existingOrderId)
}
inline std::string* Trade::_internal_mutable_existingorderid() {
  
  return existingorderid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Trade::release_existingorderid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.existingOrderId)
  
  return existingorderid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Trade::set_allocated_existingorderid(std::string* existingorderid) {
  if (existingorderid != nullptr) {
    
  } else {
    
  }
  existingorderid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), existingorderid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.existingOrderId)
}

// string executingOrderId = 6;
inline void Trade::clear_executingorderid() {
  executingorderid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Trade::executingorderid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.executingOrderId)
  return _internal_executingorderid();
}
inline void Trade::set_executingorderid(const std::string& value) {
  _internal_set_executingorderid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Trade.executingOrderId)
}
inline std::string* Trade::mutable_executingorderid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.executingOrderId)
  return _internal_mutable_executingorderid();
}
inline const std::string& Trade::_internal_executingorderid() const {
  return executingorderid_.GetNoArena();
}
inline void Trade::_internal_set_executingorderid(const std::string& value) {
  
  executingorderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Trade::set_executingorderid(std::string&& value) {
  
  executingorderid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.Trade.executingOrderId)
}
inline void Trade::set_executingorderid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  executingorderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.Trade.executingOrderId)
}
inline void Trade::set_executingorderid(const char* value, size_t size) {
  
  executingorderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.Trade.executingOrderId)
}
inline std::string* Trade::_internal_mutable_executingorderid() {
  
  return executingorderid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Trade::release_executingorderid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.executingOrderId)
  
  return executingorderid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Trade::set_allocated_executingorderid(std::string* executingorderid) {
  if (executingorderid != nullptr) {
    
  } else {
    
  }
  executingorderid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), executingorderid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.executingOrderId)
}

// string executingOrderSide = 7;
inline void Trade::clear_executingorderside() {
  executingorderside_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Trade::executingorderside() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.executingOrderSide)
  return _internal_executingorderside();
}
inline void Trade::set_executingorderside(const std::string& value) {
  _internal_set_executingorderside(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Trade.executingOrderSide)
}
inline std::string* Trade::mutable_executingorderside() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.executingOrderSide)
  return _internal_mutable_executingorderside();
}
inline const std::string& Trade::_internal_executingorderside() const {
  return executingorderside_.GetNoArena();
}
inline void Trade::_internal_set_executingorderside(const std::string& value) {
  
  executingorderside_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Trade::set_executingorderside(std::string&& value) {
  
  executingorderside_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.Trade.executingOrderSide)
}
inline void Trade::set_executingorderside(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  executingorderside_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.Trade.executingOrderSide)
}
inline void Trade::set_executingorderside(const char* value, size_t size) {
  
  executingorderside_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.Trade.executingOrderSide)
}
inline std::string* Trade::_internal_mutable_executingorderside() {
  
  return executingorderside_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Trade::release_executingorderside() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.executingOrderSide)
  
  return executingorderside_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Trade::set_allocated_executingorderside(std::string* executingorderside) {
  if (executingorderside != nullptr) {
    
  } else {
    
  }
  executingorderside_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), executingorderside);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.executingOrderSide)
}

// int64 executedOn = 8;
inline void Trade::clear_executedon() {
  executedon_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Trade::_internal_executedon() const {
  return executedon_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Trade::executedon() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.executedOn)
  return _internal_executedon();
}
inline void Trade::_internal_set_executedon(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  executedon_ = value;
}
inline void Trade::set_executedon(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_executedon(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.Trade.executedOn)
}

// .io.stakenet.orderbook.protos.BigInteger existingOrderFunds = 9;
inline bool Trade::_internal_has_existingorderfunds() const {
  return this != internal_default_instance() && existingorderfunds_ != nullptr;
}
inline bool Trade::has_existingorderfunds() const {
  return _internal_has_existingorderfunds();
}
inline void Trade::clear_existingorderfunds() {
  if (GetArenaNoVirtual() == nullptr && existingorderfunds_ != nullptr) {
    delete existingorderfunds_;
  }
  existingorderfunds_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& Trade::_internal_existingorderfunds() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = existingorderfunds_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& Trade::existingorderfunds() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.Trade.existingOrderFunds)
  return _internal_existingorderfunds();
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::release_existingorderfunds() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.Trade.existingOrderFunds)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = existingorderfunds_;
  existingorderfunds_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::_internal_mutable_existingorderfunds() {
  
  if (existingorderfunds_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    existingorderfunds_ = p;
  }
  return existingorderfunds_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* Trade::mutable_existingorderfunds() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.Trade.existingOrderFunds)
  return _internal_mutable_existingorderfunds();
}
inline void Trade::set_allocated_existingorderfunds(::io::stakenet::orderbook::protos::BigInteger* existingorderfunds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete existingorderfunds_;
  }
  if (existingorderfunds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      existingorderfunds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, existingorderfunds, submessage_arena);
    }
    
  } else {
    
  }
  existingorderfunds_ = existingorderfunds;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.Trade.existingOrderFunds)
}

// -------------------------------------------------------------------

// BarPrices

// int64 time = 1;
inline void BarPrices::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BarPrices::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BarPrices::time() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BarPrices.time)
  return _internal_time();
}
inline void BarPrices::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  time_ = value;
}
inline void BarPrices::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.BarPrices.time)
}

// .io.stakenet.orderbook.protos.BigInteger open = 2;
inline bool BarPrices::_internal_has_open() const {
  return this != internal_default_instance() && open_ != nullptr;
}
inline bool BarPrices::has_open() const {
  return _internal_has_open();
}
inline void BarPrices::clear_open() {
  if (GetArenaNoVirtual() == nullptr && open_ != nullptr) {
    delete open_;
  }
  open_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::_internal_open() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = open_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::open() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BarPrices.open)
  return _internal_open();
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::release_open() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.BarPrices.open)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = open_;
  open_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::_internal_mutable_open() {
  
  if (open_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    open_ = p;
  }
  return open_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::mutable_open() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.BarPrices.open)
  return _internal_mutable_open();
}
inline void BarPrices::set_allocated_open(::io::stakenet::orderbook::protos::BigInteger* open) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete open_;
  }
  if (open) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      open = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open, submessage_arena);
    }
    
  } else {
    
  }
  open_ = open;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.BarPrices.open)
}

// .io.stakenet.orderbook.protos.BigInteger high = 3;
inline bool BarPrices::_internal_has_high() const {
  return this != internal_default_instance() && high_ != nullptr;
}
inline bool BarPrices::has_high() const {
  return _internal_has_high();
}
inline void BarPrices::clear_high() {
  if (GetArenaNoVirtual() == nullptr && high_ != nullptr) {
    delete high_;
  }
  high_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::_internal_high() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = high_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::high() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BarPrices.high)
  return _internal_high();
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::release_high() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.BarPrices.high)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = high_;
  high_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::_internal_mutable_high() {
  
  if (high_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    high_ = p;
  }
  return high_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::mutable_high() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.BarPrices.high)
  return _internal_mutable_high();
}
inline void BarPrices::set_allocated_high(::io::stakenet::orderbook::protos::BigInteger* high) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete high_;
  }
  if (high) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      high = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, high, submessage_arena);
    }
    
  } else {
    
  }
  high_ = high;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.BarPrices.high)
}

// .io.stakenet.orderbook.protos.BigInteger low = 4;
inline bool BarPrices::_internal_has_low() const {
  return this != internal_default_instance() && low_ != nullptr;
}
inline bool BarPrices::has_low() const {
  return _internal_has_low();
}
inline void BarPrices::clear_low() {
  if (GetArenaNoVirtual() == nullptr && low_ != nullptr) {
    delete low_;
  }
  low_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::_internal_low() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = low_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::low() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BarPrices.low)
  return _internal_low();
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::release_low() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.BarPrices.low)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = low_;
  low_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::_internal_mutable_low() {
  
  if (low_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    low_ = p;
  }
  return low_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::mutable_low() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.BarPrices.low)
  return _internal_mutable_low();
}
inline void BarPrices::set_allocated_low(::io::stakenet::orderbook::protos::BigInteger* low) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete low_;
  }
  if (low) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      low = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low, submessage_arena);
    }
    
  } else {
    
  }
  low_ = low;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.BarPrices.low)
}

// .io.stakenet.orderbook.protos.BigInteger close = 5;
inline bool BarPrices::_internal_has_close() const {
  return this != internal_default_instance() && close_ != nullptr;
}
inline bool BarPrices::has_close() const {
  return _internal_has_close();
}
inline void BarPrices::clear_close() {
  if (GetArenaNoVirtual() == nullptr && close_ != nullptr) {
    delete close_;
  }
  close_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::_internal_close() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = close_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BarPrices::close() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BarPrices.close)
  return _internal_close();
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::release_close() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.BarPrices.close)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = close_;
  close_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::_internal_mutable_close() {
  
  if (close_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    close_ = p;
  }
  return close_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BarPrices::mutable_close() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.BarPrices.close)
  return _internal_mutable_close();
}
inline void BarPrices::set_allocated_close(::io::stakenet::orderbook::protos::BigInteger* close) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete close_;
  }
  if (close) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      close = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close, submessage_arena);
    }
    
  } else {
    
  }
  close_ = close;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.BarPrices.close)
}

// int64 volume = 6;
inline void BarPrices::clear_volume() {
  volume_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BarPrices::_internal_volume() const {
  return volume_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BarPrices::volume() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BarPrices.volume)
  return _internal_volume();
}
inline void BarPrices::_internal_set_volume(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  volume_ = value;
}
inline void BarPrices::set_volume(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.BarPrices.volume)
}

// -------------------------------------------------------------------

// BigInclusiveInterval

// .io.stakenet.orderbook.protos.BigInteger from = 1;
inline bool BigInclusiveInterval::_internal_has_from() const {
  return this != internal_default_instance() && from_ != nullptr;
}
inline bool BigInclusiveInterval::has_from() const {
  return _internal_has_from();
}
inline void BigInclusiveInterval::clear_from() {
  if (GetArenaNoVirtual() == nullptr && from_ != nullptr) {
    delete from_;
  }
  from_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BigInclusiveInterval::_internal_from() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = from_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BigInclusiveInterval::from() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BigInclusiveInterval.from)
  return _internal_from();
}
inline ::io::stakenet::orderbook::protos::BigInteger* BigInclusiveInterval::release_from() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.BigInclusiveInterval.from)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = from_;
  from_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BigInclusiveInterval::_internal_mutable_from() {
  
  if (from_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    from_ = p;
  }
  return from_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BigInclusiveInterval::mutable_from() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.BigInclusiveInterval.from)
  return _internal_mutable_from();
}
inline void BigInclusiveInterval::set_allocated_from(::io::stakenet::orderbook::protos::BigInteger* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.BigInclusiveInterval.from)
}

// .io.stakenet.orderbook.protos.BigInteger to = 2;
inline bool BigInclusiveInterval::_internal_has_to() const {
  return this != internal_default_instance() && to_ != nullptr;
}
inline bool BigInclusiveInterval::has_to() const {
  return _internal_has_to();
}
inline void BigInclusiveInterval::clear_to() {
  if (GetArenaNoVirtual() == nullptr && to_ != nullptr) {
    delete to_;
  }
  to_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BigInclusiveInterval::_internal_to() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = to_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& BigInclusiveInterval::to() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.BigInclusiveInterval.to)
  return _internal_to();
}
inline ::io::stakenet::orderbook::protos::BigInteger* BigInclusiveInterval::release_to() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.BigInclusiveInterval.to)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = to_;
  to_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BigInclusiveInterval::_internal_mutable_to() {
  
  if (to_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    to_ = p;
  }
  return to_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* BigInclusiveInterval::mutable_to() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.BigInclusiveInterval.to)
  return _internal_mutable_to();
}
inline void BigInclusiveInterval::set_allocated_to(::io::stakenet::orderbook::protos::BigInteger* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  to_ = to;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.BigInclusiveInterval.to)
}

// -------------------------------------------------------------------

// TradingPair

// string principal = 2;
inline void TradingPair::clear_principal() {
  principal_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TradingPair::principal() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.principal)
  return _internal_principal();
}
inline void TradingPair::set_principal(const std::string& value) {
  _internal_set_principal(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.TradingPair.principal)
}
inline std::string* TradingPair::mutable_principal() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.principal)
  return _internal_mutable_principal();
}
inline const std::string& TradingPair::_internal_principal() const {
  return principal_.GetNoArena();
}
inline void TradingPair::_internal_set_principal(const std::string& value) {
  
  principal_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TradingPair::set_principal(std::string&& value) {
  
  principal_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.TradingPair.principal)
}
inline void TradingPair::set_principal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  principal_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.TradingPair.principal)
}
inline void TradingPair::set_principal(const char* value, size_t size) {
  
  principal_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.TradingPair.principal)
}
inline std::string* TradingPair::_internal_mutable_principal() {
  
  return principal_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TradingPair::release_principal() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.principal)
  
  return principal_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TradingPair::set_allocated_principal(std::string* principal) {
  if (principal != nullptr) {
    
  } else {
    
  }
  principal_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.principal)
}

// string secondary = 1;
inline void TradingPair::clear_secondary() {
  secondary_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TradingPair::secondary() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.secondary)
  return _internal_secondary();
}
inline void TradingPair::set_secondary(const std::string& value) {
  _internal_set_secondary(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.TradingPair.secondary)
}
inline std::string* TradingPair::mutable_secondary() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.secondary)
  return _internal_mutable_secondary();
}
inline const std::string& TradingPair::_internal_secondary() const {
  return secondary_.GetNoArena();
}
inline void TradingPair::_internal_set_secondary(const std::string& value) {
  
  secondary_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TradingPair::set_secondary(std::string&& value) {
  
  secondary_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.TradingPair.secondary)
}
inline void TradingPair::set_secondary(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  secondary_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.TradingPair.secondary)
}
inline void TradingPair::set_secondary(const char* value, size_t size) {
  
  secondary_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.TradingPair.secondary)
}
inline std::string* TradingPair::_internal_mutable_secondary() {
  
  return secondary_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TradingPair::release_secondary() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.secondary)
  
  return secondary_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TradingPair::set_allocated_secondary(std::string* secondary) {
  if (secondary != nullptr) {
    
  } else {
    
  }
  secondary_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secondary);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.secondary)
}

// string id = 3;
inline void TradingPair::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TradingPair::id() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.id)
  return _internal_id();
}
inline void TradingPair::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.TradingPair.id)
}
inline std::string* TradingPair::mutable_id() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.id)
  return _internal_mutable_id();
}
inline const std::string& TradingPair::_internal_id() const {
  return id_.GetNoArena();
}
inline void TradingPair::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TradingPair::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.TradingPair.id)
}
inline void TradingPair::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.TradingPair.id)
}
inline void TradingPair::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.TradingPair.id)
}
inline std::string* TradingPair::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TradingPair::release_id() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TradingPair::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.id)
}

// .io.stakenet.orderbook.protos.BigInclusiveInterval buyFundsInterval = 4;
inline bool TradingPair::_internal_has_buyfundsinterval() const {
  return this != internal_default_instance() && buyfundsinterval_ != nullptr;
}
inline bool TradingPair::has_buyfundsinterval() const {
  return _internal_has_buyfundsinterval();
}
inline void TradingPair::clear_buyfundsinterval() {
  if (GetArenaNoVirtual() == nullptr && buyfundsinterval_ != nullptr) {
    delete buyfundsinterval_;
  }
  buyfundsinterval_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::_internal_buyfundsinterval() const {
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval* p = buyfundsinterval_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInclusiveInterval*>(
      &::io::stakenet::orderbook::protos::_BigInclusiveInterval_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::buyfundsinterval() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.buyFundsInterval)
  return _internal_buyfundsinterval();
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::release_buyfundsinterval() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.buyFundsInterval)
  
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* temp = buyfundsinterval_;
  buyfundsinterval_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::_internal_mutable_buyfundsinterval() {
  
  if (buyfundsinterval_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInclusiveInterval>(GetArenaNoVirtual());
    buyfundsinterval_ = p;
  }
  return buyfundsinterval_;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::mutable_buyfundsinterval() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.buyFundsInterval)
  return _internal_mutable_buyfundsinterval();
}
inline void TradingPair::set_allocated_buyfundsinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* buyfundsinterval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete buyfundsinterval_;
  }
  if (buyfundsinterval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buyfundsinterval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buyfundsinterval, submessage_arena);
    }
    
  } else {
    
  }
  buyfundsinterval_ = buyfundsinterval;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.buyFundsInterval)
}

// .io.stakenet.orderbook.protos.BigInclusiveInterval buyPriceInterval = 5;
inline bool TradingPair::_internal_has_buypriceinterval() const {
  return this != internal_default_instance() && buypriceinterval_ != nullptr;
}
inline bool TradingPair::has_buypriceinterval() const {
  return _internal_has_buypriceinterval();
}
inline void TradingPair::clear_buypriceinterval() {
  if (GetArenaNoVirtual() == nullptr && buypriceinterval_ != nullptr) {
    delete buypriceinterval_;
  }
  buypriceinterval_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::_internal_buypriceinterval() const {
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval* p = buypriceinterval_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInclusiveInterval*>(
      &::io::stakenet::orderbook::protos::_BigInclusiveInterval_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::buypriceinterval() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.buyPriceInterval)
  return _internal_buypriceinterval();
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::release_buypriceinterval() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.buyPriceInterval)
  
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* temp = buypriceinterval_;
  buypriceinterval_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::_internal_mutable_buypriceinterval() {
  
  if (buypriceinterval_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInclusiveInterval>(GetArenaNoVirtual());
    buypriceinterval_ = p;
  }
  return buypriceinterval_;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::mutable_buypriceinterval() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.buyPriceInterval)
  return _internal_mutable_buypriceinterval();
}
inline void TradingPair::set_allocated_buypriceinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* buypriceinterval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete buypriceinterval_;
  }
  if (buypriceinterval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buypriceinterval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buypriceinterval, submessage_arena);
    }
    
  } else {
    
  }
  buypriceinterval_ = buypriceinterval;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.buyPriceInterval)
}

// .io.stakenet.orderbook.protos.BigInclusiveInterval sellFundsInterval = 6;
inline bool TradingPair::_internal_has_sellfundsinterval() const {
  return this != internal_default_instance() && sellfundsinterval_ != nullptr;
}
inline bool TradingPair::has_sellfundsinterval() const {
  return _internal_has_sellfundsinterval();
}
inline void TradingPair::clear_sellfundsinterval() {
  if (GetArenaNoVirtual() == nullptr && sellfundsinterval_ != nullptr) {
    delete sellfundsinterval_;
  }
  sellfundsinterval_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::_internal_sellfundsinterval() const {
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval* p = sellfundsinterval_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInclusiveInterval*>(
      &::io::stakenet::orderbook::protos::_BigInclusiveInterval_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::sellfundsinterval() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.sellFundsInterval)
  return _internal_sellfundsinterval();
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::release_sellfundsinterval() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.sellFundsInterval)
  
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* temp = sellfundsinterval_;
  sellfundsinterval_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::_internal_mutable_sellfundsinterval() {
  
  if (sellfundsinterval_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInclusiveInterval>(GetArenaNoVirtual());
    sellfundsinterval_ = p;
  }
  return sellfundsinterval_;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::mutable_sellfundsinterval() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.sellFundsInterval)
  return _internal_mutable_sellfundsinterval();
}
inline void TradingPair::set_allocated_sellfundsinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* sellfundsinterval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sellfundsinterval_;
  }
  if (sellfundsinterval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sellfundsinterval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sellfundsinterval, submessage_arena);
    }
    
  } else {
    
  }
  sellfundsinterval_ = sellfundsinterval;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.sellFundsInterval)
}

// .io.stakenet.orderbook.protos.BigInclusiveInterval sellPriceInterval = 7;
inline bool TradingPair::_internal_has_sellpriceinterval() const {
  return this != internal_default_instance() && sellpriceinterval_ != nullptr;
}
inline bool TradingPair::has_sellpriceinterval() const {
  return _internal_has_sellpriceinterval();
}
inline void TradingPair::clear_sellpriceinterval() {
  if (GetArenaNoVirtual() == nullptr && sellpriceinterval_ != nullptr) {
    delete sellpriceinterval_;
  }
  sellpriceinterval_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::_internal_sellpriceinterval() const {
  const ::io::stakenet::orderbook::protos::BigInclusiveInterval* p = sellpriceinterval_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInclusiveInterval*>(
      &::io::stakenet::orderbook::protos::_BigInclusiveInterval_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInclusiveInterval& TradingPair::sellpriceinterval() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.sellPriceInterval)
  return _internal_sellpriceinterval();
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::release_sellpriceinterval() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.sellPriceInterval)
  
  ::io::stakenet::orderbook::protos::BigInclusiveInterval* temp = sellpriceinterval_;
  sellpriceinterval_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::_internal_mutable_sellpriceinterval() {
  
  if (sellpriceinterval_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInclusiveInterval>(GetArenaNoVirtual());
    sellpriceinterval_ = p;
  }
  return sellpriceinterval_;
}
inline ::io::stakenet::orderbook::protos::BigInclusiveInterval* TradingPair::mutable_sellpriceinterval() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.sellPriceInterval)
  return _internal_mutable_sellpriceinterval();
}
inline void TradingPair::set_allocated_sellpriceinterval(::io::stakenet::orderbook::protos::BigInclusiveInterval* sellpriceinterval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sellpriceinterval_;
  }
  if (sellpriceinterval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sellpriceinterval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sellpriceinterval, submessage_arena);
    }
    
  } else {
    
  }
  sellpriceinterval_ = sellpriceinterval;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.sellPriceInterval)
}

// string buyFeePercent = 8;
inline void TradingPair::clear_buyfeepercent() {
  buyfeepercent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TradingPair::buyfeepercent() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
  return _internal_buyfeepercent();
}
inline void TradingPair::set_buyfeepercent(const std::string& value) {
  _internal_set_buyfeepercent(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
}
inline std::string* TradingPair::mutable_buyfeepercent() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
  return _internal_mutable_buyfeepercent();
}
inline const std::string& TradingPair::_internal_buyfeepercent() const {
  return buyfeepercent_.GetNoArena();
}
inline void TradingPair::_internal_set_buyfeepercent(const std::string& value) {
  
  buyfeepercent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TradingPair::set_buyfeepercent(std::string&& value) {
  
  buyfeepercent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
}
inline void TradingPair::set_buyfeepercent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  buyfeepercent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
}
inline void TradingPair::set_buyfeepercent(const char* value, size_t size) {
  
  buyfeepercent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
}
inline std::string* TradingPair::_internal_mutable_buyfeepercent() {
  
  return buyfeepercent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TradingPair::release_buyfeepercent() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
  
  return buyfeepercent_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TradingPair::set_allocated_buyfeepercent(std::string* buyfeepercent) {
  if (buyfeepercent != nullptr) {
    
  } else {
    
  }
  buyfeepercent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buyfeepercent);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.buyFeePercent)
}

// string sellFeePercent = 9;
inline void TradingPair::clear_sellfeepercent() {
  sellfeepercent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TradingPair::sellfeepercent() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
  return _internal_sellfeepercent();
}
inline void TradingPair::set_sellfeepercent(const std::string& value) {
  _internal_set_sellfeepercent(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
}
inline std::string* TradingPair::mutable_sellfeepercent() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
  return _internal_mutable_sellfeepercent();
}
inline const std::string& TradingPair::_internal_sellfeepercent() const {
  return sellfeepercent_.GetNoArena();
}
inline void TradingPair::_internal_set_sellfeepercent(const std::string& value) {
  
  sellfeepercent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TradingPair::set_sellfeepercent(std::string&& value) {
  
  sellfeepercent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
}
inline void TradingPair::set_sellfeepercent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sellfeepercent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
}
inline void TradingPair::set_sellfeepercent(const char* value, size_t size) {
  
  sellfeepercent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
}
inline std::string* TradingPair::_internal_mutable_sellfeepercent() {
  
  return sellfeepercent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TradingPair::release_sellfeepercent() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
  
  return sellfeepercent_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TradingPair::set_allocated_sellfeepercent(std::string* sellfeepercent) {
  if (sellfeepercent != nullptr) {
    
  } else {
    
  }
  sellfeepercent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sellfeepercent);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.TradingPair.sellFeePercent)
}

// -------------------------------------------------------------------

// RefundablePayment

// .io.stakenet.orderbook.protos.BigInteger paidAmount = 1;
inline bool RefundablePayment::_internal_has_paidamount() const {
  return this != internal_default_instance() && paidamount_ != nullptr;
}
inline bool RefundablePayment::has_paidamount() const {
  return _internal_has_paidamount();
}
inline void RefundablePayment::clear_paidamount() {
  if (GetArenaNoVirtual() == nullptr && paidamount_ != nullptr) {
    delete paidamount_;
  }
  paidamount_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& RefundablePayment::_internal_paidamount() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = paidamount_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& RefundablePayment::paidamount() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RefundablePayment.paidAmount)
  return _internal_paidamount();
}
inline ::io::stakenet::orderbook::protos::BigInteger* RefundablePayment::release_paidamount() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RefundablePayment.paidAmount)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = paidamount_;
  paidamount_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* RefundablePayment::_internal_mutable_paidamount() {
  
  if (paidamount_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    paidamount_ = p;
  }
  return paidamount_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* RefundablePayment::mutable_paidamount() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RefundablePayment.paidAmount)
  return _internal_mutable_paidamount();
}
inline void RefundablePayment::set_allocated_paidamount(::io::stakenet::orderbook::protos::BigInteger* paidamount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paidamount_;
  }
  if (paidamount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paidamount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paidamount, submessage_arena);
    }
    
  } else {
    
  }
  paidamount_ = paidamount;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.RefundablePayment.paidAmount)
}

// bytes paymentHash = 2;
inline void RefundablePayment::clear_paymenthash() {
  paymenthash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RefundablePayment::paymenthash() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
  return _internal_paymenthash();
}
inline void RefundablePayment::set_paymenthash(const std::string& value) {
  _internal_set_paymenthash(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
}
inline std::string* RefundablePayment::mutable_paymenthash() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
  return _internal_mutable_paymenthash();
}
inline const std::string& RefundablePayment::_internal_paymenthash() const {
  return paymenthash_.GetNoArena();
}
inline void RefundablePayment::_internal_set_paymenthash(const std::string& value) {
  
  paymenthash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RefundablePayment::set_paymenthash(std::string&& value) {
  
  paymenthash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
}
inline void RefundablePayment::set_paymenthash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  paymenthash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
}
inline void RefundablePayment::set_paymenthash(const void* value, size_t size) {
  
  paymenthash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
}
inline std::string* RefundablePayment::_internal_mutable_paymenthash() {
  
  return paymenthash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RefundablePayment::release_paymenthash() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
  
  return paymenthash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RefundablePayment::set_allocated_paymenthash(std::string* paymenthash) {
  if (paymenthash != nullptr) {
    
  } else {
    
  }
  paymenthash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), paymenthash);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.RefundablePayment.paymentHash)
}

// -------------------------------------------------------------------

// OrderSummary

// .io.stakenet.orderbook.protos.BigInteger price = 1;
inline bool OrderSummary::_internal_has_price() const {
  return this != internal_default_instance() && price_ != nullptr;
}
inline bool OrderSummary::has_price() const {
  return _internal_has_price();
}
inline void OrderSummary::clear_price() {
  if (GetArenaNoVirtual() == nullptr && price_ != nullptr) {
    delete price_;
  }
  price_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderSummary::_internal_price() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = price_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderSummary::price() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderSummary.price)
  return _internal_price();
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderSummary::release_price() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderSummary.price)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = price_;
  price_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderSummary::_internal_mutable_price() {
  
  if (price_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    price_ = p;
  }
  return price_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderSummary::mutable_price() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderSummary.price)
  return _internal_mutable_price();
}
inline void OrderSummary::set_allocated_price(::io::stakenet::orderbook::protos::BigInteger* price) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete price_;
  }
  if (price) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      price = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price, submessage_arena);
    }
    
  } else {
    
  }
  price_ = price;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderSummary.price)
}

// .io.stakenet.orderbook.protos.BigInteger amount = 2;
inline bool OrderSummary::_internal_has_amount() const {
  return this != internal_default_instance() && amount_ != nullptr;
}
inline bool OrderSummary::has_amount() const {
  return _internal_has_amount();
}
inline void OrderSummary::clear_amount() {
  if (GetArenaNoVirtual() == nullptr && amount_ != nullptr) {
    delete amount_;
  }
  amount_ = nullptr;
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderSummary::_internal_amount() const {
  const ::io::stakenet::orderbook::protos::BigInteger* p = amount_;
  return p != nullptr ? *p : *reinterpret_cast<const ::io::stakenet::orderbook::protos::BigInteger*>(
      &::io::stakenet::orderbook::protos::_BigInteger_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::BigInteger& OrderSummary::amount() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.OrderSummary.amount)
  return _internal_amount();
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderSummary::release_amount() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.OrderSummary.amount)
  
  ::io::stakenet::orderbook::protos::BigInteger* temp = amount_;
  amount_ = nullptr;
  return temp;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderSummary::_internal_mutable_amount() {
  
  if (amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::stakenet::orderbook::protos::BigInteger>(GetArenaNoVirtual());
    amount_ = p;
  }
  return amount_;
}
inline ::io::stakenet::orderbook::protos::BigInteger* OrderSummary::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.OrderSummary.amount)
  return _internal_mutable_amount();
}
inline void OrderSummary::set_allocated_amount(::io::stakenet::orderbook::protos::BigInteger* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete amount_;
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.OrderSummary.amount)
}

// -------------------------------------------------------------------

// ServerInMaintenance

// -------------------------------------------------------------------

// RentedChannel

// .io.stakenet.orderbook.protos.LndChannel lndChannel = 1;
inline bool RentedChannel::_internal_has_lndchannel() const {
  return value_case() == kLndChannel;
}
inline bool RentedChannel::has_lndchannel() const {
  return _internal_has_lndchannel();
}
inline void RentedChannel::set_has_lndchannel() {
  _oneof_case_[0] = kLndChannel;
}
inline void RentedChannel::clear_lndchannel() {
  if (_internal_has_lndchannel()) {
    delete value_.lndchannel_;
    clear_has_value();
  }
}
inline ::io::stakenet::orderbook::protos::LndChannel* RentedChannel::release_lndchannel() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannel.lndChannel)
  if (_internal_has_lndchannel()) {
    clear_has_value();
      ::io::stakenet::orderbook::protos::LndChannel* temp = value_.lndchannel_;
    value_.lndchannel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::stakenet::orderbook::protos::LndChannel& RentedChannel::_internal_lndchannel() const {
  return _internal_has_lndchannel()
      ? *value_.lndchannel_
      : *reinterpret_cast< ::io::stakenet::orderbook::protos::LndChannel*>(&::io::stakenet::orderbook::protos::_LndChannel_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::LndChannel& RentedChannel::lndchannel() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannel.lndChannel)
  return _internal_lndchannel();
}
inline ::io::stakenet::orderbook::protos::LndChannel* RentedChannel::_internal_mutable_lndchannel() {
  if (!_internal_has_lndchannel()) {
    clear_value();
    set_has_lndchannel();
    value_.lndchannel_ = CreateMaybeMessage< ::io::stakenet::orderbook::protos::LndChannel >(
        GetArenaNoVirtual());
  }
  return value_.lndchannel_;
}
inline ::io::stakenet::orderbook::protos::LndChannel* RentedChannel::mutable_lndchannel() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannel.lndChannel)
  return _internal_mutable_lndchannel();
}

// .io.stakenet.orderbook.protos.ConnextChannel connextChannel = 2;
inline bool RentedChannel::_internal_has_connextchannel() const {
  return value_case() == kConnextChannel;
}
inline bool RentedChannel::has_connextchannel() const {
  return _internal_has_connextchannel();
}
inline void RentedChannel::set_has_connextchannel() {
  _oneof_case_[0] = kConnextChannel;
}
inline void RentedChannel::clear_connextchannel() {
  if (_internal_has_connextchannel()) {
    delete value_.connextchannel_;
    clear_has_value();
  }
}
inline ::io::stakenet::orderbook::protos::ConnextChannel* RentedChannel::release_connextchannel() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.RentedChannel.connextChannel)
  if (_internal_has_connextchannel()) {
    clear_has_value();
      ::io::stakenet::orderbook::protos::ConnextChannel* temp = value_.connextchannel_;
    value_.connextchannel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::stakenet::orderbook::protos::ConnextChannel& RentedChannel::_internal_connextchannel() const {
  return _internal_has_connextchannel()
      ? *value_.connextchannel_
      : *reinterpret_cast< ::io::stakenet::orderbook::protos::ConnextChannel*>(&::io::stakenet::orderbook::protos::_ConnextChannel_default_instance_);
}
inline const ::io::stakenet::orderbook::protos::ConnextChannel& RentedChannel::connextchannel() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.RentedChannel.connextChannel)
  return _internal_connextchannel();
}
inline ::io::stakenet::orderbook::protos::ConnextChannel* RentedChannel::_internal_mutable_connextchannel() {
  if (!_internal_has_connextchannel()) {
    clear_value();
    set_has_connextchannel();
    value_.connextchannel_ = CreateMaybeMessage< ::io::stakenet::orderbook::protos::ConnextChannel >(
        GetArenaNoVirtual());
  }
  return value_.connextchannel_;
}
inline ::io::stakenet::orderbook::protos::ConnextChannel* RentedChannel::mutable_connextchannel() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.RentedChannel.connextChannel)
  return _internal_mutable_connextchannel();
}

inline bool RentedChannel::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void RentedChannel::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline RentedChannel::ValueCase RentedChannel::value_case() const {
  return RentedChannel::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LndChannel

// bytes nodePublicKey = 1;
inline void LndChannel::clear_nodepublickey() {
  nodepublickey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LndChannel::nodepublickey() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
  return _internal_nodepublickey();
}
inline void LndChannel::set_nodepublickey(const std::string& value) {
  _internal_set_nodepublickey(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
}
inline std::string* LndChannel::mutable_nodepublickey() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
  return _internal_mutable_nodepublickey();
}
inline const std::string& LndChannel::_internal_nodepublickey() const {
  return nodepublickey_.GetNoArena();
}
inline void LndChannel::_internal_set_nodepublickey(const std::string& value) {
  
  nodepublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LndChannel::set_nodepublickey(std::string&& value) {
  
  nodepublickey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
}
inline void LndChannel::set_nodepublickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nodepublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
}
inline void LndChannel::set_nodepublickey(const void* value, size_t size) {
  
  nodepublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
}
inline std::string* LndChannel::_internal_mutable_nodepublickey() {
  
  return nodepublickey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LndChannel::release_nodepublickey() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
  
  return nodepublickey_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LndChannel::set_allocated_nodepublickey(std::string* nodepublickey) {
  if (nodepublickey != nullptr) {
    
  } else {
    
  }
  nodepublickey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodepublickey);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.LndChannel.nodePublicKey)
}

// string channelId = 2;
inline void LndChannel::clear_channelid() {
  channelid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LndChannel::channelid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.LndChannel.channelId)
  return _internal_channelid();
}
inline void LndChannel::set_channelid(const std::string& value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.LndChannel.channelId)
}
inline std::string* LndChannel::mutable_channelid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.LndChannel.channelId)
  return _internal_mutable_channelid();
}
inline const std::string& LndChannel::_internal_channelid() const {
  return channelid_.GetNoArena();
}
inline void LndChannel::_internal_set_channelid(const std::string& value) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LndChannel::set_channelid(std::string&& value) {
  
  channelid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.LndChannel.channelId)
}
inline void LndChannel::set_channelid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.LndChannel.channelId)
}
inline void LndChannel::set_channelid(const char* value, size_t size) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.LndChannel.channelId)
}
inline std::string* LndChannel::_internal_mutable_channelid() {
  
  return channelid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LndChannel::release_channelid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.LndChannel.channelId)
  
  return channelid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LndChannel::set_allocated_channelid(std::string* channelid) {
  if (channelid != nullptr) {
    
  } else {
    
  }
  channelid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channelid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.LndChannel.channelId)
}

// bytes fundingTransaction = 3;
inline void LndChannel::clear_fundingtransaction() {
  fundingtransaction_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LndChannel::fundingtransaction() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
  return _internal_fundingtransaction();
}
inline void LndChannel::set_fundingtransaction(const std::string& value) {
  _internal_set_fundingtransaction(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
}
inline std::string* LndChannel::mutable_fundingtransaction() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
  return _internal_mutable_fundingtransaction();
}
inline const std::string& LndChannel::_internal_fundingtransaction() const {
  return fundingtransaction_.GetNoArena();
}
inline void LndChannel::_internal_set_fundingtransaction(const std::string& value) {
  
  fundingtransaction_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LndChannel::set_fundingtransaction(std::string&& value) {
  
  fundingtransaction_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
}
inline void LndChannel::set_fundingtransaction(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fundingtransaction_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
}
inline void LndChannel::set_fundingtransaction(const void* value, size_t size) {
  
  fundingtransaction_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
}
inline std::string* LndChannel::_internal_mutable_fundingtransaction() {
  
  return fundingtransaction_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LndChannel::release_fundingtransaction() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
  
  return fundingtransaction_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LndChannel::set_allocated_fundingtransaction(std::string* fundingtransaction) {
  if (fundingtransaction != nullptr) {
    
  } else {
    
  }
  fundingtransaction_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fundingtransaction);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.LndChannel.fundingTransaction)
}

// int32 outputIndex = 4;
inline void LndChannel::clear_outputindex() {
  outputindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LndChannel::_internal_outputindex() const {
  return outputindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LndChannel::outputindex() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.LndChannel.outputIndex)
  return _internal_outputindex();
}
inline void LndChannel::_internal_set_outputindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  outputindex_ = value;
}
inline void LndChannel::set_outputindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_outputindex(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.LndChannel.outputIndex)
}

// string fundingTxidStr = 5;
inline void LndChannel::clear_fundingtxidstr() {
  fundingtxidstr_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LndChannel::fundingtxidstr() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
  return _internal_fundingtxidstr();
}
inline void LndChannel::set_fundingtxidstr(const std::string& value) {
  _internal_set_fundingtxidstr(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
}
inline std::string* LndChannel::mutable_fundingtxidstr() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
  return _internal_mutable_fundingtxidstr();
}
inline const std::string& LndChannel::_internal_fundingtxidstr() const {
  return fundingtxidstr_.GetNoArena();
}
inline void LndChannel::_internal_set_fundingtxidstr(const std::string& value) {
  
  fundingtxidstr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LndChannel::set_fundingtxidstr(std::string&& value) {
  
  fundingtxidstr_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
}
inline void LndChannel::set_fundingtxidstr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fundingtxidstr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
}
inline void LndChannel::set_fundingtxidstr(const char* value, size_t size) {
  
  fundingtxidstr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
}
inline std::string* LndChannel::_internal_mutable_fundingtxidstr() {
  
  return fundingtxidstr_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LndChannel::release_fundingtxidstr() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
  
  return fundingtxidstr_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LndChannel::set_allocated_fundingtxidstr(std::string* fundingtxidstr) {
  if (fundingtxidstr != nullptr) {
    
  } else {
    
  }
  fundingtxidstr_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fundingtxidstr);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.LndChannel.fundingTxidStr)
}

// -------------------------------------------------------------------

// ConnextChannel

// string nodePublicIdentifier = 1;
inline void ConnextChannel::clear_nodepublicidentifier() {
  nodepublicidentifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnextChannel::nodepublicidentifier() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
  return _internal_nodepublicidentifier();
}
inline void ConnextChannel::set_nodepublicidentifier(const std::string& value) {
  _internal_set_nodepublicidentifier(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
}
inline std::string* ConnextChannel::mutable_nodepublicidentifier() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
  return _internal_mutable_nodepublicidentifier();
}
inline const std::string& ConnextChannel::_internal_nodepublicidentifier() const {
  return nodepublicidentifier_.GetNoArena();
}
inline void ConnextChannel::_internal_set_nodepublicidentifier(const std::string& value) {
  
  nodepublicidentifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ConnextChannel::set_nodepublicidentifier(std::string&& value) {
  
  nodepublicidentifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
}
inline void ConnextChannel::set_nodepublicidentifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nodepublicidentifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
}
inline void ConnextChannel::set_nodepublicidentifier(const char* value, size_t size) {
  
  nodepublicidentifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
}
inline std::string* ConnextChannel::_internal_mutable_nodepublicidentifier() {
  
  return nodepublicidentifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnextChannel::release_nodepublicidentifier() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
  
  return nodepublicidentifier_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnextChannel::set_allocated_nodepublicidentifier(std::string* nodepublicidentifier) {
  if (nodepublicidentifier != nullptr) {
    
  } else {
    
  }
  nodepublicidentifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodepublicidentifier);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.ConnextChannel.nodePublicIdentifier)
}

// string channelId = 2;
inline void ConnextChannel::clear_channelid() {
  channelid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnextChannel::channelid() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.ConnextChannel.channelId)
  return _internal_channelid();
}
inline void ConnextChannel::set_channelid(const std::string& value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.ConnextChannel.channelId)
}
inline std::string* ConnextChannel::mutable_channelid() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.ConnextChannel.channelId)
  return _internal_mutable_channelid();
}
inline const std::string& ConnextChannel::_internal_channelid() const {
  return channelid_.GetNoArena();
}
inline void ConnextChannel::_internal_set_channelid(const std::string& value) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ConnextChannel::set_channelid(std::string&& value) {
  
  channelid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.ConnextChannel.channelId)
}
inline void ConnextChannel::set_channelid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.ConnextChannel.channelId)
}
inline void ConnextChannel::set_channelid(const char* value, size_t size) {
  
  channelid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.ConnextChannel.channelId)
}
inline std::string* ConnextChannel::_internal_mutable_channelid() {
  
  return channelid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnextChannel::release_channelid() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.ConnextChannel.channelId)
  
  return channelid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnextChannel::set_allocated_channelid(std::string* channelid) {
  if (channelid != nullptr) {
    
  } else {
    
  }
  channelid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channelid);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.ConnextChannel.channelId)
}

// string channelAddress = 3;
inline void ConnextChannel::clear_channeladdress() {
  channeladdress_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnextChannel::channeladdress() const {
  // @@protoc_insertion_point(field_get:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
  return _internal_channeladdress();
}
inline void ConnextChannel::set_channeladdress(const std::string& value) {
  _internal_set_channeladdress(value);
  // @@protoc_insertion_point(field_set:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
}
inline std::string* ConnextChannel::mutable_channeladdress() {
  // @@protoc_insertion_point(field_mutable:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
  return _internal_mutable_channeladdress();
}
inline const std::string& ConnextChannel::_internal_channeladdress() const {
  return channeladdress_.GetNoArena();
}
inline void ConnextChannel::_internal_set_channeladdress(const std::string& value) {
  
  channeladdress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ConnextChannel::set_channeladdress(std::string&& value) {
  
  channeladdress_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
}
inline void ConnextChannel::set_channeladdress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channeladdress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
}
inline void ConnextChannel::set_channeladdress(const char* value, size_t size) {
  
  channeladdress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
}
inline std::string* ConnextChannel::_internal_mutable_channeladdress() {
  
  return channeladdress_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnextChannel::release_channeladdress() {
  // @@protoc_insertion_point(field_release:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
  
  return channeladdress_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnextChannel::set_allocated_channeladdress(std::string* channeladdress) {
  if (channeladdress != nullptr) {
    
  } else {
    
  }
  channeladdress_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channeladdress);
  // @@protoc_insertion_point(field_set_allocated:io.stakenet.orderbook.protos.ConnextChannel.channelAddress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace orderbook
}  // namespace stakenet
}  // namespace io

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::io::stakenet::orderbook::protos::Order_OrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::stakenet::orderbook::protos::Order_OrderType>() {
  return ::io::stakenet::orderbook::protos::Order_OrderType_descriptor();
}
template <> struct is_proto_enum< ::io::stakenet::orderbook::protos::Order_OrderSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::stakenet::orderbook::protos::Order_OrderSide>() {
  return ::io::stakenet::orderbook::protos::Order_OrderSide_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_stakenet_2forderbook_2fmodels_2eproto
